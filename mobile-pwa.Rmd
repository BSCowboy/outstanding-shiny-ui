# `{shinyMobile}` and PWA {#mobile-pwa}
Transforming a classic Shiny app into a PWA is a game changer for end users.
The first step is to setup a valid web manifest with icons and favicon.

## Manual approach

Below, we review one by one the steps necessary to convert a shiny app to a PWA.
To get a goo idea of what we exactly miss, we leverage the `Application` tab of the
developer tools.

The overall expected result is shown Figure \@ref(fig:mobile-pwa). Alternatively, one
may use the Google Lighthouse utility to provide a general diagnosis to the app.
There are many categories like performance, accessibility. In our case, let's just select
the PWA category, select the mobile device radio and click on generate a report.

```{r mobile-pwa, echo=FALSE, fig.cap='Application tab of the developers tools', out.width='50%', fig.align = "default", fig.show = "hold"}
knitr::include_graphics("images/mobile/mobile-pwa-application.png")
knitr::include_graphics("images/mobile/mobile-pwa-lighthouse.png")
```

According to the diagnostic result displayed on Figure \@ref(fig:mobile-pwa-lighthouse-result), we miss many elements:

  - No manifest.
  - No service worker.
  - No icons. 

```{r mobile-pwa-lighthouse-result, echo=FALSE, fig.cap='Lighthouse audit result', out.width='100%'}
knitr::include_graphics("images/mobile/mobile-pwa-lighthouse-result.png")
```

Let's first create the manifest.

### Create the manifest
We want to create a JSON configuration file like this:

```javascript
{
  "short_name": "My App",
  "name": "Super amazing app",
  "description": "This app is just mind blowing",
  "icons": [
    {
      "src": "icons/icon.png",
      "type": "image/png",
      "sizes": "192x192"
    }
    // ...
  ],
  "start_url": "https://whatever-url.com/",
  "background_color": "#3367D6",
  "display": "standalone",
  "scope": "/",
  "theme_color": "#3367D6"
}
```

This file has to be accessible by the app so best practice is to put it in the `/www` folder.
and images are hosted in a sub-directory `/www/icons`.


`{shinyMobile}` has a create manifest function:

```{r}
create_manifest <- function(path, name = "My Progressive Web App", shortName = "My App",
                            description = "What it does!", lang = "en-US",
                            startUrl = "/", display = c("minimal-ui", "standalone", "fullscreen", "browser"),
                            background_color = "#ffffff", theme_color = "#ffffff") {

  display <- match.arg(display)

  manifest <- list(
    name = name,
    short_name = shortName,
    description = description,
    lang = lang,
    start_url = startUrl,
    display = display,
    background_color = background_color,
    theme_color = theme_color,
    icons = data.frame(
      src = "icons/logo-144.png",
      sizes = "144x144"
    )
  )

  # create /www folder if does not exist yet
  if (!dir.exists(paste0(path, "/www"))) {
    dir.create(paste0(path, "/www/icons"), recursive = TRUE)
  }
  jsonlite::write_json(
    manifest, 
    path = paste0(path, "/www/manifest.webmanifest"),
    pretty = TRUE,
    auto_unbox = TRUE
  )
}
```

This function may be included in `f7_page` so that any app that uses it creates a manifest when the user asks for it.
We could for instance add an extra `pwa_options` parameter that takes a list of properties related
to the manifest:

```{r, eval=FALSE}
f7_page <- function(
  ..., 
  navbar, 
  toolbar, 
  title = NULL, 
  options = NULL, 
  pwa_options = list(
    name = "My App",
    shortName = "My App",
    description = "What it does!",
    lang = "en-US",
    startUrl = "/",
    display = "standalone",
    background_color = "#ffffff",
    theme_color = "#ffffff",
    icons = data.frame(
      src = "icons/logox144.png",
      sizes = "144x144"
    )
  )
) {

  do.call(create_manifest, args = c(list(path = "."), pwa_options))

  config_tag <- shiny::tags$script(
    type = "application/json",
    `data-for` = "app",
    jsonlite::toJSON(
      x = options,
      auto_unbox = TRUE,
      json_verbatim = TRUE
    )
  )

  # create body_tag
  body_tag <- tags$body(
    tags$div(
      id = "app",
      tags$div(
        class = "view view-main",
        tags$div(
          class = "page",
          navbar,
          toolbar,
          tags$div(
            class = "page-content",
            ...
          )
        )
      )
    ),
    config_tag
  )

  tagList(
    tags$head(
      tags$meta(charset = "utf-8"),
      tags$meta(
        name = "viewport",
        content = "width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"
      ),
      tags$meta(
        name = "apple-mobile-web-app-capable",
        content = "yes"
      ),
      tags$meta(
        name = "theme-color",
        content = "#2196f3"
      ),
      tags$title(title),
      tags$link(rel="manifest",href="manifest.webmanifest"),
      tags$script(async = NA, src="https://cdn.jsdelivr.net/npm/pwacompat", crossorigin="anonymous"),
      tags$link(
        rel="icon",
        type="image/png",
        href="icons/logo-144.png",
        sizes="144x144"
      )
    ),
    add_dependencies(
      body_tag,
      deps = c("framework7", "shinyMobile")
    )
  )
}
```

`do.call` is particularly handy in that case. The chosen path is `.` that is the app
root so that `www` is properly created. 

As we use the google PWA compatibility script, we have to include at least one icon like `<link rel="icon" type="image/png" href="res/icon-128.png" sizes="128x128" />`. All other elements are generated by the script
itself. 

Elements are included in the `head` in the following order:

```html
<link rel="manifest" href="manifest.webmanifest" />
<script async src="path/to/pwacompat.min.js"></script>
<!-- include icon also from manifest -->
<link rel="icon" type="image/png" href="icons/logo-144.png" sizes="144x144" />
```

### Service worker and offline page
The second mandatory step to make our app installable is the service worker.
We borrow the code from [web.dev](https://web.dev/offline-fallback-page/) and save it
to `service-worker.js` in the `www` folder:

```javascript
/*
Copyright 2015, 2019, 2020 Google LLC. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

// Incrementing OFFLINE_VERSION will kick off the install event and force
// previously cached resources to be updated from the network.
const OFFLINE_VERSION = 1;
const CACHE_NAME = "offline";
// Customize this with a different URL if needed.
const OFFLINE_URL = "offline.html";

self.addEventListener("install", (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(CACHE_NAME);
      // Setting {cache: 'reload'} in the new request will ensure that the
      // response isn't fulfilled from the HTTP cache; i.e., it will be from
      // the network.
      await cache.add(new Request(OFFLINE_URL, { cache: "reload" }));
    })()
  );
  // Force the waiting service worker to become the active service worker.
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    (async () => {
      // Enable navigation preload if it's supported.
      // See https://developers.google.com/web/updates/2017/02/navigation-preload
      if ("navigationPreload" in self.registration) {
        await self.registration.navigationPreload.enable();
      }
    })()
  );

  // Tell the active service worker to take control of the page immediately.
  self.clients.claim();
});

self.addEventListener("fetch", (event) => {
  // We only want to call event.respondWith() if this is a navigation request
  // for an HTML page.
  if (event.request.mode === "navigate") {
    event.respondWith(
      (async () => {
        try {
          // First, try to use the navigation preload response if it's supported.
          const preloadResponse = await event.preloadResponse;
          if (preloadResponse) {
            return preloadResponse;
          }

          // Always try the network first.
          const networkResponse = await fetch(event.request);
          return networkResponse;
        } catch (error) {
          // catch is only triggered if an exception is thrown, which is likely
          // due to a network error.
          // If fetch() returns a valid HTTP response with a response code in
          // the 4xx or 5xx range, the catch() will NOT be called.
          console.log("Fetch failed; returning offline page instead.", error);

          const cache = await caches.open(CACHE_NAME);
          const cachedResponse = await cache.match(OFFLINE_URL);
          return cachedResponse;
        }
      })()
    );
  }

  // If our if() condition is false, then this fetch handler won't intercept the
  // request. If there are any other fetch handlers registered, they will get a
  // chance to call event.respondWith(). If no fetch handlers call
  // event.respondWith(), the request will be handled by the browser as if there
  // were no service worker involvement.
});
```

This service worker redirects the end user to the offline cached page whenever
the app is offline, thereby offering a better user experience.

The next step is to mention and register the service worker. Framework7 has a dedicated module in the 
app configuration. We modify `init.js` and run `compress_js()` to update the minified file:

```javascript
serviceWorker: {
  path: 'service-worker.js',
  scope: '/'
}
```

The new standard impose to return a valid response when the app is offline. We are going 
to design a basic offline page:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>You are offline</title>

    <!-- inline the webpage's stylesheet -->
    <style>
      body {
        font-family: helvetica, arial, sans-serif;
        margin: 2em;
      }

      h1 {
        font-style: italic;
        color: #373fff;
      }

      p {
        margin-block: 1rem;
      }

      button {
        display: block;
      }
    </style>
  </head>
  <body>
    <h1>You are offline</h1>

    <p>Click the button below to try reloading.</p>
    <button type="button">⤾ Reload</button>

    <!-- inline the webpage's javascript file -->
    <script>
      document.querySelector("button").addEventListener("click", () => {
        window.location.reload();
      });
    </script>
  </body>
</html>
```

## Automated approach

`{charpente}` has tools to help designing a PWA. The `set_pwa` function is a wrapper
that does all the previously mentioned step in only one line of code. There are however few
prerequisites:

  - The app must belong to a package.
  - The function must target the app directory.
  
### With `{shinyMobile}`
As a reminder, the demonstration apps are located within the `inst/examples` folder.
We create the `pwa-app` sub-folder and the `app.R` file:

```{r, eval=FALSE}
library(shiny)
library(shinyMobile)

ui <- f7_page(
  "Test",
  navbar = f7_navbar("Title"),
  toolbar = f7_toolbar(),
  title = "shinyMobile"
)

server <- function(input, output, session) {}
shinyApp(ui, server)
```

Then we set the PWA configuration:

```{r, eval=FALSE}
set_pwa("inst/examples/pwa-app")
```

This function generates a `manifest.webmanifest` file, downloads the Google PWA compatibility
script, adds a custom dependency pointing to the `manifest.webmanifest` file and a `144x144` icon file,
copies a boilerplate `service-worker.js` with its `offline.html` page and optionally registers the
service worker (code borrowed from [web.dev](https://web.dev/offline-fallback-page/#registering-the-service-worker):

```javascript
window.addEventListener('load', () => {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js');
  };
});
```

In the `{shinyMobile}` case, as Framework7 already registers any linked service
worker, we don't need that initialization script. Therefore, we actually call:

```{r, eval=FALSE}
set_pwa("inst/examples/pwa-app", register_service_worker = FALSE)
```

Importantly, this functions does not handle icon creation. There are tools such as 
[appsco](https://appsco.pe/developer/splash-screens) and 
[app-manifest](https://app-manifest.firebaseapp.com), to create 
those custom icons and splash screens, if you need to.
  
### Without `{shinyMobile}`
To show that the process is generalizable to any HTML template, even vanilla shiny,
let's consider the following example. 