[["index.html", "Outstanding User Interfaces with Shiny Welcome Is this book for me? Learning objectives 0.1 Why another Shiny related book? Book structure 0.2 Code structure Preliminary exercices Extra material About RinteRface Acknowledgements Packages", " Outstanding User Interfaces with Shiny David Granjon 2021-02-16 Welcome This book is still under active development and intended for a 2021 Q2 release in the R Series by Chapman &amp; Hall. Is this book for me? Before going further, the reader must: Be comfortable with basic R structures and concepts, functional and object oriented programming (R6) Have solid knowledge of Shiny Basic knowledge in HTML and JavaScript is a plus but not mandatory. If you fulfill the above prerequisites, you should read this book if you answer yes to the following questions: Do you want to know how to develop shiny apps with a more professional look and feel? Have you ever wondered how to design new input widgets to unleash interactivity? Are you simply curious about what happens under the hood? Learning objectives This book will help you to: Manipulate Shiny tags from R to create custom layouts Harness the power of CSS and JavaScript to quickly design apps standing out from the pack Discover the steps to import and convert existing web frameworks like Bootstrap 4, framework7 Learn how Shiny internally deals with inputs Learn more about less documented Shiny mechanisms (websockets, sessions, …) 0.1 Why another Shiny related book? There are various Shiny focused resources introducing basic as well as advanced topics such as modules and Javascript/R interactions, however, handling advanced user interfaces design was never an emphasis. Clients often desire custom templates, yet this generally exceeds core features of Shiny (not out of the box). Generally, R App developers lack a significant background in web development and often find this requirement overwhelming. It was this sentiment that motivated writing this book, namely to provide readers the necessary knowledge to extend Shiny’s layout, input widgets and output elements. This project officially started at the end of 2018 but was stopped when Joe Cheng revealed the upcoming Mastering Shiny Book. Fortunately, the later, does not cover a lot about the customization of Shiny user interfaces. Besides, this book may constitute a good complement to the work in progress Engineering Production-Grade Shiny Apps by the ThinkR team, where the link between Shiny and CSS/JavaScript is covered. For a deep dive into JavaScript and R interactions, the upcoming book by John Coene covers topics like htmlWidgets, interactive documents and computations. Book structure This book is organized into eight parts. Part 1 demonstrates the link between Shiny and the classic web languages like HTML, CSS and JavaScript. We gradually introduce necessary web development knowledge to be able to read the book. We finish by exploring the web dependencies behind Shiny such as Bootstrap and jQuery. In part 2, we dive into the {htmltools} (Cheng et al. 2021) package, providing functions to create and manipulate HTML tags from R as well as manage web dependencies. Part 3 focuses on CSS and Sass. We provide the reader with basic CSS knowledge to get the most out of Sass, a powerful tool to seamlessly alter Shiny apps style, in a more reproducible manner. All along this part, we showcase examples from the R community like {fresh} (Perrier and Meyer 2020b) and {bslib} (Sievert and Cheng 2021), to significantly beautify apps with only few lines of code. Part 4 contains chapters dedicated to the Shiny input system. This part starts with a JavaScript hands on, then exposes how Shiny works under the hood by introducing the websockets which allows the communication between R and JavaScript. We explore the Shiny input life cycle, that is how they are created and updated. We expose JS techniques to get rid of unnecessary renderUI patterns that may speed up Shiny apps. This part contains many hidden gems to significantly and quickly enhance apps. Part 5 focuses on the development of a new template for Shiny by demonstrating examples from the {tablerDash} (Granjon 2020d) package. These, and more may be explored further as part of the RinteRface project. This case study mobilizes all knowledge acquired in the previous parts. Part 6 introduces a new opinionated package, {charpente} (Granjon and Coene 2021), that substantially reduce the burden of JavaScript management during the development of Shiny extensions. Part 7 dives into mobile web development through a practical study involving a rework of {shinyMobile} (Granjon, Perrier, and Rudolf 2020). We give a brief introduction to the progressive web application world with some patterns to get started like service workers, web manifests, offline pages. Part 8 exposes other alternatives like React, taking examples from the {reactR} (Inc et al. 2020) package. Parts are sorted by difficulty level, the last one being the most technical. However, this does not mean the reader must read all chapters. Given the very heterogeneous background of the community, some people may focus on the JavaScript section, while others will read the Sass part or the mobile development examples. Some patterns exposed in this book may apply to classic Shiny apps projects, that are not necessarily meant to extend Shiny per se, but may need a highly customized experience. Beyond the aesthetic aspect, this book tries to expose best practices to develop optimized shiny apps! By the end of that book, the reader should be able to entirely customize Shiny in a reasonable amount of time. 0.2 Code structure This book has a side package containing all the necessary material to run the code without having to reload each previous snippet. remotes::install_github(&quot;DivadNojnarg/outstanding-shiny-ui-code &quot;) It covers Chapters 11, 14 and the whole Practice section. There is another good reason for this package: provide a robust method to bundle JavaScript/CSS code along side any shiny app. Indeed, it is quite tempting to proceed as below: ui &lt;- fluidPage( tags$script( &quot;$(function() { Shiny.addCustomMessageHandler(&#39;hello&#39;, function(message) { alert(message); }); }); &quot; ), actionButton(&quot;go&quot;, &quot;Send&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$go, { session$sendCustomMessage(&quot;hello&quot;, message = &quot;plop&quot;) }) } shinyApp(ui, server) It is fine if the app purpose is a simple demonstration. In our case, since we aim at providing reusable template elements, we need a better approach, that will be described later. Preliminary exercices Before starting with technical details, we propose to play a little game. Among all the images shown, what are the ones corresponding to shiny apps? Extra material This book may serve as material for workshops. See below a list of recent events. e-Rum 2020 Novartis associates Mustapha Larbaoui and David Granjon gave a workshop entitled “Advanced User Interfaces for Shiny Developers” at the latest 2020 virtual e-Rum conference whose detailed agenda is available here. This two hours workshop takes a lot of inspiration on this book. An RStudio Cloud dedicated project is deployed here and slides are located here. R/Pharma 2020 This books served as resource for the 2020 R/Pharma Unleash Shiny workshop held by John Coene, Colin Fay and David Granjon. Slides are available here and exercises accessible from here. This workshop expects an higher level than the e-Rum one. About RinteRface The RinteRface project is an initiative aiming to provide one of the most famous HTML templates to Shiny. Everything started by the collaboration of John Coene and David Granjon early 2018 on {shinybulma} (Coene and Granjon 2020) to officially release RinteRface November 2018 with {shinydashboardPlus} (Granjon 2020c), {bs4Dash} (Granjon 2020a) as line-up packages. FIGURE 0.1: Official release of RinteRface, November 28 2018 The biggest RinteRface accomplishment is probably the work in progress {shinyMobile} package, which was initially called {shinyF7}, in collaboration with the dreamRs team. Since 2019, RinteRface has been involved in various R related events like local R meetups or conferences (Zurich R User Group, baselR, useR2019, satRdayNeuchatel2020, e-Rum2020, RPharma2020). RinteRface is a contributor in the Shiny Developers Series, hosted by Eric Nantz, also known as the theRcast. RinteRface work has been awarded several times at the 2 latest shiny contests (2019 and 2020), through contributions like: A virtual lab for teaching physiology (2019), the Apps.Physiol plateform, fuelled by {bs4Dash} and hosted in {CaPO4Sim} (Granjon 2020b) FIGURE 0.2: The virtual patient simulator of {CaPO4Sim} {deminR} (Devaux and Granjon 2020), a minesweeper for R (2020), powered by {shinyMobile} FIGURE 0.3: {deminR}, a minesweeper for R RinteRface is very grateful to the R community and this book is a sort of acknowledgment! Acknowledgements I am very grateful to Douglas Robinson for proof reading the book and fixing many typos it contained A special thanks to my friends John and Victor for contributing to RinteRface Thanks to the eRum organizers for inviting me to the virtual e-Rum2020 conference RinteRface and this book won’t exist without the amazing R community. Thanks for their valuable feedback Packages This book was built with R version 3.6.1 (2019-07-05) and the following packages: package version source apexcharter 0.1.8 CRAN (R 3.6.2) blogdown 1.1 CRAN (R 3.6.2) bs4Dash 2.0.0.9000 local bslib 0.2.4 CRAN (R 3.6.1) CaPO4Sim 0.2.0.9000 local charpente 0.0.0.9000 Github (RinteRface/charpente@e73723c) deminR 0.0.0.9000 Github (DivadNojnarg/deminR@e0bf665) dplyr 1.0.3 CRAN (R 3.6.2) fresh 0.2.0 CRAN (R 3.6.1) ggplot2 3.3.3 CRAN (R 3.6.2) golem 0.3.0 Github (ThinkR-open/golem@558a715) htmltools 0.5.1.9000 Github (rstudio/htmltools@e7f0393) httpuv 1.5.5 CRAN (R 3.6.2) jstools 0.1.0 Github (dreamRs/jstools@5689973) magrittr 2.0.1 CRAN (R 3.6.2) purrr 0.3.4 CRAN (R 3.6.2) reactR 0.4.3 Github (react-R/reactR@da3e6af) scales 1.1.1 CRAN (R 3.6.2) shiny 1.6.0 CRAN (R 3.6.2) shinybulma 0.0.2.9000 local shinydashboard 0.7.1 CRAN (R 3.6.0) shinydashboardPlus 2.0.0.9000 local shinyjs 2.0.0 CRAN (R 3.6.1) shinyMobile 1.0.0.9000 local shinyWidgets 0.5.6 CRAN (R 3.6.2) tablerDash 0.1.5 Github (RinteRface/tablerDash@341efde) testthat 3.0.1 CRAN (R 3.6.2) thematic 0.1.1.9000 Github (rstudio/thematic@45454fa) websocket 1.3.1 CRAN (R 3.6.2) References "],["foreword.html", "Foreword", " Foreword By Kenton Russel aka @timelyportfolio Since the initial commit (https://github.com/rstudio/shiny/commit/e28b3da1badfecb34235e74a43aac4e8da1641bc) of Shiny in June 2012, the project has grown rapidly with users around the world across nearly every domain. Strangely though there are nearly zero comprehensive resources collecting the scattered wisdom and experience of thousands of Shiny users and developers into a single definitive resource. Fortunately, this book addresses the gap offering a detailed up-to-date compilation on Shiny to benefit users of all skill levels from beginner to advanced. As I read through the early drafts, I kept saying to myself with a smile, “Yes, finally”. This book fills a void covering some topics for which an Internet search might yield no useful results. Successful open source requires skillful developers, active engaged users, and helpful supporters. In the R/Shiny community, David Granjon, PhD fulfills all three roles as a prolific R package creator, educated and thoughtful user with domain expertise, and educator (workshops, posts, and forum responses). I cannot think of anyone more qualified to write a book on Shiny, and I am so happy that David has spent the time to generously share his wisdom and experience in this excellent resource. "],["web-intro.html", "Chapter 1 Shiny and the Web 1.1 Shiny generates HTML code from R 1.2 HTML 101", " Chapter 1 Shiny and the Web Shiny is designed so that, as an R user, you don’t need to learn about the details of HTML … — Hadley Wickham {shiny} (Chang et al. 2021) allows the development of web applications with R in minutes. Let’s face it: this is quite mind blowing! While this may not be a production ready app, it will still be a fully functional, working prototype. Believe me, doing a web application with pure HTML/CSS and JavaScript is more difficult, especially for someone with a non-web developer background. We first load {shiny}: library(shiny) 1.1 Shiny generates HTML code from R Let’s start with a little exercise: Run the following code: p(&quot;Hello World&quot;) Copy and paste this code to the R console. What do you observe? Notice the output format is an example of an HTML tag. The p function generates HTML (see chapter 3). The main difference between HTML tags and Shiny tags is the absence of closing tag for Shiny. For instance, in raw HTML, we expect &lt;p&gt; to be closed by &lt;/p&gt;. In Shiny, we only call p(...), where ... may be attributes like class/id or children tags. For a R developer, being able to generate HTML code from R allows to remain focused on the main task instead of the web development burdens. As stated in the general introduction 0.1, a production app sometimes needs to custom elements that are not contained or hidden in Shiny’s core. Is a Shiny app less customizable than a classic web app? Not at all! Under the hood, Shiny has its own engine to build HTML tags, through R, meaning that all HTML elements are available. You may also include any custom JavaScript code. 1.2 HTML 101 This chapter provides a short introduction to the 3 main web languages, namely HTML, CSS and JavaScript. The following content is crucial to understand part 3 about HTML generation from R. 1.2.1 HTML Basics HTML (Hypertext Markup Language) is derived from SGML (Standard Generalized markup Language). An HTML file contains tags that may be divided into 2 categories: paired-tags: the text is inserted between the opening and the closing tag closing-tags &lt;!-- paired-tags --&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;!-- self-closing tags --&gt; &lt;iframe/&gt; &lt;img/&gt; &lt;input/&gt; &lt;br/&gt; Tags may be divided into 3 categories, based on their role: structure tags: they constitute the skeleton of the HTML page (&lt;title&gt;&lt;/title&gt;, &lt;head&gt;&lt;/head&gt;, &lt;body&gt;&lt;/body&gt;) control tags: script, inputs and buttons (and more). Their role is to include external resources, provide interactivity with the user formatting tags: to control the size, font of the wrapped text Finally, we distinguish block and inline elements: block elements may contain other tags and take the full width (block or inline). &lt;div&gt;&lt;/div&gt; is the most commonly used block element. All elements of a block are printed on top of each others inline elements (for instance &lt;span&gt;&lt;/span&gt;, &lt;a&gt;&lt;/a&gt;) are printed on the same line. They can not contain block tags but may contain other nested inline tags. In practice, we often see &lt;a&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; inline-block elements allow to insert block element in an inline Consider the following example. This is clearly a bad use of HTML conventions since an inline tag can not host block elements. &lt;span&gt; &lt;div&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/span&gt; Importantly, &lt;div&gt; and &lt;span&gt; don’t have any semantic meaning, contrary to &lt;header&gt; and &lt;footer&gt;, which allow to structure the HTML page. 1.2.2 Tag attributes Attributes are text elements allowing to specify some properties of the tag. For instance for a link tag (&lt;a&gt;&lt;/a&gt;), we actually expect more than just the tag itself: a target url and how to open the new page … In all previous examples, tags don’t have any attributes. Yet, there exist a large range of attributes and we will only see 2 of them for now (the reason is that these are the most commonly used in CSS and JavaScript): class: may be shared between multiple tags id: each must be unique &lt;div class=&quot;awesome-item&quot; id=&quot;myitem&quot;&gt;&lt;/div&gt; &lt;!-- the class awesome-item may be applied to multiple tags --&gt; &lt;span class=&quot;awesome-item&quot;&gt;&lt;/span&gt; Both attributes are widely used by CSS and JavaScript (see Chapter 9 with the jQuery selectors) to apply a custom style to a web page. Class attributes apply to multiple elements, however the id attribute is restricted to only one item. Interestingly, there exists another attribute category, know as non-standard attributes like data-toggle. We will see them later in the book (see Chapter 17). 1.2.3 The simplest HTML skeleton An HTML page is a collection of tags which will be interpreted by the web browser step by step. The simplest HTML page may be defined as follows: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body content here --&gt; &lt;/body&gt; &lt;/html&gt; &lt;html&gt; is the may wrapper &lt;head&gt; and &lt;body&gt; are the 2 main children &lt;head&gt; contains dependencies like styles and JavaScript files (but not only), &lt;body&gt; contains the page content and it is displayed on the screen. We will see later that JavaScript files are often added just before the end of the &lt;body&gt;. Only the body content is displayed on the screen! W3C validation imposes at list a title tag in the head section and a lang attribute to the html tag! Let’s write the famous Hello World in HTML: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; In order to preview this page in a web browser, you need to save the above snippet to a script hello-world.html and double-click on it. It will open with your default web browser. Below is how we would do with a Shiny app, only for demonstration purpose (static HTML would be enough if no user interaction is required). ui &lt;- fluidPage(p(&quot;Hello World&quot;)) server &lt;- function(input, output, session) {} shinyApp(ui, server) From outside, it looks identical even though we’ll see in Chapter 2 that this simple app actually contains much more HTML than our previous example. 1.2.4 About the Document Object Model (DOM) The DOM stands for “Document Object Model” and is a convenient representation of the html document. There actually exists multiple DOM types, namely DOM-XML and DOM-HTML but we will only focus on the latter. If we consider the last example (Hello World), the associated DOM tree may be inspected in Figure 1.1. 1.2.4.1 Visualizing the DOM with the HTML inspector Below, we introduce a tool that will facilitate our exploration of beautiful shiny user interfaces. In this section, we restrict the description to the first panel of the HTML inspector.1 This feature is available in all web browsers, however for demonstration purposes, we will only focus on the Chrome DevTools. It may be opened: After a right click and selecting inspect After clicking on F12 (windows), fn + F12 on Mac (or Command+Option+C) In the following: Open the hello-world.html example with Chrome Right-click to open the HTML inspector (developer tools must be enabled if it is not the case) The HTML inspector is a convenient tool to explore the structure of the current HTML page. On the left-hand side, the DOM tree is displayed where we clearly see that &lt;html&gt; is the parent of &lt;head&gt; and &lt;body&gt;. &lt;body&gt; has also 1 child, that is &lt;p&gt;. We may preview any style (CSS) associated with the selected element on the right panel as well as Event Listeners (JavaScript), which will be discussed later in the book. FIGURE 1.1: Inspection of the DOM in the Hello World example 1.2.4.2 HTML Inspector 101 In the following, we enumerate key features of the inspector Elements tab. In addition to explore the HTML structure, the inspector allows to: Dynamically change CSS at run time Debug JavaScript code (put break points, …) Run JavaScript code from the console. Monitor any error or warning that may prevent your app or website from properly working Another important feature is the ability to switch between different devices, especially mobile platforms and to do a global performance audit with Google LightHouse. The book from Colin Fay et al. details the most relevant elements for Shiny app development. We propose at set of quick exercises to review the most important HTML inspector capabilities that are commonly needed during Shiny app customization. We consider the app already defined above: ui &lt;- fluidPage(p(&quot;Hello World&quot;)) server &lt;- function(input, output, session) {} shinyApp(ui, server) 1.2.4.2.1 Exercise: Altering the DOM structure Run the Hello World app, right click on the only text element and click on inspect Notice we could have done similarly by clicking on the very top left corner Inspect icon (Command + maj + C for Mac) and hovering over the Hello World text You should see a result similar to Figure 1.2, the Inspect icon being in blue. The selected element is highlighted and a white box displays the main CSS properties like text-color, font-size, margins, as well as accessibility parameters. FIGURE 1.2: Inspection of the p element in the Hello World example In the Elements panel, double click between the &lt;p&gt; and &lt;/p&gt; tags to edit the current text. Press enter when finished Let’s add some children to our p tag. Right click and select the Edit as HTML option. You may enter any valid HTML code inside. Don’t forget about some rules relative to inline and block tags (inline tags cannot contain block tags!!!) As depicted in Figure 1.3, we could have done a right click on the p tag to display more options like: Add/edit an attribute. You may try to add it a class class=\"awesome-text\" and an id id=\"only-text\" Delete the current tag (the return key would do it as well) Copy the element with all nested elements Only copy the outside HTML (ignore nested elements) Extract the CSS selector or JavaScript path (code to select the element): body &gt; div &gt; p and document.querySelector(\"body &gt; div &gt; p\"), respectively. These 2 features are extremely powerful as they save you time. Try to copy and paste document.querySelector(\"body &gt; div &gt; p\") in the JavaScript console at the bottom of the inspector window. It returns the selected HTML element, as shown in Figure 1.4! Amazing isn’ it? Hide the element Force a specific state. For instance buttons may be active, inactive FIGURE 1.3: Modifications of the p element in the Hello World example FIGURE 1.4: Extract the JavaScript path to select the p element Whenever you are looking for a specific tag in a more complex page, the search tag option is a game changer (Ctrl + F on Windows, command + F within the Elements tab on a Mac). See Figure 1.5. FIGURE 1.5: Search for element having the “awesome-text” class Finally, the inspector toolkit allows to reorder DOM elements with a rather intuitive drag and drop feature. I invite the reader to carefully explore those features as they will be crucial in the next chapters. 1.2.5 Preliminary introduction to CSS and JavaScript To introduce this section, I propose to look at the very first website, early in the 90’s (August 1991 exactly). From an aesthetic point of view (see Figure 1.6), this is far from what we can observe today as shown in Figure 1.7. FIGURE 1.6: World wide web website FIGURE 1.7: RinteRface website: https://rinterface.com How can we explain that difference? One of the main reason is the absence of CSS (Cascading Style Sheet) since the first CSS release only appeared in December 1996, that is 5 years later than the first web site publication. CSS allows to deeply customize the appearance of any web page by changing colors, fonts, margins and much more. We acknowledge, the role of JavaScript cannot be demonstrated through the previous example. Yet its impact is as important as CSS, so that it is now impossible to dissociate HTML, CSS and JavaScript. 1.2.5.1 HTML and CSS CSS (Cascading Style Sheets) changes the style of HTML tags by targeting specific classes or ids. For instance, if we want all p tags to have red color we will use: p { color: red; } To include CSS in an HTML page, we use the &lt;style&gt; tag as follows: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p { color: red; } &lt;/style&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; You may update the hello-world.html script and run it in your web-browser to see the difference. The example may be slight, but shows how we may control the look and feel of the display. In a development context, we will see later that css files may so big that it is better to include them in external files. Let’s build a shiny app that does similar things. As a reminder, you may use tags$style to include small pieces of CSS in your app: ui &lt;- fluidPage( tags$style(&quot;p { color: red;}&quot;), p(&quot;Hello World&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 1.2.5.2 HTML and JavaScript You will see how quickly/seamlessly you may add awesome features to your shiny app. In the following example, we defined the changeColor function that targets the element having hello id and change its color property to green. The HTML element has an onClick attribute that triggers the changeColor function each time the button is clicked. &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p { color: red; } &lt;/style&gt; &lt;script language=&quot;javascript&quot;&gt; // displays an alert alert(&#39;Click on the Hello World text!&#39;); // change text color function changeColor(color){ document.getElementById(&#39;hello&#39;).style.color = &quot;green&quot;; } &lt;/script&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- onclick attributes applies the JavaScript function changeColor define above --&gt; &lt;p id=&quot;hello&quot; onclick=&quot;changeColor(&#39;green&#39;)&quot;&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; In few lines of code, you can change the color of the text. This is only the beginning! We see below that the process is not dramatically different in a Shiny app. We wrap our custom JavaScript in the tags$script function (prefer external scripts to add more code), as below: ui &lt;- fluidPage( tags$script( &quot;alert(&#39;Click on the Hello World text!&#39;); // change text color function changeColor(color){ document.getElementById(&#39;hello&#39;).style.color = &#39;green&#39;; } &quot; ), p(id = &quot;hello&quot;, onclick=&quot;changeColor(&#39;green&#39;)&quot;, &quot;Hello World&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) As demonstrated above, developing a shiny app is basically building a website from R and is completely compatible with the web languages, that is CSS and JavaScript. Sections 4 and 11 present more robust tools and concepts to extend Shiny. … However, if you already know HTML (or want to learn!) you can also work directly with HTML tags to achieve any level of customization you want — Hadley Wickham References "],["web-dependencies.html", "Chapter 2 Discover Shiny dependencies 2.1 Introduction 2.2 Bootstrap 2.3 jQuery, DOM manipulation 2.4 Data formating 2.5 Custom dependencies 2.6 Exercise", " Chapter 2 Discover Shiny dependencies 2.1 Introduction If Shiny creates HTML code for us, it is not enough to design a beautiful working app with user interactions. As shown earlier, all modern web sites and apps have a lot of CSS and JavaScript under the hood. Let’s explore these elements in the following exercise. The simplest Shiny layout is the fluidPage. The shinyapp predefined Rstudio snippet creates a basic app skeleton (type shinyapp in a new script or the console in your RStudio IDE, Figure 2.1). FIGURE 2.1: shinyapp code snippet We add some text inside and remove the session parameter from the serve function, as we don’t use any update function: library(shiny) ui &lt;- fluidPage( p(&quot;Hello World&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) At first glance, the page only contains text. Wait … are you sure about this? Let’s run the above example and open the HTML inspector introduced in 1.2. Results are displayed on Figure 2.2. FIGURE 2.2: Shiny dependencies Click on “Open in Browser” Open the HTML inspector Locate the &lt;head&gt; tag Uncollapse it and search for the script containing application/html-dependencies List all dependencies We see in the head section (delimited by &lt;head&gt;&lt;/head&gt;) that Shiny has four dependencies: json2 jQuery 3.4.1 shiny (custom JavaScript and CSS) Bootstrap 3.4.1 (JavaScript and CSS) + other files (html5shiv, respond) 2.2 Bootstrap According to the gitstar ranking, which is an unofficial Github star ranking website, Bootstrap comes at the 7th place (144563 stars) and 22th place for repositories and organization, respectively. It has been first released in 2011 and will welcome the fifth version in few months. It provides plug and play layout and interactive elements such as tabs, navigation bars, tooltips, popovers and many input (forms), which is rather convenient since it avoids writing a large amount of CSS/JavaScript that would bring more complexity. The first release of Shiny was shipped with Bootstrap 2. Shiny currently relies on Bootstrap 3 since v0.11, while a lot of efforts are being made to provide a Bootstrap 4 compatibility, essentially through the bootstraplib R package. One of the great advantage of using Bootstrap is the responsiveness of the design that can work either on desktop or mobile, even though advanced user likely prefer other specialized libraries like Framework7 or onsenUI to develop native looking apps. Bootstrap 3 relies on the grid layout system that allows to efficiently organize the content in row and columns. For instance the fluidRow and column Shiny functions leverage the Bootstrap grid to control how elements are displayed in a page. How does Shiny attach the Bootstrap dependencies? The well know fluidPage layout is actually hiding a lower level function, that is bootstrapPage. The latter is also called in many other high level layout functions for instance fixedPage, fillPage and navbarPage. It simply attaches bootstraplib as well as any Bootstrap compatible theme css files that one can pass with the {shinythemes} package. The interested reader will have a look at the following script. 2.3 jQuery, DOM manipulation jQuery allows to perform DOM manipulation, that is interacting with HMTL elements, in a more user-friendly manner than with pure JavaScript. At that step, you might not be familiar with JavaScript nor jQuery. Don’t worry chapter 9 will expose the basics. Below is a comparison on how you would select a button HTML element with both technologies. I am sure you’ll notice how jQuery2 is more intuitive than JavaScript. Javascript: var btn = document.getElementById(&#39;mybutton&#39;); // select the button btn.addEventListener(&#39;click&#39;, function() { // action + consequences alert(&#39;You clicked me!&#39;); // action }); jQuery: $(&#39;#mybutton&#39;).on(&#39;click&#39;, function() { alert(&#39;You clicked me!&#39;); }); Interestingly, the work in progress {jquerylib} will provide support for {shiny} in future releases. 2.4 Data formating json2 is a library to handle the JSON data format (JavaScript Object Notation). We will see in section 10.2 of Chapter 10 that the R / JS communication involves data exchange and given that data structures are not the same in R and JS, there must be a way to ensure the translation. This is done through the jsonlite package that allows to transform JSON objects in R objects with jsonlite::fromJSON and inversely with jsonlite::toJSON. Shiny automatically handles the process and it works well most of the time! 2.5 Custom dependencies The last dependency contains custom JS and CSS code necessary for Shiny to work, that is: Fine tuning the layout Registering input/output Handling every single input/output action Initializing and controlling the R/JS communication Handling alerts/modals/notifications … Part 10.1, 11, 14 and 20 showcase the most important elements of those custom files. TO DO: link to CSS part The interested reader will have a look at the following script. 2.6 Exercise In the following exercise, we consider a more complex app with a slider as well as a plot output. Run the app runExample(\"01_hello\") Open the HTML inspector Delete the bootstrap.min.css and ion.rangeSlider.css Conclusions To sump up, all these libraries are necessary to make Shiny what it is! In Chapter 4, we explore tools to manage HTML dependencies. In Chapter 20.4.1, we study a special case to insert dependencies during the app runtime. Let’s move to the next part to discover the internal engine that creates HTML code from R! The next iteration of Bootstrap, namely Bootstrap 5 completely abandons jQuery for vanilla JavaScript. The main reason is to lighten the Bootstrap code.↩︎ "],["htmltools-overview.html", "Chapter 3 htmltools overview 3.1 Writing HTML Tags from R 3.2 Notations 3.3 Adding new tags 3.4 Alternative way to write tags 3.5 Playing with tags 3.6 Practical examples 3.7 Exercises", " Chapter 3 htmltools overview {htmltools} (Cheng et al. 2021) is a R package designed to: Generate HTML tags from R Handle web dependencies (see chapter 4) Historically, {htmltools} was extracted out of {shiny} (Chang et al. 2021) to be able to extend it, that is developing custom HTML tags, importing extra dependencies from the web. That’s why, both packages have many common functions! At the moment, {htmltools} does not have any user guide, although being a key package for all web things! 3.1 Writing HTML Tags from R {htmltools} provides the necessary functions to write HTML tags that were introduced in Chapter 1.2. In R, it is even more convenient than raw HTML since there is no opening/closing tag, a simple function call instead: library(htmltools) tag &lt;- div(&quot;Hello World&quot;) tag Hello World as.character(tag) ## [1] &quot;&lt;div&gt;Hello World&lt;/div&gt;&quot; Inside the function call, all named elements will become attributes, whereas unnamed elements will become children. In some cases, tags may have empty attributes like &lt;input disabled&gt;. In that case, the corresponding R code is input(disabled = NA). Since tag functions produce shiny tags, that is HTML elements, we can capture the HTML output by converting it to a character with as.character, as shown above. 3.2 Notations Whether to use tags$div or div depends if the tag is exported by default. For instance, you could use htmltools::div but not htmltools::nav since nav does not have a dedicated function (only for p, h1, h2, h3, h4, h5, h6, a, br, div, span, pre, code, img, strong, em, hr). Rather prefer htmltools::tags$nav. Alternatively, there exists a function (in shiny and htmltools) called withTags. Wrapping your code in this function allows code like this withTags(nav(), ...) instead of tags$nav(), thereby omitting the tags$ prefixes. If you had to gather multiple tags together, choose tagList() over list(), although the HTML output is the same. The first has the shiny.tag.list class in addition to list. Package like {golem} (Fay et al. 2020) (see also http://golemverse.org) allows to test if an R object is a tag list. In this case, using a list would cause the test fail. 3.3 Adding new tags The tag function allows to add extra HTML tags not already defined. You may use it as follows: customTag &lt;- tag(&quot;test&quot;, list(class = &quot;test&quot;, p(&quot;Custom Tag&quot;))) str(customTag) ## List of 3 ## $ name : chr &quot;test&quot; ## $ attribs :List of 1 ## ..$ class: chr &quot;test&quot; ## $ children:List of 1 ## ..$ :List of 3 ## .. ..$ name : chr &quot;p&quot; ## .. ..$ attribs : Named list() ## .. ..$ children:List of 1 ## .. .. ..$ : chr &quot;Custom Tag&quot; ## .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## - attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; customTag Custom Tag Good practice is to check whether the created tag is in line with the HTML validation rules. 3.4 Alternative way to write tags {htmltools} comes with the HTML() function that you can feed with raw HTML: HTML(&#39;&lt;div&gt;Blabla&lt;/div&gt;&#39;) # will render exactly like div(&quot;Blabla&quot;) # but their classes are different class(HTML(&#39;&lt;div&gt;Blabla&lt;/div&gt;&#39;)) class(div(&quot;Blabla&quot;)) You will not be able to use tag related functions, as in the following parts. Therefore, I strongly recommend using R and not mixing HTML in R. Interestingly, if you want to convert raw HTML to R code, there is a Shiny App developed by Alan Dipert from RStudio, namely html2R, shown Figure 3.1. There are some issues, non standard attributes (like data-toggle) are not correctly processed but there are solutions. This will save you precious time! A more recent approach is developed in section 21 and has be internally used to develop some of the RinteRface templates. FIGURE 3.1: Illustration of the html2R App 3.5 Playing with tags 3.5.1 Tags structure A tag is defined by: A name such as span, div, h1 … tag$name Some attributes, which can be accessed with tag$attribs Children, which you can be accessed with tag$children A class, namely shiny.tag For instance: # create the tag myTag &lt;- div( class = &quot;divclass&quot;, id = &quot;first&quot;, h1(&quot;Here comes your baby&quot;), span(class = &quot;child&quot;, id = &quot;baby&quot;, &quot;Crying&quot;) ) # access its name myTag$name # access its attributes (id and class) myTag$attribs # access children (returns a list of 2 elements) myTag$children # access its class class(myTag) How to modify the class of the second child? second_children &lt;- myTag$children[[2]] second_children$attribs$class &lt;- &quot;adult&quot; myTag # This is not working ... Why is this not working? By assigning myTag$children[[2]] to second_children, second_children$attribs$class &lt;- \"adult\" modifies the class of the copy and not the original object. Thus we do: myTag$children[[2]]$attribs$class &lt;- &quot;adult&quot; myTag 3.5.2 Useful functions for tags {htmltools} and {shiny} have powerful functions to seamlessly manipulate tags. 3.5.2.1 Add attributes tagAppendAttributes: this function allows to add a new attribute to the current tag. For instance, assuming we created a div without any id attribute: mydiv &lt;- div(&quot;Where is my brain&quot;) mydiv &lt;- tagAppendAttributes(mydiv, id = &quot;here_it_is&quot;) You can pass as many attributes as you want, including non standard attributes such as data-toggle (see Bootstrap 3 tabs for instance): mydiv &lt;- tagAppendAttributes(mydiv, list(`data-toggle` = &quot;tabs&quot;, class = &quot;myclass&quot;)) # even though you could proceed as follows but this requires 2 steps mydiv$attribs[[&quot;data-toggle&quot;]] &lt;- &quot;tabs&quot; mydiv$attribs$class &lt;- &quot;myclass&quot; 3.5.2.2 Check if tag has specific attribute tagHasAttribute: to check if a tag has a specific attribute # I want to know if div has a class mydiv &lt;- div(class = &quot;myclass&quot;) has_class &lt;- tagHasAttribute(mydiv, &quot;class&quot;) has_class # if you are familiar with %&gt;% has_class &lt;- mydiv %&gt;% tagHasAttribute(&quot;class&quot;) has_class In practice, this function is useful when testing tag elements as shown in chapter 18. 3.5.2.3 Get all attributes tagGetAttribute: to get the value of the targeted attributes, if it exists, otherwise NULL. mydiv &lt;- div(class = &quot;test&quot;) # returns the class tagGetAttribute(mydiv, &quot;class&quot;) # returns NULL tagGetAttribute(mydiv, &quot;id&quot;) 3.5.2.4 Set child/children tagSetChildren allows to create children for a given tag. For instance: mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;) # mydiv has 1 child &quot;Not the mama!!!&quot; mydiv children &lt;- lapply(1:3, span) mydiv &lt;- tagSetChildren(mydiv, children) # mydiv has 3 children, the first one was removed mydiv Notice that tagSetChildren removes all existing children. Below we see another set of functions to add children while conserving existing ones. 3.5.2.5 Add child or children tagAppendChild and tagAppendChildren: add other tags to an existing tag. Whereas tagAppendChild only takes one tag, you can pass a list of tags to tagAppendChildren. mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;) otherTag &lt;- span(&quot;I am your child&quot;) mydiv &lt;- tagAppendChild(mydiv, otherTag) 3.5.2.6 Build your own functions You might wonder why there is no tagRemoveChild or tagRemoveAttributes. Let’s look at the tagAppendChild tagAppendChild &lt;- function (tag, child) { tag$children[[length(tag$children) + 1]] &lt;- child tag } Below we write the tagRemoveChild, where tag is the target and n is the position to remove in the list of children: mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;, span(&quot;Hey!&quot;)) # we create the tagRemoveChild function tagRemoveChild &lt;- function(tag, n) { # check if the list is empty if (length(tag$children) == 0) { stop(paste(tag$name, &quot;does not have any children!&quot;)) } tag$children[n] &lt;- NULL tag } mydiv &lt;- tagRemoveChild(mydiv, 1) mydiv When defining the tagRemoveChild, we choose [ instead of [[ to allow to select multiple list elements: mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;, &quot;Hey!&quot;) # fails `[[`(mydiv$children, c(1, 2)) # works `[`(mydiv$children, c(1, 2)) Alternatively, we could also create a tagRemoveChildren function. Also notice that the function raises an error if the provided tag does not have children. The tagAppendChild is not able to insert at a specific position. We could draft the tagInsertChild building on top of the base R append function: tagInsertChild &lt;- function(tag, child, position) { tag$children &lt;- append(tag$children, list(child), position - 1) tag } tagInsertChild(p(span(&quot;hello&quot;)), a(), 1) tagInsertChild(p(span(&quot;hello&quot;)), a(), 2) 3.5.3 Other functions The golem package written by thinkr contains neat functions to edit your tags. Particularly, the tagRemoveAttributes: tagRemoveAttributes &lt;- function(tag, ...) { attrs &lt;- as.character(list(...)) for (i in seq_along(attrs)) { tag$attribs[[ attrs[i] ]] &lt;- NULL } tag } mydiv &lt;- div(class = &quot;test&quot;, id = &quot;coucou&quot;, &quot;Hello&quot;) tagRemoveAttributes(mydiv, &quot;class&quot;, &quot;id&quot;) 3.5.4 Conditionally set attributes Sometimes, you only want to set attributes under specific conditions. my_button &lt;- function(color = NULL) { tags$button( style = paste(&quot;color:&quot;, color), p(&quot;Hello&quot;) ) } my_button() This example will not fail but having style=\"color: \" is not clean. We may use conditions: my_button &lt;- function(color = NULL) { tags$button( style = if (!is.null(color)) paste(&quot;color:&quot;, color), p(&quot;Hello&quot;) ) } my_button(&quot;blue&quot;) my_button() In this example, style won’t be available if color is not specified. 3.5.5 Using %&gt;% While doing a lot of manipulation for a tag, if you don’t need to create intermediate objects, this is a good idea to use %&gt;% from magrittr: div(class = &quot;cl&quot;, h1(&quot;Hello&quot;)) %&gt;% tagAppendAttributes(id = &quot;myid&quot;) %&gt;% tagAppendChild(p(&quot;some extra text here!&quot;)) The pipe syntax is overall easier to follow and read. 3.5.6 Programmatically create children elements Assume you want to create a tag with three children inside: div( span(1), span(2), span(3), span(4), span(5) ) The structure is correct but imagine if you had to create 1000 span or fancier tag. The previous approach is not consistent with DRY programming. lapply function will be useful here (or the purrr map family): # base R div(lapply(1:5, function(i) span(i))) # purrr + %&gt;% map(1:5, function(i) span(i)) %&gt;% div() 3.6 Practical examples Below we give concrete example on how to customize tags in the real life. There exists a nice RPG HTML template, that is rpgui. It provides the necessary elements to get started developing nice RPG looking user interfaces, as depicted by Figure 3.2. FIGURE 3.2: rpgui select input In the following, we consider the select input, which does not have exactly the same structure as the original shiny tag. However, it is convenient to reuse the shiny function to limit our amount of work. We therefore start to write our custom input: rpgSelect &lt;- function(inputId, label, choices, selected = NULL, multiple = FALSE, size = NULL) { shiny::selectInput( inputId, label, choices, selected, multiple, selectize = FALSE, width = NULL, size ) } According to the rpgui documentation, a select tag is composed of the following HTML elements: &lt;select class=&quot;rpgui-dropdown&quot;&gt; &lt;option value=&quot;option1&quot;&gt;option1&lt;/option&gt; &lt;option value=&quot;option2&quot;&gt;option2&lt;/option&gt; ... &lt;/select&gt; Adding a label tag on top of the slider, this is what we would like to get: &lt;div&gt; &lt;label id=&quot;variable-label&quot; for=&quot;variable&quot;&gt;Variable:&lt;/label&gt; &lt;select id=&quot;variable&quot; class=&quot;rpgui-dropdown&quot;&gt;&lt;option value=&quot;cyl&quot; selected&gt;Cylinders&lt;/option&gt; &lt;option value=&quot;am&quot;&gt;Transmission&lt;/option&gt; &lt;option value=&quot;gear&quot;&gt;Gears&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; We compare with our own rpgSelect function: rpgSelect( &quot;variable&quot;, &quot;Variable:&quot;, c(&quot;Cylinders&quot; = &quot;cyl&quot;, &quot;Transmission&quot; = &quot;am&quot;, &quot;Gears&quot; = &quot;gear&quot;) ) %&gt;% as.character() ## [1] &quot;&lt;div class=\\&quot;form-group shiny-input-container\\&quot;&gt;\\n &lt;label class=\\&quot;control-label\\&quot; id=\\&quot;variable-label\\&quot; for=\\&quot;variable\\&quot;&gt;Variable:&lt;/label&gt;\\n &lt;div&gt;\\n &lt;select id=\\&quot;variable\\&quot; class=\\&quot;form-control\\&quot;&gt;&lt;option value=\\&quot;cyl\\&quot; selected&gt;Cylinders&lt;/option&gt;\\n&lt;option value=\\&quot;am\\&quot;&gt;Transmission&lt;/option&gt;\\n&lt;option value=\\&quot;gear\\&quot;&gt;Gears&lt;/option&gt;&lt;/select&gt;\\n &lt;/div&gt;\\n&lt;/div&gt;&quot; As shown in the above output, this is not exactly matching: The outer div should not have any class. The label should not have any class. The input tag is wrapped inside a div container. It should not. The input tag should have the rpgui-dropdown or rpgui-list class, depending on the size value. To fix the first problem we target the outer tag (selectTag), that is the tag returned by our rpgSelect function. The second row cleans the label class. The third row removes the extra outer div and only keeps its children, corresponding to the input tag. The last instruction ensure to set the appropriate class, depending on the size value: # Modify tag selectTag$attribs$class &lt;- NULL # Clean extra label class selectTag$children[[1]]$attribs$class &lt;- NULL # Remove extra outer div selectTag$children[[2]] &lt;- selectTag$children[[2]]$children[[1]] # Add good class for rppgui binding selectTag$children[[2]]$attribs$class &lt;- if (is.null(size)) { &quot;rpgui-dropdown&quot; } else { &quot;rpgui-list&quot; } The final version is shown below: rpgSelect &lt;- function(inputId, label, choices, selected = NULL, multiple = FALSE, size = NULL) { selectTag &lt;- shiny::selectInput( inputId, label, choices, selected, multiple, selectize = FALSE, width = NULL, size ) # Modify tag selectTag$attribs$class &lt;- NULL # Clean extra label class selectTag$children[[1]]$attribs$class &lt;- NULL # Remove extra outer div selectTag$children[[2]] &lt;- selectTag$children[[2]]$children[[1]] # Add good class for rppgui binding selectTag$children[[2]]$attribs$class &lt;- if (is.null(size)) { &quot;rpgui-dropdown&quot; } else { &quot;rpgui-list&quot; } selectTag } rpgSelect( &quot;variable&quot;, &quot;Variable:&quot;, c(&quot;Cylinders&quot; = &quot;cyl&quot;, &quot;Transmission&quot; = &quot;am&quot;, &quot;Gears&quot; = &quot;gear&quot;) ) %&gt;% as.character() ## [1] &quot;&lt;div&gt;\\n &lt;label id=\\&quot;variable-label\\&quot; for=\\&quot;variable\\&quot;&gt;Variable:&lt;/label&gt;\\n &lt;select id=\\&quot;variable\\&quot; class=\\&quot;rpgui-dropdown\\&quot;&gt;&lt;option value=\\&quot;cyl\\&quot; selected&gt;Cylinders&lt;/option&gt;\\n&lt;option value=\\&quot;am\\&quot;&gt;Transmission&lt;/option&gt;\\n&lt;option value=\\&quot;gear\\&quot;&gt;Gears&lt;/option&gt;&lt;/select&gt;\\n&lt;/div&gt;&quot; 3.7 Exercises 3.7.1 Exercise 1: tags structure (5 minutes) Consider the following shiny tag: myTag &lt;- a( class = &quot;btn btn-large&quot;, type = &quot;button&quot;, span(class = &quot;child1&quot;, id = &quot;super-span&quot;, 1), span(class = &quot;child2&quot;, 2) ) myTag Inspect its structure. Hint: you may use str. Access its class using tagGetAttribute and another method of your choice. Modify the first child class to custom class. 3.7.2 Exercise 2: modifiying tags (5 minutes) Let us consider the following tag: temp &lt;- div(&quot;Hello World&quot;) (You may chain functions with %&gt;%) Replace its unique child by a(href = \"http://www.google.com\", \"click me!\"). Hint: tagSetChildren is your friend. Add 10 other span. Hint: tags may be programmatically generated with lapply or purrr::map. References "],["htmltools-dependencies.html", "Chapter 4 Dependency utilities 4.1 The dirty approach 4.2 The clean approach 4.3 Importing HTML dependencies from other packages 4.4 Suppress dependencies 4.5 Resolve dependencies 4.6 Insert Custom script in the head", " Chapter 4 Dependency utilities When creating a new template, you have to import custom HTML dependencies that are not available in shiny. Fortunately, this is not a problem with {htmltools} (Cheng et al. 2021)! 4.1 The dirty approach Let’s consider the following example. Since Bootstrap is one of the most popular HTML/CSS/JS framework to develop websites and web apps, we want to include a bootstrap 4 card in a shiny app. This case study is taken from a RStudio Community question. The naive approach would be to include the HTML code directly in the app code. This approach is dirty since it is not easily re-usable by others. library(shiny) # we create the card function before my_card &lt;- function(...) { withTags( div( class = &quot;card border-success mb-3&quot;, div(class = &quot;card-header bg-transparent border-success&quot;), div( class = &quot;card-body text-success&quot;, h3(class = &quot;card-title&quot;, &quot;title&quot;), p(class = &quot;card-text&quot;, ...) ), div(class = &quot;card-footer bg-transparent border-success&quot;, &quot;footer&quot;) ) ) } # we build our app shinyApp( ui = fluidPage( fluidRow( column( width = 6, align = &quot;center&quot;, br(), my_card(&quot;Card Content&quot;) ) ) ), server = function(input, output) {} ) FIGURE 4.1: Attempt to display a Bootstrap 4 card without dependencies As depicted by Figure 4.1, nothing is displayed which was expected since {shiny} (Chang et al. 2021) does not contain Bootstrap 4 dependencies and this card is a bootstrap 4 element. Don’t panic! We load the necessary css to display this card (if required, we could include the javascript as well). We could use either includeCSS(), tags$head(tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"custom.css\")), as described in the shiny documentation here. Web development best practice recommend to point to external file rather than including CSS in the head or directly on a tag (inline CSS). In the below example, we use a CDN (content delivery network) but that could be a local file located in the www/ folder: shinyApp( ui = fluidPage( # load the css code tags$head( tags$link(rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;, href = &quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;) ), fluidRow( column( width = 6, align = &quot;center&quot;, br(), my_card(&quot;Card Content&quot;) ) ) ), server = function(input, output) {} ) The card may seem ugly but at least it is displayed as shown on Figure 4.2. FIGURE 4.2: Bootstrap 4 card within a simple app 4.2 The clean approach The best approach consists in leveraging the htmlDependency and attachDependencies functions from {htmltools}. The htmlDependency function takes the following main parameters: the dependency name the version (useful to remember on which version it is built upon) a path to the dependency (can be a CDN or a local folder) script and stylesheet to respectively pass css and scripts # handle dependency card_css &lt;- &quot;bootstrap.min.css&quot; bs4_card_dep &lt;- function() { htmlDependency( name = &quot;bs4_card&quot;, version = &quot;1.0&quot;, src = c(href = &quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/&quot;), stylesheet = card_css ) } If you are not pointing to a CDN and use local files, this is crucial to wrap the htmlDependency in a function since the path has to be determined at run time and not when the package builds. It means that if you are developing a package with dependencies, forgetting this step might prevent other users to get the dependency working on their own machine (the differences between Unix and Windows OS paths is clearly a good example). We create the card tag and give it the bootstrap 4 dependency through the attachDependencies function. In recent version of {htmltools}, we may simply use tagList(tag, deps) instead. Importantly, attachDependencies has an append parameter FALSE by default. Ensure to set it to TRUE if you want to keep already attached dependencies! # create the card my_card &lt;- function(...) { cardTag &lt;- withTags( div( class = &quot;card border-success mb-3&quot;, div(class = &quot;card-header bg-transparent border-success&quot;), div( class = &quot;card-body text-success&quot;, h3(class = &quot;card-title&quot;, &quot;title&quot;), p(class = &quot;card-text&quot;, ...) ), div(class = &quot;card-footer bg-transparent border-success&quot;, &quot;footer&quot;) ) ) # attach dependencies (old way) # htmltools::attachDependencies(cardTag, bs4_card_dep()) # simpler way tagList(cardTag, bs4_card_dep()) } We finally run our app: # run shiny app ui &lt;- fluidPage( title = &quot;Hello Shiny!&quot;, fluidRow( column( width = 6, align = &quot;center&quot;, br(), my_card(&quot;Card Content&quot;) ) ) ) shinyApp(ui, server = function(input, output) { }) With this approach, you can develop a package of custom dependencies that people could use when they need to add custom elements in shiny. 4.3 Importing HTML dependencies from other packages The {shinydashboard} (Chang and Borges Ribeiro 2018) package helps to design dashboards with shiny. In the following, we would like to integrate the box component in a classic Shiny App (without the dashboard layout). However, if you try to include the box tag, you will notice that nothing is displayed since {shiny} does not have {shinydashboard} dependencies. {htmltools} contains a function, namely findDependencies that looks for all dependencies attached to a tag. Before going further, let’s define the basic skeleton of a dashboard: library(shinydashboard) shinyApp( ui = dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody(), title = &quot;Dashboard example&quot; ), server = function(input, output) { } ) There are numerous details associated with shinydashboard that we will not go into. If you are interested in learning more, please help yourself. The key point here is the main wrapper function dashboardPage. The fluidPage is another wrapper function that most are already familiar with. We apply findDependencies on dashboardPage: library(htmltools) deps &lt;- findDependencies( dashboardPage( header = dashboardHeader(), sidebar = dashboardSidebar(), body = dashboardBody() ) ) deps ## [[1]] ## List of 10 ## $ name : chr &quot;font-awesome&quot; ## $ version : chr &quot;5.13.0&quot; ## $ src :List of 1 ## ..$ file: chr &quot;www/shared/fontawesome&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: chr [1:2] &quot;css/all.min.css&quot; &quot;css/v4-shims.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : chr &quot;shiny&quot; ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[2]] ## List of 10 ## $ name : chr &quot;font-awesome&quot; ## $ version : chr &quot;5.13.0&quot; ## $ src :List of 1 ## ..$ file: chr &quot;www/shared/fontawesome&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: chr [1:2] &quot;css/all.min.css&quot; &quot;css/v4-shims.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : chr &quot;shiny&quot; ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[3]] ## List of 10 ## $ name : chr &quot;bootstrap&quot; ## $ version : chr &quot;3.4.1&quot; ## $ src :List of 2 ## ..$ href: chr &quot;shared/bootstrap&quot; ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shiny/www/shared/bootstrap&quot; ## $ meta :List of 1 ## ..$ viewport: chr &quot;width=device-width, initial-scale=1&quot; ## $ script : chr [1:2] &quot;js/bootstrap.min.js&quot; &quot;accessibility/js/bootstrap-accessibility.min.js&quot; ## $ stylesheet: chr [1:2] &quot;css/bootstrap.min.css&quot; &quot;accessibility/css/bootstrap-accessibility.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[4]] ## List of 10 ## $ name : chr &quot;options&quot; ## $ version : chr &quot;2.0.0.9000&quot; ## $ src :List of 1 ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shinydashboardPlus/shinydashboardPlus-2.0.0&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: NULL ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[5]] ## List of 10 ## $ name : chr &quot;shinydashboardPlus&quot; ## $ version : chr &quot;2.0.0.9000&quot; ## $ src :List of 1 ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shinydashboardPlus/shinydashboardPlus-2.0.0&quot; ## $ meta : NULL ## $ script : chr [1:2] &quot;js/app.min.js&quot; &quot;js/shinydashboardPlus.min.js&quot; ## $ stylesheet: chr [1:3] &quot;css/AdminLTE.min.css&quot; &quot;css/_all-skins.min.css&quot; &quot;css/custom.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[6]] ## List of 10 ## $ name : chr &quot;shinydashboard&quot; ## $ version : chr &quot;0.7.1&quot; ## $ src :List of 1 ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shinydashboard&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: chr &quot;shinydashboard.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; deps is a list containing four dependencies: Font Awesome handles icons. Interestingly, this dependency is provided by dashboardHeader, especially the shiny::icon(\"bars\") that collapses the left sidebar Bootstrap is the main HTML/CSS/JS template. Importantly, please note the version 3.3.7, whereas the current is 4.5.2 AdminLTE is the dependency containing HTML/CSS/JS related to the admin template. It is closely linked to Bootstrap 3 shinydashboard, the CSS and javascript necessary for our dashboard to work properly. In practice, integrating custom HTML templates to shiny does not usually work out of the box for many reasons and some modifications are necessary. For instance, here is a list of changes to optimize adminLTE for shiny. This has major consequences on the template maintenance such that upgrading to another AdminLTE version would require to modify all these elements by hand. You may understand why template maintainers are quite often reluctant to upgrade their dependencies as it might brake the whole package, quite easily. Below, we attach the dependencies to the box with tagList, as shown above. Notice that our custom box does not contain all parameters as in the official {shinydashboard} version, which is actually ok at this time. For a better contrast with the body, we add a custom color to the background, as depicted by Figure 4.3: my_box &lt;- function(title, status) { tagList(box(title = title, status = status), deps) } ui &lt;- fluidPage( tags$style(&quot;body { background-color: gainsboro; }&quot;), titlePanel(&quot;Shiny with a box&quot;), my_box(title = &quot;My box&quot;, status = &quot;danger&quot;), ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 4.3: AdminLTE2 box inside classic shiny app You now have limitless possibilities! Interestingly, this same approach is the basis of shinyWidgets for the useBs4Dash function and other related tools. 4.4 Suppress dependencies In rare cases, you may need to remove an existing conflicting dependency. The suppressDependencies function allows users to perform this. For instance, shiny.semantic built on top of semantic ui is not compatible with Bootstrap, as illustrated by Figure 4.4. FIGURE 4.4: Deletion of Bootstrap inside semanticPage Below, we remove the AdminLTE2 dependency from a {shinydashboard} page and nothing is displayed (as expected): shinyApp( ui = dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody(suppressDependencies(&quot;AdminLTE&quot;)), title = &quot;Dashboard example&quot; ), server = function(input, output) { } ) 4.5 Resolve dependencies Imagine a situation in which we would like to use the very last version of fontawesome icons, that is currently 5.15.1 according to jsdelivr. We recall that {shiny} already provides version 5.13.0 through the icon function. Including another version would probably cause conflicts and we would like to avoid that case. {htmltools} has a resolveDependencies tool that consists in removing any redundant element, taking the last version if dependencies names are identical. new_icon_dep &lt;- htmlDependency( name = &quot;font-awesome&quot;, version = &quot;5.15.1&quot;, src = c(href = &quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/&quot;), stylesheet = &quot;css/all.min.css&quot; ) icon_deps &lt;- list(new_icon_dep, findDependencies(shiny::icon(&quot;th&quot;))[[1]]) resolveDependencies(icon_deps) ## [[1]] ## List of 10 ## $ name : chr &quot;font-awesome&quot; ## $ version : chr &quot;5.15.1&quot; ## $ src :List of 1 ## ..$ href: chr &quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: chr &quot;css/all.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; Combining findDependencies, suppressDependencies and resolveDependencies gives you great power to successfully manage your dependencies! 4.6 Insert Custom script in the head With {shinydashboardPlus}, users can fine tune their dashboard behavior with a simple option parameter passed to dashboardPagePlus. The sidebarExpandOnHover capability that consists in expanding the sidebar when hovering on it is part of those options, yet not exposed by {shinydashboard}. Under the hood, all those options are gathered in a (nested) list, then converted into JSON to eventually generate a JavaScript configuration file. Until now, we only saw two ways to include scripts or stylesheets. How do we include any arbitrary script (defined on the fly by the user when the app starts) in an dependency? htmlDependency has a head parameter allowing to pass any lines of HTML to insert into the document head. We can easily imagine passing a string containing a script. Below, we first construct the options list. Then, we create the dependency: notice since src is mandatory, we have to give it a value but we will not use script nor stylesheet arguments. options &lt;- list( sidebarExpandOnHover = TRUE, boxWidgetSelectors = list( remove = &#39;[data-widget=&quot;remove&quot;]&#39; ) ) config_script &lt;- function() { htmlDependency( &quot;options&quot;, as.character(utils::packageVersion(&quot;shinydashboardPlus&quot;)), src = c(file = system.file(&quot;shinydashboardPlus-0.6.0&quot;, package = &quot;shinydashboardPlus&quot;)), head = if (!is.null(options)) { paste0( &quot;&lt;script&gt;var AdminLTEOptions = &quot;, jsonlite::toJSON( options, auto_unbox = TRUE, pretty = TRUE ), &quot;;&lt;/script&gt;&quot; ) } ) } # show the script print(HTML(config_script()$head)) ## &lt;script&gt;var AdminLTEOptions = { ## &quot;sidebarExpandOnHover&quot;: true, ## &quot;boxWidgetSelectors&quot;: { ## &quot;remove&quot;: &quot;[data-widget=\\&quot;remove\\&quot;]&quot; ## } ## };&lt;/script&gt; I invite the reader to run the example below involving {shinydashboardPlus}, open the HTML inspector and look at the head. shinyApp( ui = dashboardPagePlus( collapse_sidebar = TRUE, options = options, header = dashboardHeaderPlus( enable_rightsidebar = TRUE, rightSidebarIcon = &quot;gears&quot; ), sidebar = dashboardSidebar(), body = dashboardBody(), rightsidebar = rightSidebar(), title = &quot;DashboardPage&quot; ), server = function(input, output) { } ) According the the AdminLTE documentation, global options must be passed before loading the app.min.js script. Creating this “dummy” dependency allowed us to isolate the script to insert it before the app.min.js script (contained in another dependency), as shown on Figure 4.5. FIGURE 4.5: Insert arbitrary script in the head References "],["beautify-css.html", "Chapter 5 CSS for Shiny 5.1 How to include CSS? 5.2 CSS selectors 5.3 Modify CSS with the HTML inspector 5.4 CSS in action 5.5 Best practice 5.6 Exercises", " Chapter 5 CSS for Shiny The first CSS version was released in 1996, that is 5 years later than HTML. Before CSS appeared, developers styled their pages with specific tags like font, which eventually made the HTML code hard to maintain. The current version of CSS is 3. While nowadays all web browsers support CSS, this was not the case at the very beginning! 5.1 How to include CSS? There are 3 ways to include CSS in a web page: Point to an external file &lt;link rel=\"stylesheet\" href=\"style.css\"/&gt; Insert the style in the head Insert the style at the tag level, through the style attribute &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;CSS&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p style=&quot;color: red&quot;&gt;Hello World&lt;/p&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;div&gt;Plop&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; I recommend to follow the first method as much as you can so that you modify the CSS in only one place! At the end of the day, your CSS script will look like the below example: tag1 { property1: value1; property2: value2; } tag2 { property1: value1; } All of the above methods apply to shiny: External CSS file tags$link(rel = \"stylesheet\", type=\"text/css\", href=\"www/style.css\"). Internal CSS tags$head(tags$style(\"p {color: red;}\")). Inline CSS p(style = \"color:red;\", \"Red text\"). However, if you correctly followed the previous part about HTML dependencies, the best way in Shiny is to create a dependency, and attach it to a tag: css_dep &lt;- function() { htmlDependency( name = &quot;css dep&quot;, version = &quot;1.0&quot;, src = path_to_css, stylesheet = filename ) } tagList(tag, css_dep) Following this method, you make the file accessible on the server, thereby easing the debugging process. When should we apply the above method? Well, it does not make a lot of sense for tiny CSS modifications, where you could use one of the 3 other methods listed above. 5.2 CSS selectors 5.2.1 Basics To apply CSS, we select a the tag , choose the property we want to change and give it a value: selector { property: value; } For instance, to set the color blue to the p tag, we would do: p { color: red; } Now, how would we apply the same property to multiple tags? We separate tags by a comma: p, div { color: red; } See below an example with a Shiny app: ui &lt;- fluidPage( tags$style( &quot;p, div { color: red; }&quot; ), p(&quot;Hello World&quot;), div(&quot;A block&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 5.2.2 Select by class, id The method shown above applies to all selected tags. This is not necessarily what we want as we probably would like to filter. We first add a class to the first p tag. Best practice is to give it a meaningful name. &lt;p class=&quot;first-p&quot;&gt;&lt;/p&gt; On the CSS side, we prefix the class by a ., as shown below: .first-p { color: red; } To style unique elements, we may use id: #element { color: red; } As another example, the result is shown in Figure 5.1: ui &lt;- fluidPage( tags$style( &quot;.first-p { color: red; } #element { color: red; } &quot; ), p(class = &quot;first-p&quot;, &quot;Hello World&quot;), p(&quot;Another text&quot;), div(id = &quot;element&quot;, &quot;A block&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) FIGURE 5.1: Select by class and id 5.2.3 Apply CSS to single elements Let’s consider the following example: &lt;p&gt;Hello World! What&#39;s up?&lt;/p&gt; How would you change the color of the World word? We could not select the whole p element. There exist specific tags like div and span which you can apply. As stated in @chapter(web-intro-html), span may be used inside containers to surround words: &lt;p&gt;Hello &lt;span class=&quot;custom&quot;&gt;World&lt;/span&gt;! What&#39;s up?&lt;/p&gt; .custom { color: red; } 5.2.4 Advanced selectors Until now, we’ seen how to select an element by the tag name, a class and an id. Yet, this is not enough. How would you select the below tag? &lt;a data-toggle=&quot;dropdown&quot;&gt;Tag&lt;/a&gt; 5.2.4.1 Select nested tags We consider 2 HTML tags. We only want the first a element to have a red text. We can’t select by class .nav-link as it would also style the second element! &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; The idea is to select the first tag, that is li, then select it’s child a: li a { color: red; } The Shiny navbarPage template is composed of navigation items li and a, which we may easily modify: ui &lt;- navbarPage( &quot;App Title&quot;, tabPanel( &quot;Plot&quot;, tags$style( &quot;li a { font-size: 20px; font-weight: bold; } &quot; ), tabsetPanel( tabPanel(&quot;Plot&quot;), tabPanel(&quot;Summary&quot;), tabPanel(&quot;Table&quot;) ) ), tabPanel(&quot;Summary&quot;), tabPanel(&quot;Table&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 5.2: Style all nav link elements You’ll notice that tabsetPanel tabs are also modified, which is not exactly what we wanted, as shown in Figure 5.2. The main difference between navbarPage and tabsetPanel is the class held by the the menu wrapper ul: as.character(navbarPage(tabPanel(&quot;test&quot;))) ## [1] &quot;&lt;nav class=\\&quot;navbar navbar-default navbar-static-top\\&quot; role=\\&quot;navigation\\&quot;&gt;\\n &lt;div class=\\&quot;container-fluid\\&quot;&gt;\\n &lt;div class=\\&quot;navbar-header\\&quot;&gt;\\n &lt;span class=\\&quot;navbar-brand\\&quot;&gt;\\n &lt;div class=\\&quot;tab-pane\\&quot; title=\\&quot;test\\&quot; data-value=\\&quot;test\\&quot;&gt;&lt;/div&gt;\\n &lt;/span&gt;\\n &lt;/div&gt;\\n &lt;ul class=\\&quot;nav navbar-nav\\&quot; data-tabsetid=\\&quot;6950\\&quot;&gt;&lt;/ul&gt;\\n &lt;/div&gt;\\n&lt;/nav&gt;\\n&lt;div class=\\&quot;container-fluid\\&quot;&gt;\\n &lt;div class=\\&quot;tab-content\\&quot; data-tabsetid=\\&quot;6950\\&quot;&gt;&lt;/div&gt;\\n&lt;/div&gt;&quot; as.character(tabsetPanel(tabPanel(&quot;test&quot;))) ## [1] &quot;&lt;div class=\\&quot;tabbable\\&quot;&gt;\\n &lt;ul class=\\&quot;nav nav-tabs\\&quot; data-tabsetid=\\&quot;1556\\&quot;&gt;\\n &lt;li class=\\&quot;nav-item\\&quot;&gt;\\n &lt;a href=\\&quot;#\\&quot; data-toggle=\\&quot;tab\\&quot; data-value=\\&quot;test\\&quot; class=\\&quot;nav-link active\\&quot; data-target=\\&quot;#tab-1556-1\\&quot;&gt;test&lt;/a&gt;\\n &lt;/li&gt;\\n &lt;/ul&gt;\\n &lt;div class=\\&quot;tab-content\\&quot; data-tabsetid=\\&quot;1556\\&quot;&gt;\\n &lt;div class=\\&quot;tab-pane active\\&quot; data-value=\\&quot;test\\&quot; id=\\&quot;tab-1556-1\\&quot;&gt;&lt;/div&gt;\\n &lt;/div&gt;\\n&lt;/div&gt;&quot; which is nav navbar-nav for navbarPage and nav nav-tabs for tabsetPanel. To isolate navbarPage tabs, we have to improve our previous selector: .navbar-nav li a { font-size: 20px; font-weight: bold; } Doing so, we’ll only look at the link elements inside the container having the navbar-nav class. ui &lt;- navbarPage( &quot;App Title&quot;, tabPanel( &quot;Plot&quot;, tags$style( &quot;.navbar-nav li a { font-size: 20px; font-weight: bold; } &quot; ), tabsetPanel( tabPanel(&quot;Plot&quot;), tabPanel(&quot;Summary&quot;), tabPanel(&quot;Table&quot;) ) ), tabPanel(&quot;Summary&quot;), tabPanel(&quot;Table&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) The final result is depicted in Figure 5.3. FIGURE 5.3: Style specific navbar nav link elements 5.2.4.2 Select by attributes To select by attribute, we use tag[attribute] &lt;a data-toggle=&quot;dropdown&quot;&gt;Tag&lt;/a&gt; &lt;a data-toggle=&quot;my dropdown&quot;&gt;Tag&lt;/a&gt; &lt;a data-toggle=&quot;whatever&quot;&gt;Tag&lt;/a&gt; The below CSS code, will select all a tags: a[data-toggle] { color: red; } while the following code, will only select the first a tag: a[data-toggle=&quot;dropdown&quot;] { color: red; } The reason is that we exactly match the dropdown value! We could be less specific: a[data-toggle*=&quot;dropdown&quot;] { color: red; } * checks whether the word dropdown is there but not the position. You may use ^ and $ like you do with regular expressions to check if the value starts or ends by the specified word, respectively. 5.2.4.3 Other selectors 5.2.4.4 Direct descendants Let’s consider a navbarPage with nested navigation. This is accomplished with the navbarMenu function: navbarPage(&quot;App Title&quot;, tabPanel(&quot;Plot&quot;), navbarMenu(&quot;More&quot;, tabPanel(&quot;Summary&quot;), &quot;----&quot;, &quot;Section header&quot;, tabPanel(&quot;Table&quot;) ) ) The resulting HTML code is as follow: &lt;ul class=&quot;nav navbar-nav&quot; data-tabsetid=&quot;5879&quot;&gt; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;#tab-5879-1&quot; data-toggle=&quot;tab&quot; data-value=&quot;Plot&quot;&gt;Plot&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; data-value=&quot;More&quot;&gt; More &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; data-tabsetid=&quot;7141&quot;&gt; &lt;li&gt; &lt;a href=&quot;#tab-7141-1&quot; data-toggle=&quot;tab&quot; data-value=&quot;Summary&quot;&gt;Summary&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-header&quot;&gt;Section header&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#tab-7141-4&quot; data-toggle=&quot;tab&quot; data-value=&quot;Table&quot;&gt;Table&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; We see that there are two ul menus with multiple li and a inside. Applying our previous CSS selector as depicted in Figure 5.4 selects all links. FIGURE 5.4: Style all navbar nav link elements What if we only want to select the direct a children of the outer menu (meaning we exclude the inner menu links)? Using the &gt; we can select direct children and not all descendant that could contain grand-children. .navbar-nav &gt; li &gt; a { font-size: 20px; font-weight: bold; } Result is displayed in Figure 5.5: ui &lt;- navbarPage( &quot;App Title&quot;, tabPanel( &quot;Plot&quot;, tags$style( HTML( &quot;.navbar-nav &gt; li &gt; a { font-size: 20px; font-weight: bold; } &quot; ) ) ), navbarMenu(&quot;More&quot;, tabPanel(&quot;Summary&quot;), &quot;----&quot;, &quot;Section header&quot;, tabPanel(&quot;Table&quot;) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 5.5: Style only direct children navbar nav link elements Well, what if we want to be even more specific and get only the very first nav link element? We’ll have to introduce pseudo classes. 5.2.4.4.1 Pseudo-classes A pseudo class starts with the : symbol. For instance, a:active styles active links, button:disabled applies for disabled buttons, … a:active { } button:disabled { } checkbox:checked { } There exists many pseudo class types, particularly the structural ones. Those are useful to select specific children like element:first-child. Going back to the navbarPage example, we could refine our CSS selector adding :first-child to the li element as we want to only select the first item: .navbar-nav &gt; li:first-child &gt; a { font-size: 20px; font-weight: bold; } As expected, only the first link is styled, as demonstrated in Figure 5.6! ui &lt;- navbarPage( &quot;App Title&quot;, tabPanel( &quot;Plot&quot;, tags$style( HTML( &quot;.navbar-nav &gt; li:first-child &gt; a { font-size: 20px; font-weight: bold; } &quot; ) ) ), navbarMenu(&quot;More&quot;, tabPanel(&quot;Summary&quot;), &quot;----&quot;, &quot;Section header&quot;, tabPanel(&quot;Table&quot;) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 5.6: Style only the first navbar nav link element 5.2.4.4.2 Pseudo-elements Pseudo elements are preceded by ::. One of the most famous ones are ::before and ::after that respectively apply before and after the selected element. a::before { } a::after { } For instance .navbar-nav &gt; li:first-child &gt; a::before will insert an element before the very first navbar link. ui &lt;- navbarPage( &quot;App Title&quot;, tabPanel( &quot;Plot&quot;, tags$style( HTML( &quot;.navbar-nav &gt; li:first-child &gt; a { font-size: 20px; font-weight: bold; } .navbar-nav &gt; li:first-child &gt; a::before { content: &#39;✌️&#39; } &quot; ) ) ), navbarMenu( &quot;More&quot;, tabPanel(&quot;Summary&quot;), &quot;----&quot;, &quot;Section header&quot;, tabPanel(&quot;Table&quot;) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 5.7: Add before pseudo-element 5.3 Modify CSS with the HTML inspector 5.3.1 Add inline properties Run the following app: ui &lt;- fluidPage( tags$style(&quot;p { color: red;}&quot;), p(&quot;Hello World&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) Right click the p element and open the inspector. In the Styles tab, notice the element.style section. This is to define inline new CSS rules for the selected item. Let’s add 2 rules by clicking inside the element.style container: border-style: dashed. Indicates we want a box with dashed border border-color: .... To set a border color After typing enter, the inline CSS is automatically added in the tag element. You probably noticed the auto suggestion feature while typing a property, as shown in Figure 5.8. FIGURE 5.8: Edit CSS with Chrome DevTools 5.3.2 View local changes Whenever playing around with a web page style or a shiny app, it may be good to have an overview of all changes when you are satisfied about the new design. Run the previous shiny app example and open the inspector In the Styles tab, add some new CSS properties to the first p element set of rules Once done press enter and click on the file name located at the top-right corner of the property box This opens the Sources tab. In the left sidebar, right click on the file name (index) and select Local Modifications This opens a Git like diff panel called Changes where you can review any change and see the previous values. If you refresh the page, you will loose every local change, unless the persistent authoring feature is active FIGURE 5.9: Review all CSS changes To get a deeper understanding of the different CSS options please refer to the Google documentation. 5.4 CSS in action Below we review the most commonly used CSS properties such as text styling, shadows, color and background color, … 5.4.1 Text Styling 5.4.1.1 Polices This controls the text appearance. The police may be changed like below: tag { font-family: mypolice1, mypolice2, ..., serif; } In practice, we enter multiple police values, in case the end user does not have the same police. The last values are composed of generic polices like serif and monospace. For instance, Bootstrap 3 that powers Shiny utilizes the default sans-serif police. A neat tool to inspect the current text polices is the HTML inspector CSS Overview tab, as shown Figure 5.10. FIGURE 5.10: Overview of font properties Custom polices may be downloaded with @font-face but there are few prerequisites to make it work properly: The files format must be correctly handled by the end user web browsers. There are currently .ttf (work on almost all web browser), .woff (work on almost all web browser), .svg (iPhone and iPad), .eot (IE only) and .otf (don’t work on IE). Those files have to be downloaded which may take time. Be careful about copyright! Most polices are not open source. @font-face { font-family: &#39;customPolice&#39;; src: url(&#39;customPolice.ttf&#39;), url(&#39;customPolice.woff&#39;); } Importantly, the police files must be accessible to the CSS file where they are called from. As another example, the below code means that the fonts folder is located one level above the CSS file: @font-face { font-family: &#39;Framework7 Icons&#39;; font-style: normal; font-weight: 400; src: url(&quot;../fonts/Framework7Icons-Regular.eot&quot;); src: url(&quot;../fonts/Framework7Icons-Regular.woff2&quot;) format(&quot;woff2&quot;), url(&quot;../fonts/Framework7Icons-Regular.woff&quot;) format(&quot;woff&quot;), url(&quot;../fonts/Framework7Icons-Regular.ttf&quot;) format(&quot;truetype&quot;); } 5.4.1.2 Size To change the text size, we use the font-size property. From there, you have 2 choices: relative size (first choice) like small, medium, … You may also find notations like 1em (default size), 1.8em being bigger and 0.5em being smaller; as well as percentages. absolute size: 16px, 20px, … In the following example, the second h1 tag is smaller than the default one, so is p: ui &lt;- fluidPage( tags$style( &quot;.smaller--h1 { font-size: 0.75em; } .smaller--p { font-size: 80%; } &quot; ), h1(&quot;Default &lt;h1&gt;&quot;), h1(class = &quot;smaller--h1&quot;, &quot;Smaller &lt;h1&gt;&quot;), p(&quot;Normal &lt;p&gt;&quot;), p(class = &quot;smaller--p&quot;, &quot;Smaller &lt;p&gt;&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) 5.4.1.3 Alignement This is a job for text-align which accepts 4 values (left, center, right and justify). Importantly, this does not work for inline tags like span! 5.4.1.4 Other styling properties You can also put any text in bold, italic using font-style: italic and font-weight: bold, respectively. 5.4.2 Colors We have already mentioned this property before in the previous examples. In CSS, there are 4 ways to apply colors to a text or to the background: Using the hexadecimal notation (HEX). For instance #FFFFFF corresponds to the white color. Given a color code, unless you already know it, the result is quite hard to predict. Could you guess what is the result of #4b0082? Using the rgb code. If you ever followed art courses, this is the classic system uses in painting, by mixing colors. rgb stands for red, green and blue. Each scale goes from 0 to 255 (256 choices), which gives a weight to each color! Why 255? Since 256256256 gives about 16 millions color, the maximum number of colors that actual screen can display. Using the hsl convention. hsl stands for hue, saturation and lightness. Saturation and lightness are expressed in percentage from 0 to 100. The hue goes from red (0) to 360 (a sort of red) each time incrementing by 15. The yellow color is 60. Using the color name like ghostwhite, maroon, red… While rgb and hsl give an unlimited number of possibilities, HTML color names are not infinite. There are many tools allowing to get each of those codes like, notably color pickers: https://html-color.codes/ https://www.w3schools.com/colors/colors_picker.asp 5.4.2.1 Text color Given the methods listed above, we use the color property to change any text color. For obvious colors like red, this is not necessary to use the rgb convention. p { color: red; } 5.4.2.2 Background color backgound-color is the property necessary to apply a given color to the background. To change to page background color, we target the body tag, but you could also target any tag like p. 5.4.3 Borders and shadows These effects may be applied to text and block elements. The easiest way to set up a border is to leverage the border propriety which takes 3 parameters: The border width in px. The border color with any valid CSS color like rgb(), red, … The border type, which corresponds to the border style (none, solid, dotted, dashed, double, groove, ridge, inset and outset). In practice, we mostly use solid. There exist other properties such as border-radius which controls the shape of the corners from top left to bottom left. The higher the value the most rounded is the corner. If for any reason, you want to fine tune the border position, there are four properties: border-top, border-bottom, border-left and border-right. Finally, shadows are controlled by two properties: text-shadow which applies a shadow to a text element (not the most used). box-shadow for styling blocks. For instance: block { box-shadow: 2px 2px 0px black; } The box-shadow property takes four main parameters: The horizontal offset in px. The vertical offset in px. The blur radius value in px. The higher the more blurred. The shadow color. Do your remember the {shinydashboard} box that we imported inside a simple shiny app from Chapter 4.3? This box has been included in the {OSUICode} side package. Let’s add it some border and shadows. library(OSUICode) library(shinyWidgets) ui &lt;- fluidPage( useShinydashboard(), br(), box2(title = &quot;Box with border&quot;, background = &quot;blue&quot;, height = &quot;400px&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) The box class is styled as follow and show Figure 5.11: .box { border-radius: 3px; border-top: 3px solid #d2d6de; box-shadow: 0 1px 1px rgb(0 0 0 / 10%); } FIGURE 5.11: Shinydashboard box style The border-radius of 3px indicates that the box is slightly rounded on all corners. There is a top solid border which color in gray as well as a tiny shadow. Let’ increase the border-radius to 10px, change the border top to border-left with an orange color and slightly increased thickness: .box { border-radius: 10px; border-left: 6px solid #e28810; box-shadow: 0 1px 1px rgb(0 0 0 / 10%); } We would like to increase the shadow effect only on mouse hover, with reasonable values. To proceed we leverage the pseudo format elements like :hover: .box:hover { box-shadow: 0px 8px 8px 0px rgb(0, 0, 0, 0.2); } The easiest way to modify the shadow style is directly inside the HTML inspector, as demonstrated on Figure 5.12. Next to the property text, there is a button to open the shadow editor. We click on it, which opens a box with input to control the shadow offset, the blur and spread parameter. We leave the effect outside the box, that is outset unchanged. To change the color, we click on the color widget next to the rgb value which opens Figure 5.13. FIGURE 5.12: Box shadow shape tools FIGURE 5.13: Box shadow color tools We finally include this new CSS rule inside the previous app. Optionally, we may change the color of the text header to be white, to improve the contrast with the box background (See Figure 5.14): ui &lt;- fluidPage( useShinydashboard(), tags$style( &quot;.box { border-top: none; border-radius: 10px; border-left: 6px solid #e28810; box-shadow: 0 1px 1px rgb(0 0 0 / 10%); } .box:hover { box-shadow: 0px 8px 8px 0px rgb(0, 0, 0, 0.2); } .box-header { color: #fff; } &quot; ), br(), box2(title = &quot;Box with border&quot;, background = &quot;blue&quot;, height = &quot;400px&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 5.14: Improved box shadow on hover 5.4.4 Layout As mentioned in section 1.2, there exist block and inline tags. While block elements are displayed under each other, inline elements are added next to each others, as shown in Figure 5.15. FIGURE 5.15: Inline and block elements CSS allows deep customization of block elements like setting up the width, height and margin. Let’s review them below. 5.4.4.1 Style blocks As shown Figure 5.16, a block tag may be seen as a box. CSS allows to set internal and external margins. Internal margins, also called padding, is the space between the block border and the content, in all directions. External margins also known as margin are all spaces between blocks in all directions. A block is also defined by a width and height as well as optional minimal width and height. Width and height may be set either using absolute unites (px) or relative unites(%) but minimal values are always absolute. Minimal values are useful in case the end user resizes the windows. The corresponding CSS properties are found below: .block { width: 50%; /* % also work and will be relative size*/ height: 200px; min-width: 200px; } Padding and margins are called CSS super properties. Indeed, setting padding: 10px guarantees to have 10px in all directions. If you need custom values, you will have to specify the directions as follows: .block { padding: 10px; margin-top: 10px; margin-left: 5px; } There exists a shortcut margin: 5px 0 5px 2 that means 5px on the top, 0 px on the right, 5 px on the bottom and 2px on the left. To remember about the good order, it is clockwise (top, right, bottom, left). Specifying only 2 values margin: 5px 2.5px means 5px top and bottom, 2.5px left and right. All of the above obviously applies to padding! FIGURE 5.16: Blocks layout Using margin allows to center a block when margin: auto is applied in combination with a given width. What happens when the content inside the block is bigger than the block itself? We apply the overflow super property that acts either horizontally or vertically. To have only vertical overflow, choose overflow-y. The overflow property has 4 possible values: visible shows the content. hidden hides the content that goes outside the block. scroll shows scrolling bars in all directions to see the hidden content. auto let the web browser decide. Let’s apply our newly acquired knowledge to a simple shiny app. ui &lt;- fluidPage( tags$style( &quot;.block { border-color: #00000; border-style: solid; background-color: lightblue; text-align: center; margin: 10px; min-height: 200px; width: 200px; } span, a { background-color: orange; } &quot; ), div( class = &quot;block&quot;, &quot;Block 1&quot;, br(), span(&quot;Inline text 1&quot;), span(&quot;Inline text 2&quot;) ), div( class = &quot;block&quot;, &quot;Block 2&quot;, br(), lapply(1:2, a, href = &quot;https://www.google.com/&quot;, &quot;Link&quot;) ), div( class = &quot;block&quot;, &quot;Block 3&quot;, lapply(1:5, span, &quot;Inline text&quot;) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) Well, is that all? I could to better by combining fluidRow and column! Indeed, those 2 functions are part of the grid system built on top of flexbox. Let’s talk about this in the next section. 5.4.4.2 Flexbox The flexbox (“flexible boxes”) model is a game changer in layout development as it allows to seamlessly: align items in a container. ensure those items fill the same space. … The first step is to define the main container and give the flex value to the display property: .container { display: flex; } Once done, we have to define the direction and have 4 choices, as shown Figure 5.17: row row-reverse column column-reverse FIGURE 5.17: Flexbox directions Below is an example involving shiny. We first define the container CSS where display: flex and flex-direction: row set the flexbox display. We also add a border to better see the container limits: .container { display: flex; flex-direction: row; border: red dashed 2px; } Then, we define the style for container elements, that are p tags. We give them a width and height to better see the blocks. Each child has a given background color with the :nth-child(n) pseudo class. As an exercise, you may try to replace the flex-direction by any of the 4 values and see how blocks move in the main container. ui &lt;- fluidPage( tags$style( &quot;.container { display: flex; flex-direction: row-reverse; border: red dashed 2px; } p { width: 200px; height: 200px; text-align: center; color: white; font-size: 50px; } .container :nth-child(1) { background-color: green; } .container :nth-child(2) { background-color: orange; } .container :nth-child(3) { background-color: purple; } &quot; ), div( class = &quot;container&quot;, p(&quot;A&quot;), p(&quot;B&quot;), p(&quot;C&quot;) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) The flex-wrap property may be useful to control how blocks are arranged: nowrap (default) put all items on the same row. wrap put items on multiple lines from top to bottom. wrap-reverse put items on multiple lines from bottom to top. Interestingly, both flex-wrap and flex-direction may be merged with flex-flow: direction wrap mode. Items may be aligned either on the principal axis defined in the container CSS or on the secondary axis, called cross-axis: justify-content that may take the following values flex-start (default), flex-end, center, space-between, space-around and space-evenly align-items whose values can be stretch (default), flex-start, flex-end, center and baseline justify-content and align-items are applied at the container level and not on individual items! Whenever the container has multiple line, as a result of a flex-wrap: wrap or flex-flow: ... wrap, we use align-content to align on the cross-axis (flex-start, flex-end, center, stretch by default, space-between, space-around). flexbox is a mono dimensional system. In the following, we review the CSS grid system… 5.4.4.3 Grid model As mentioned above, fluidRow and column leverage the Bootstrap grid system, that uses flexbox. This is unfortunately rather complex and out of the scope of this book. 5.4.5 Responsive design: media queries At the very beginning of the web, there was no smartphones or tablets. All websites were mostly designed to be display on fix computer screens. Everything has changed now, which leads to several problems for non responsive sites. Media queries are convenient to solve this issue. They allow to setup rules depending on various conditions. The structure is defined as follows: @media rule1 { /* CSS */ } /* We may combine rules */ @media rule1 and rule 2 and ... { /* CSS */ } For instance, assuming you want to increase the text size, only for mobile devices: @media all and (max-device-width: 480px) { p { font-size: 1.5em; } } all stands for all screen sizes and the second request target devices having a width of 480px, at most. In a shiny app this would give: ui &lt;- fluidPage( tags$style( &quot;@media all and (max-device-width: 480px) { p { font-size: 1.5em; } } &quot; ), p(&quot;Hello World&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) As shown on Figure 5.18, the developer tools have a responsive mode, which you can enable by clicking on the blue button next to the Elements tabs. The responsive mode let you define the viewport dimensions, that is the height and width of the web browser page so as to test the media queries. We set the width to 480 so that the text size appears increased. You may try with 481px and see that this text becomes smaller. Be careful, the responsive mode tool does not display the web browser navigation bars, nor the status bar (the bar containing the battery icon and various indicators). Be sure to select the ... icon to enable the show media queries and show rulers options. The media query option provides a better visualization of the media query range versus the current screen width, while the ruler helps to fine tune the design. FIGURE 5.18: HTML inspector in responsive mode Let’s consider another example, involving shiny::modalDialog. This function displays a Bootstrap 3 modal, whose design is partly controlled by media queries. We run the app below and open the developer tools: shinyApp( ui = fluidPage( actionButton(&quot;show&quot;, &quot;Show modal dialog&quot;) ), server = function(input, output) { observeEvent(input$show, { showModal( modalDialog( title = &quot;Important message&quot;, &quot;This is an important message!&quot; ) ) }) } ) The corresponding CSS rules are located in the Bootstrap (3) CSS file: @media (min-width: 768px) { .modal-dialog { width: 600px; margin: 30px auto; } .modal-content { -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); } .modal-sm { width: 300px; } } @media (min-width: 992px) { .modal-lg { width: 900px; } } The first query fixes a width of 600px for all modals having the .modal-dialog class (default), as long as the screen size is at least 768px. Moreover, if the modal has the modal-sm class, its width is set to 300px. Finally, as soon as the screen width is higher or equal to 992 px, all modals having the .modal-lg class have a width set to 900px. Figure 5.19 illustrates the modal responsiveness. FIGURE 5.19: Responsive modal. Left: first media query is fullfilled, width is 600px. Right: First media query not met, width is set to auto In Figure 5.20, we changed the modal size from s to l (left and right, respectively). FIGURE 5.20: Changed modal size. Left: small modal when screensize is at least 768px. Right: large modal when screen size is at least 992px. This has strong implications for the modal size on mobiles. As long as the screen size is lower than 768px, the size parameter is ignored! 5.5 Best practice 5.5.1 DRY principles DRY stands for “Don’t repeat yourself”. This methodology not only applies to structural languages like R and JavaScript but also to declarative languages like CSS. Below is an example of badly managed CSS code. Both .class-1 and .class-2 have the same color and border radius. Only the padding and font size change. This type of code does not follow the DRY rule and increases the risk of having contradictory CSS properties. .class-1{ color: #33BEFF; padding: 10px 16px; font-size: 12px; border-radius: 3px; } .class-2{ color: #33BEFF; padding: 5px 10px; font-size: 12px; border-radius: 3px; } We could gather all common properties in one generic class: .generic { color: #33BEFF; border-radius: 3px; } .specific-1 { padding: 10px 16px; font-size: 18px; } .specific2 { padding: 5px 10px; font-size: 12px; } On the HTML side, we add classes from the most generic to the most specific like: &lt;div class=&quot;generic specific-1&quot;&gt;My element&lt;/div&gt; &lt;div class=&quot;generic specific-2&quot;&gt;My element&lt;/div&gt; As an even more concrete example, take a look at the bulma button: &lt;button class=&quot;button is-large is-fullwidth&quot;&gt;Large&lt;/button&gt; Notice how easy it is to predict the style of the button. It will be large and take the maximum width. It is for sure more meaningful than .class1! 5.5.2 Selector specificity What happens in case multiple different selectors target the same element? Which style is really applied? Consider the following example: &lt;div id=&quot;element&quot; class=&quot;myclass&quot;&gt;Some text&lt;/div&gt; with the following CSS rules: #element { color: red; } .myclass { color: blue; } div { color: green; } Can you guess what would be the element text color? Well, this is not obvious. You must understand that web browsers apply rules to select the more specific rules: Inline style is the most specific. This is style directly attached to the HTML tag. id apply to unique objects. class, pseudoclasses, attributes. elements and pseudo-elements. Going back to our previous example, the most specific selector is #element, therefore the text color will be red. What happens in case of equality? The last written selector is applied: &lt;div class=&quot;class1 class2&quot;&gt;Some text&lt;/div&gt; .class1 { color: blue; } .class2 { color: red; } Only the second selector is applied to the tag. To apply class1, you must move it after the class2 style definition. Best practice is to keep the lowest specificity as possible, thereby making .class the first choice. 5.5.3 Block element modified (BEM) The BEM methodology will help you to write meaningful CSS, easier to manage. A block is a standalone entity having a self explanatory name like header, checkbox. An elements is part of the block but not standalone like menu items. A modifier indicates a specific state of an element, for instance if a button is disabled, active, … The general scheme is defined below: .block__element--modifier { /* rules */ } Following this methodology guaranties to have documented and meaningful classes. 5.6 Exercises TO DO "],["beautify-sass.html", "Chapter 6 Introduction to SASS 6.1 Getting started with Sass 6.2 {sass} best practices 6.3 From Sass to CSS 6.4 Sass and Shiny 6.5 Examples", " Chapter 6 Introduction to SASS One of the main problem with CSS is to handle the growing number of files and the code repetition. Nowadays, web developers mainly use CSS preprocessors like Sass, that stands for “Syntactically Awesome Style Sheets”, providing access to variables, mathematical operators, nesting, thereby reducing the code complexity and extending the possibilities. Rstudio developed the {sass} package, which makes it possible to use Sass in Shiny apps or Rmarkdown documents. 6.1 Getting started with Sass While we could use Sass from the terminal, we leverage the {sass} package features to stay in R. To install the {sass}, we run: install.packages(&quot;sass&quot;) # OR remotes::install_github(&quot;rstudio/sass&quot;) We then use the sass() function whose input parameter accepts: A R string like a { color: pink}. A named list(). A file passed with sass_file(), imports with sass_import(). More complex structures. library(sass) sass(input = &quot;.element-class { color: pink;}&quot;) .element-class { color: pink; } 6.1.1 Variables Let us consider the following example: .class-1{ color: #33BEFF; } .class-2{ background-color: #33BEFF; } Shouldn’t this be easier? Imagine if we had hundreds of elements with the same color. What happens in case the color changes? Do we have to update all properties by hand? If we let the Sass variable $my-color: $my-color: purple; .class-1{ color: $my-color; } .class-2{ background-color: $my-color; } we can quickly solve that problem. With {sass}, we obtain: var &lt;- &quot;$my-color: purple;&quot; rule1 &lt;- &quot;.class-1{ color: $my-color; }&quot; rule2 &lt;- &quot;.class-2{ background-color: $my-color; }&quot; sass(input = list(var, rule1, rule2)) .class-1 { color: purple; } .class-2 { background-color: purple; } Note: it is good practice to add the default! tag after the variable definition, if you want to let others modify it: \"$my-color: purple !default;\" 6.1.2 Partials and Modules It is best practice to save useful code snippets in one place, and reuse them at anytime and anywhere. Sass allows to define partials, like _partial.css, with the leading underscore, which avoids it to be converted into CSS. Partials are subsequently called with @import &lt;PARTIAL_NAME&gt; (you may also find @use, the latter not being handled by LibSass, which fuels{sass}), thereby significantly reducing code duplication. Modules are pieces of Sass files that are later converted into CSS, reducing file size to a minimum. Below is an example of the bootstrap.scss file: /*! * Bootstrap v5.0.0-beta1 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) */ // scss-docs-start import-stack // Configuration @import &quot;functions&quot;; @import &quot;variables&quot;; @import &quot;mixins&quot;; @import &quot;utilities&quot;; // Layout &amp; components @import &quot;root&quot;; @import &quot;reboot&quot;; @import &quot;type&quot;; @import &quot;images&quot;; @import &quot;containers&quot;; @import &quot;grid&quot;; @import &quot;tables&quot;; @import &quot;forms&quot;; @import &quot;buttons&quot;; @import &quot;transitions&quot;; @import &quot;dropdown&quot;; @import &quot;button-group&quot;; @import &quot;nav&quot;; @import &quot;navbar&quot;; @import &quot;card&quot;; @import &quot;accordion&quot;; @import &quot;breadcrumb&quot;; @import &quot;pagination&quot;; @import &quot;badge&quot;; @import &quot;alert&quot;; @import &quot;progress&quot;; @import &quot;list-group&quot;; @import &quot;close&quot;; @import &quot;toasts&quot;; @import &quot;modal&quot;; @import &quot;tooltip&quot;; @import &quot;popover&quot;; @import &quot;carousel&quot;; @import &quot;spinners&quot;; // Helpers @import &quot;helpers&quot;; // Utilities @import &quot;utilities/api&quot;; // scss-docs-end import-stack which is better to read and easier to maintain than the original bootstrap.css with 10717 lines of code! In practice, we will often end up with a main Sass file and compile it as follows: sass(sass_file(&quot;main.scss&quot;)) 6.1.3 Mixins and Functions 6.1.3.1 Mixins To make a 90 degrees rotation in CSS, we have to write: .element { -webkit-transform: rotate(90deg); -ms-transform: rotate(90deg); transform: rotate(90deg); } which is tedious. Mixins allow to encapsulate the logic into a reusable unit: @mixin transform($property, ...) { -webkit-transform: $property; -ms-transform: $property; transform: $property; } .element1 { @include transform(rotate(90deg)); } The mixin starts with a @mixin keyword followed by its name and parameters. It is called with @include &lt;MIXIN_NAME(PARMS)&gt;, very similar to a function declaration, excepts that it must return a CSS rule. mixin &lt;- &quot;@mixin transform($property) { -webkit-transform: $property; -ms-transform: $property; transform: $property; }&quot; rule &lt;- &quot;.element1 { @include transform(rotate(90deg)); }&quot; sass(input = list(mixin, rule)) .element1 { -webkit-transform: rotate(90deg); -ms-transform: rotate(90deg); transform: rotate(90deg); } 6.1.3.2 Functions Sass offers many built-In modules containing ready to use functions for colors, numbers, strings, lists, maps, …Some functions like rgb are global, so that we don’t have to import the corresponding module. sass(&quot;.pouet { color: rgb(0, 255, 0); }&quot;) .pouet { color: lime; } It is definitely possible to design custom functions with @function, whose syntax is very close the mixins: @function name($parm1, $parm2) { /* logic */ @return value; } While debugging functions, it might be useful to capture intermediate elements. @debug allows this: $my-var: 1; @debug myvar; sass(&quot; $myvar: 1; @debug &#39;$myvar is #{$myvar};&#39; &quot;) 6.1.4 Extend/Inheritance We consider 2 alerts with the color as only difference. As we can’t capture multiple properties inside one single Sass variable, we introduce the extend concept, which permits to import CSS properties inside multiple rules. We first define a generic alerts-common rule, prefixed by the % symbol. It contains several rules and variables: %alerts-common { position: relative; padding: $alert-padding-y $alert-padding-x; margin-bottom: $alert-margin-bottom; } .alert-red { @extend %alerts-common; color: red; } .alert-green { @extend %alerts-common; color: green; } Let’s translate this into R: y_padding &lt;- &quot;$alert-padding-y: 5px;&quot; x_padding &lt;- &quot;$alert-padding-x: 10px;&quot; b_margin &lt;- &quot;$alert-margin-bottom: 2px;&quot; common &lt;- &quot;%alerts-common { position: relative; padding: $alert-padding-y $alert-padding-x; margin-bottom: $alert-margin-bottom; }&quot; alert_red &lt;- &quot;.alert-red { @extend %alerts-common; color: red; } &quot; alert_green &lt;- &quot;.alert-green { @extend %alerts-common; color: green; } &quot; sass(input = list(y_padding, x_padding, b_margin, common, alert_red, alert_green)) .alert-green, .alert-red { position: relative; padding: 5px 10px; margin-bottom: 2px; } .alert-red { color: red; } .alert-green { color: green; } This method avoids to multiply classes on elements such as .alert-common .alert-red .... Yet, there is still duplication as we could have programmatically generated the two alert classes with a loop. 6.1.5 Flow Controls These are elements aiming at fine tuning mixins and functions behavior. #### If and else Like in every programming language if and else control the execution of a code block, depending on some conditions. Below, we only want to conditionally control a shadow property, depending on the alert color: @mixin add-shadow($box-color) { @if box-color == red { box-shadow: 0 4px 10px 0 rgb(255, 0, 0), 0 4px 20px 0 rgb(255, 0, 0); } @else if $box-color == green { box-shadow: 0 4px 10px 0 rgb(0, 255, 0), 0 4px 20px 0 rgb(0, 255, 0); } } .alert-red { @extend %alerts-common; color: red; @include add-shadow($box-color: red); } .alert-green { @extend %alerts-common; color: green; @include add-shadow($box-color: green); } add_shadow &lt;- &quot;@mixin add-shadow($box-color) { @if $box-color == red { box-shadow: 0 4px 10px 0 rgb(255, 0, 0), 0 4px 20px 0 rgb(255, 0, 0); } @else if $box-color == green { box-shadow: 0 4px 10px 0 rgb(0, 255, 0), 0 4px 20px 0 rgb(0, 255, 0); } } &quot; y_padding &lt;- &quot;$alert-padding-y: 5px;&quot; x_padding &lt;- &quot;$alert-padding-x: 10px;&quot; b_margin &lt;- &quot;$alert-margin-bottom: 2px;&quot; common &lt;- &quot;%alerts-common { position: relative; padding: $alert-padding-y $alert-padding-x; margin-bottom: $alert-margin-bottom; }&quot; alert_red &lt;- &quot;.alert-red { @extend %alerts-common; color: red; @include add-shadow($box-color: red); } &quot; alert_green &lt;- &quot;.alert-green { @extend %alerts-common; color: green; @include add-shadow($box-color: green); } &quot; sass(input = list(y_padding, x_padding, b_margin, common, add_shadow, alert_red, alert_green)) .alert-green, .alert-red { position: relative; padding: 5px 10px; margin-bottom: 2px; } .alert-red { color: red; box-shadow: 0 4px 10px 0 red, 0 4px 20px 0 red; } .alert-green { color: green; box-shadow: 0 4px 10px 0 lime, 0 4px 20px 0 lime; } 6.1.5.1 Loops 6.1.5.1.1 Each We would like to create the alert class with only one rule. We first define a list of colors in Sass and call the @each: $colors: red, green; @each $color in $colors { .alert-#{$color} { color: green; @include add-shadow($box-color: $color); } } The structure is the same as the JavaScript loop. You’ll also notice the #{...} which is called interpolation and allows to insert any Sass expression in a string. As another example, if we want to create a background-image property within a mixin, we could do background-image: url(\"/some_path/#{$name}.svg\"), where #{$name} holds the file name. add_shadow &lt;- &quot;@mixin add-shadow($box-color) { @if $box-color == red { box-shadow: 0 4px 10px 0 rgb(255, 0, 0), 0 4px 20px 0 rgb(255, 0, 0); } @else if $box-color == green { box-shadow: 0 4px 10px 0 rgb(0, 255, 0), 0 4px 20px 0 rgb(0, 255, 0); } } &quot; y_padding &lt;- &quot;$alert-padding-y: 5px;&quot; x_padding &lt;- &quot;$alert-padding-x: 10px;&quot; b_margin &lt;- &quot;$alert-margin-bottom: 2px;&quot; common &lt;- &quot;%alerts-common { position: relative; padding: $alert-padding-y $alert-padding-x; margin-bottom: $alert-margin-bottom; }&quot; alerts_rule &lt;- &quot;$colors: red, green; @each $color in $colors { .alert-#{$color} { @extend %alerts-common; color: green; @include add-shadow($box-color: $color); } } &quot; sass(input = list(y_padding, x_padding, b_margin, common, add_shadow, alerts_rule)) .alert-green, .alert-red { position: relative; padding: 5px 10px; margin-bottom: 2px; } .alert-red { color: green; box-shadow: 0 4px 10px 0 red, 0 4px 20px 0 red; } .alert-green { color: green; box-shadow: 0 4px 10px 0 lime, 0 4px 20px 0 lime; } It becomes even more powerful while working with maps like $font-weights: (\"regular\": 400, \"medium\": 500, \"bold\": 700);, ie by key/value pairs. @each is as convenient as lapply or map functions to chain repetitive rules creation. 6.1.5.1.2 For However, it is not straightforward to count up or down with @each. This is precisely where @for fills the gap. The generic scheme is: @for &lt;variable&gt; from &lt;expression&gt; to &lt;expression&gt; { ... } @for &lt;variable&gt; from &lt;expression&gt; through &lt;expression&gt; { ... } to excludes the last number while through includes it. 6.2 {sass} best practices As it’s best practice, especially for debugging purposes, to include assets as HTML dependencies, it is a good idea to organize the Sass variable definition, function/mixins in layers, leveraging the sass_layer function: var &lt;- &quot;$my-color: purple !default&quot; rule1 &lt;- &quot;.class-1{ color: $my-color; }&quot; rule2 &lt;- &quot;.class-2{ background-color: $my-color; }&quot; layer1 &lt;- sass_layer( default = var, rules = c(rule1, rule2) ) ## Warning in sass_layer(default = var, rules = c(rule1, rule2)): partial argument match of &#39;default&#39; to &#39;defaults&#39; Besides, sass_layer provide options like: declarations containing any function, mixin elements, in a sass_file for instance. html_deps that attaches a single or a list of HTML dependencies to the provided Sass code. (See below) sass_layer( html_deps = htmltools::htmlDependency( name = &quot;my-dep&quot;, version = &quot;1.0.0&quot;, package = &quot;mypkg&quot;, src = &quot;path&quot;, ... ) ) Ultimately, multiple layers may be bundled with sass_bundle: var2 &lt;- &quot;$my-color: blue !default&quot; layer2 &lt;- sass_layer( default = var2, rules = c(rule1, rule2) ) ## Warning in sass_layer(default = var2, rules = c(rule1, rule2)): partial argument match of &#39;default&#39; to &#39;defaults&#39; my_bundle &lt;- sass_bundle(layer1 = layer1, layer2 = layer1) my_bundle ## /* Sass Bundle: layer1, layer2 */ ## $my-color: purple !default ## $my-color: purple !default ## .class-1{ color: $my-color; } ## .class-2{ background-color: $my-color; } ## .class-1{ color: $my-color; } ## .class-2{ background-color: $my-color; } ## /* *** */ sass(my_bundle) .class-1 { color: purple; } .class-2 { background-color: purple; } .class-1 { color: purple; } .class-2 { background-color: purple; } and sass_bundle_remove removes a given layer from the bundle, provided that you passed a named list to sass_bundle. This allows other developers to reuse and modify predefined layers: my_bundle &lt;- sass_bundle_remove(my_bundle, &quot;layer2&quot;) sass(my_bundle) .class-1 { color: purple; } .class-2 { background-color: purple; } 6.3 From Sass to CSS sass can generate CSS from Sass by passing an output parameter pointing to the path where to generate the CSS file. Best practice consists in enabling compression and source maps. We discuss this later in the book in Chapter 21. Overall those steps makes the code faster to load and easier to debug: sass( list( &quot;$color: pink;&quot;, &quot;.a { color: $color; }&quot; ), options = sass_options( output_style = &quot;compressed&quot;, source_map_embed = TRUE ) ) .a{color:pink} /*# sourceMappingURL=data:application/json;base64,ewoJInZlcnNpb24iOiAzLAoJImZpbGUiOiAic3RkaW4uY3NzIiwKCSJzb3VyY2VzIjogWwoJCSJzdGRpbiIKCV0sCgkibmFtZXMiOiBbXSwKCSJtYXBwaW5ncyI6ICJBQUNBLEFBQUEsRUFBRSxBQUFDLENBQUUsS0FBSyxDQURGLElBQUksQ0FDVSIKfQ== */ sass( sass_file(&quot;main.scss&quot;), &quot;&lt;OUTPUT PATH&gt;&quot;, options = sass_options( output_style = &quot;compressed&quot;, source_map_embed = TRUE ) ) 6.4 Sass and Shiny Now let’s go back to Shiny! How do we include Sass code in a Shiny app? There are multiple situations: You simply want to style a shiny app. You developed a template with custom JS and Sass/CSS to be reused by other developers. The first option is rather simple since the Sass code is compiled with sass before the shiny apps is launched. The resulting code may be either a string or a CSS file (within the www folder), to be included in the head. To make it easier to test on the reader side, we create a temporary folder where the Sass code is compiled. We then create a simple app file which is run with runApp: path &lt;- file.path(tempdir(), &quot;myApp&quot;) dir.create(sprintf(&quot;%s/www&quot;, path), recursive = TRUE) sass( list( c(&quot;$color: pink;&quot;, &quot;$size: 30px;&quot;), c(&quot;.awesome-link { color: $color; font-size: $size; &amp;:hover{ color: green; } }&quot; ) ), output = sprintf(&quot;%s/www/main.min.css&quot;, path), options = sass_options( output_style = &quot;compressed&quot;, source_map_embed = TRUE ) ) file.create(sprintf(&quot;%s/app.R&quot;, path)) app_code &lt;- &#39;library(shiny) ui &lt;- fluidPage( tags$head( tags$link(href = &quot;main.min.css&quot;, rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;) ), a(&quot;Hello Shiny!&quot;, class = &quot;awesome-link&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) &#39; writeLines(app_code, sprintf(&quot;%s/app.R&quot;, path)) runApp(sprintf(&quot;%s&quot;, path)) Source maps allow us to see the original Sass code, as shown Figure 6.1. sass_options gives the flexibility to fine tune the CSS output and source map configuration. FIGURE 6.1: Inspect Sass code in the web browser The second option requires to run sass passing an output file within the package. Then, the generated CSS is included in an HTML dependency, to be shipped with the template: sass( sass_file(&quot;main.scss&quot;), &quot;&lt;OUTPUT PATH&gt;/main.css&quot;, options = sass_options( output_style = &quot;compressed&quot;, source_map_embed = TRUE ) ) my_css_deps &lt;- htmltools::htmlDependency( name = &quot;my-style&quot;, version = &quot;1.0.0&quot;, package = &quot;mypkg&quot;, src = &quot;&lt;OUTPUT PATH&gt;&quot;, stylesheet = &quot;main.css&quot; ) 6.5 Examples 6.5.1 Customize {bs4Dash} colors {bs4Dash} is a Bootstrap 4 dashboard template built on top of the AdminLTE3 HTML template. {shinydashboard} is powered by the previous version, that is AdminLTE2, which make it somehow {bs4Dash}’s big brother! AdminLTE3 relies on Sass and all files are stored here. Particularly, all variables are located in the _variables.scss partial. Since we can decompose our Sass code in multiple layers thanks to {sass}, we can seamlessly customize the theme color variables listed below: $blue: #0073b7 !default; $lightblue: #3c8dbc !default; $navy: #001f3f !default; $teal: #39cccc !default; $olive: #3d9970 !default; $lime: #01ff70 !default; $orange: #ff851b !default; $fuchsia: #f012be !default; $purple: #605ca8 !default; $maroon: #d81b60 !default; $black: #111 !default; $gray-x-light: #d2d6de !default; Let’s provide our own default with some custom colors: $blue: #136377 !default; $olive: #d8bc66 !default; $lime: #fcec0c !default; $orange: #978d01 !default; $maroon: #58482c !default; $gray-x-light: #d1c5c0 !default; Now we would have to recompile the whole AdminLTE3 Sass code to account for these changes. It means, all scss assets must be accessible somewhere: this is what the {fresh} package is doing under the hoods. No worries, we’ll come back on {fresh} in the next Chapter. For now, we rely on the {fresh} Sass code stored at system.file(\"assets/AdminLTE-3.0.4/AdminLTE.scss\", package = \"fresh\"): library(bs4Dash) css &lt;- sass( sass_layer( default = c( &quot;$lightblue: #136377 !default;&quot;, &quot;$olive: #d8bc66 !default;&quot;, &quot;$lime: #fcec0c !default;&quot;, &quot;$orange: #978d01 !default;&quot;, &quot;$maroon: #58482c !default;&quot;, &quot;$gray-x-light: #d1c5c0 !default;&quot; ), rules = sass_file( input = system.file(&quot;assets/AdminLTE-3.0.4/AdminLTE.scss&quot;, package = &quot;fresh&quot;) ) ) ) ui &lt;- dashboardPage( dashboardHeader(title = &quot;Custom colors&quot;), dashboardSidebar(), dashboardBody( tags$head(tags$style(css)), # Boxes need to be put in a row (or column) fluidRow( box(plotOutput(&quot;plot1&quot;, height = 250), status = &quot;olive&quot;), box( status = &quot;lightblue&quot;, title = &quot;Controls&quot;, sliderInput(&quot;slider&quot;, &quot;Number of observations:&quot;, 1, 100, 50) ) ) ) ) server &lt;- function(input, output) { set.seed(122) histdata &lt;- rnorm(500) output$plot1 &lt;- renderPlot({ data &lt;- histdata[seq_len(input$slider)] hist(data) }) } shinyApp(ui, server) You probably noticed a potential issue. We indeed have to rely on a specific version, namely 3.0.4, that is not necessarily the one we want. Therefore, an alternative could be to download the Sass files from the AdminLTE3, store them in a temp folder and recompile the code from that folder with new variables. As AdminLTE3 depends on a very specific version of Bootstrap 4, 4.5.3, we also have to recover those dependencies in a separate folder. We finally edit the original adminlte.scss to change the Bootstrap Sass path: /*! * AdminLTE v3.1.0-rc * Author: Colorlib * Website: AdminLTE.io &lt;https://adminlte.io&gt; * License: Open source - MIT &lt;https://opensource.org/licenses/MIT&gt; */ // Bootstrap // --------------------------------------------------- @import &quot;../bootstrap/scss/functions&quot;; @import &quot;bootstrap-variables&quot;; @import &quot;../bootstrap/scss/bootstrap&quot;; // Variables and Mixins // --------------------------------------------------- @import &quot;variables&quot;; @import &quot;mixins&quot;; @import &quot;parts/core&quot;; @import &quot;parts/components&quot;; @import &quot;parts/extra-components&quot;; @import &quot;parts/pages&quot;; @import &quot;parts/plugins&quot;; @import &quot;parts/miscellaneous&quot;; In the below demonstration, in addition to change the theme colors, we also modified the $sidebar-dark-bg variable to be $lightblue and $sidebar-light-bg to $lime: temp_path &lt;- file.path(tempdir()) dir.create(file.path(temp_path, &quot;adminlte&quot;)) setwd(file.path(temp_path, &quot;adminlte&quot;)) system(&quot;wget -r -np -k --cut-dirs=4 -nH https://cdn.jsdelivr.net/npm/admin-lte@3.1.0-rc/build/scss/&quot;) dir.create(file.path(temp_path, &quot;bootstrap/scss&quot;), recursive = TRUE) setwd(file.path(temp_path, &quot;bootstrap/scss&quot;)) system(&quot;wget -r -np -k --cut-dirs=3 -nH https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/scss/&quot;) adminlte_scss &lt;- sprintf(&quot;%s/adminlte/adminlte.scss&quot;, temp_path) css &lt;- sass( sass_layer( default = c( &quot;$lightblue: #136377 !default;&quot;, &quot;$olive: #d8bc66 !default;&quot;, &quot;$lime: #fcec0c !default;&quot;, &quot;$orange: #978d01 !default;&quot;, &quot;$maroon: #58482c !default;&quot;, &quot;$gray-x-light: #d1c5c0 !default;&quot;, &quot;$sidebar-dark-bg: $lightblue !default;&quot;, &quot;$sidebar-light-bg: $lime !default;&quot; ), rules = sass_file(input = adminlte_scss) ) ) ui &lt;- dashboardPage( dashboardHeader(title = &quot;Custom colors&quot;), dashboardSidebar(), dashboardBody( tags$head(tags$style(css)), # Boxes need to be put in a row (or column) fluidRow( box(plotOutput(&quot;plot1&quot;, height = 250), status = &quot;olive&quot;), box( status = &quot;lightblue&quot;, title = &quot;Controls&quot;, sliderInput(&quot;slider&quot;, &quot;Number of observations:&quot;, 1, 100, 50) ) ) ) ) shinyApp(ui, server) 6.5.2 Customize {shinybulma} For convenience, the Sass code is already included in the book side package. The goal is to change the main color palette that comprises: primary info success warning danger In total, bulma exposes 419 Sass variables! Among all files, we locate the main variables file and select the relevant variables you want to modify. Notice you can retrieve all those information: initial variables and derived variables. We assign them new values: $turquoise: #03a4ff; $cyan: #e705be; $green: #f3d6e9; $yellow: #fdaf2c; $red: #ff483e; $scheme-main: hsl(0, 0%, 4%); Particularly, we target the main body color hosted by $scheme-main. Instead of pointing to $white, we change its value to the default $black. We then Compile the new CSS with sass: css &lt;- sass( sass_layer( default = c( &quot;$turquoise: #03a4ff;&quot;, &quot;$cyan: #e705be;&quot;, &quot;$green: #f3d6e9;&quot;, &quot;$yellow: #fdaf2c;&quot;, &quot;$red: #ff483e;&quot;, &quot;$scheme-main: hsl(0, 0%, 10%);&quot; ), rules = sass_file(input = system.file(&quot;sass/bulma/bulma.sass&quot;, package = &quot;OSUICode&quot;)) ) ) ## Warning in sass_layer(default = c(&quot;$turquoise: #03a4ff;&quot;, &quot;$cyan: #e705be;&quot;, : partial argument match of &#39;default&#39; to &#39;defaults&#39; Finally, we try the new theme in the following app, shown on Figure 6.2: #remotes::install_github(&quot;RinteRface/shinybulma&quot;) library(shinybulma) shinyApp( ui = bulmaPage( tags$head(tags$style(css)), bulmaSection( bulmaTileAncestor( bulmaTileParent( vertical = TRUE, bulmaTileChild( bulmaTitle(&quot;Tile 1&quot;), p(&quot;Put some data here&quot;), color = &quot;link&quot; ), bulmaTileChild( bulmaTitle(&quot;Tile 2&quot;), &quot;Hi Bulma!&quot;, color = &quot;danger&quot; ) ), bulmaTileParent( vertical = TRUE, bulmaTileChild( bulmaTitle(&quot;Tile 3&quot;), p(&quot;Put some data here&quot;), color = &quot;warning&quot; ), bulmaTileChild( bulmaTitle(&quot;Tile 3&quot;), (&quot;Put some data here&quot;), color = &quot;info&quot; ) ) ) ) ), server = function(input, output) {} ) FIGURE 6.2: Custom bulma theme "],["beautify-with-fresh.html", "Chapter 7 Beautify with fresh 7.1 {fresh}, the big picture", " Chapter 7 Beautify with fresh {fresh} is an R package developed by the dreamRs team, also authors of shinyWidget and esquisse. All dreamRs projects are clearly a great source of inspiration to design outstanding Shiny apps, I recommend the reader to explore! 7.1 {fresh}, the big picture {fresh} is built on top of {sass} and what you see in Figures 7.1 and 7.2 may be done in few minutes! 7.1.1 Customize {bs4Dash} FIGURE 7.1: Few lines of code to create a bs4Dash dark theme! library(bs4Dash) # Theme ------------------------------------------------------------------- bs4DashTheme &lt;- create_theme( bs4dash_vars( navbar_dark_color = &quot;#bec5cb&quot;, navbar_dark_active_color = &quot;#FFF&quot;, navbar_dark_hover_color = &quot;#FFF&quot; ), bs4dash_yiq(contrasted_threshold = 10, text_dark = &quot;#FFF&quot;, text_light = &quot;#272c30&quot;), bs4dash_layout(main_bg = &quot;#353c42&quot;), bs4dash_sidebar_dark( bg = &quot;#272c30&quot;, color = &quot;#bec5cb&quot;, hover_color = &quot;#FFF&quot;, submenu_bg = &quot;#272c30&quot;, submenu_color = &quot;#FFF&quot;, submenu_hover_color = &quot;#FFF&quot; ), bs4dash_status(dark = &quot;#272c30&quot;), bs4dash_color(gray_900 = &quot;#FFF&quot;, white = &quot;#272c30&quot;) ) # App --------------------------------------------------------------------- ui &lt;- bs4DashPage( title = &quot;bs4Dash Dark Mode&quot;, # sidebar_collapsed = FALSE, navbar = bs4DashNavbar(skin = &quot;dark&quot;), controlbar = bs4DashControlbar( skin = &quot;dark&quot;, &quot;This is the control bar&quot; ), sidebar = bs4DashSidebar( title = &quot;bs4Dash Dark Mode&quot;, skin = &quot;dark&quot;, bs4SidebarMenu( bs4SidebarHeader(&quot;Menu:&quot;), bs4SidebarMenuItem( tabName = &quot;tab1&quot;, text = &quot;UI components&quot;, icon = &quot;home&quot; ), bs4SidebarMenuItem( tabName = &quot;tab2&quot;, text = &quot;Tab 2&quot; ), bs4SidebarMenuItem( text = &quot;Item List&quot;, icon = &quot;bars&quot;, startExpanded = TRUE, bs4SidebarMenuSubItem( text = &quot;Item 1&quot;, tabName = &quot;item1&quot;, icon = &quot;circle-thin&quot; ), bs4SidebarMenuSubItem( text = &quot;Item 2&quot;, tabName = &quot;item2&quot;, icon = &quot;circle-thin&quot; ) ) ) ), body = bs4DashBody( use_theme(bs4DashTheme), bs4TabItems( bs4TabItem( tabName = &quot;tab1&quot;, tags$h2(&quot;UI components&quot;), tags$h4(&quot;bs4ValueBox&quot;), fluidRow( bs4ValueBox( value = 150, subtitle = &quot;ValueBox with primary status&quot;, status = &quot;primary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4ValueBox( value = 150, subtitle = &quot;ValueBox with secondary status&quot;, status = &quot;secondary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4ValueBox( value = &quot;53%&quot;, subtitle = &quot;ValueBox with danger status&quot;, status = &quot;danger&quot;, icon = &quot;cogs&quot;, footer = &quot;Hello World&quot;, width = 4 ) ), tags$h4(&quot;bs4InfoBox&quot;), fluidRow( bs4InfoBox( value = 150, title = &quot;InfoBox with primary status&quot;, iconStatus = &quot;primary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4InfoBox( value = 150, title = &quot;InfoBox with secondary status&quot;, iconStatus = &quot;secondary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4InfoBox( value = &quot;53%&quot;, title = &quot;InfoBox with danger status&quot;, iconStatus = &quot;danger&quot;, icon = &quot;cogs&quot;, footer = &quot;Hello World&quot;, width = 4 ) ), tags$h4(&quot;bs4Card&quot;), fluidRow( bs4Card( title = &quot;Card with primary status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;primary&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with secondary status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;secondary&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with danger status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;danger&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with warning status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;warning&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with info status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;info&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with success status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;success&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ) ) ), bs4TabItem( tabName = &quot;tab2&quot;, &quot;Nothing to see here&quot; ) ) ) ) server &lt;- function(input, output) { } shinyApp(ui, server) 7.1.2 Customize {shinydashboard} Similarly, {fresh} supports {shinydashboard} powered apps. In few lines of code, you may definitely provide a cyberpunk look and feel to your favorite dashboard (Figure 7.2). {shinydashboardPlus} (v2) has a plug and play support for {fresh} where the theme has to be passed to the dashboardPage freshTheme parameter (it would also seamlessly work with {shinydashboard}). Importantly, I strongly suggest to avoid setting the default green to blue, as it might become confusing. Prefer playing with different color palettes. FIGURE 7.2: Cyberpunk shinydashboard theme &lt;- create_theme( adminlte_color( green = &quot;#3fff2d&quot;, blue = &quot;#2635ff&quot;, red = &quot; #ff2b2b&quot;, yellow = &quot;#feff6e&quot;, fuchsia = &quot;#ff5bf8&quot;, navy = &quot;#374c92&quot;, purple = &quot;#615cbf&quot;, maroon = &quot;#b659c9&quot;, light_blue = &quot;#5691cc&quot; ), adminlte_sidebar( dark_bg = &quot;#D8DEE9&quot;, dark_hover_bg = &quot;#81A1C1&quot;, dark_color = &quot;#2E3440&quot; ), adminlte_global( content_bg = &quot;#aaaaaa&quot; ) ) # create tribble for box global config box_config &lt;- tibble::tribble( ~background, ~labelStatus, &quot;red&quot;, &quot;warning&quot;, &quot;purple&quot;, &quot;success&quot;, &quot;green&quot;, &quot;primary&quot;, &quot;yellow&quot;, &quot;danger&quot;, &quot;fuchsia&quot;, &quot;info&quot; ) # box factory function box_factory &lt;- function(background, labelStatus) { box( title = &quot;Cyberpunk Box&quot;, collapsible = TRUE, background = background, height = &quot;200px&quot;, label = boxLabel(1, labelStatus) ) } # pmap magic boxes &lt;- purrr::pmap(box_config, box_factory) shinyApp( ui = dashboardPage( freshTheme = theme, skin = &quot;blue&quot;, options = list(sidebarExpandOnHover = TRUE), header = dashboardHeader( dropdownMenu( type = &quot;messages&quot;, badgeStatus = &quot;success&quot;, messageItem( from = &quot;Support Team&quot;, message = &quot;This is the content of a message.&quot;, time = &quot;5 mins&quot; ), messageItem( from = &quot;Support Team&quot;, message = &quot;This is the content of another message.&quot;, time = &quot;2 hours&quot; ) ) ), sidebar = dashboardSidebar( sidebarMenu( menuItem(&quot;Item 1&quot;, badgeLabel = icon(&quot;heart&quot;), badgeColor = &quot;light-blue&quot;), menuItem(&quot;Item 2&quot;, badgeLabel = icon(&quot;poo&quot;), badgeColor = &quot;maroon&quot;) ) ), body = dashboardBody(boxes), controlbar = dashboardControlbar(), title = &quot;Fresh theming&quot; ), server = function(input, output) { } ) "],["beautify-with-bootstraplib.html", "Chapter 8 Beautify with {bslib} 8.1 Disclaimer 8.2 Plug and play customization 8.3 Dynamic theming 8.4 Custom elements 8.5 Further resources", " Chapter 8 Beautify with {bslib} {bslib} (Sievert and Cheng 2021) is a package developed by RStudio. It is built on top {sass} like {fresh} (Perrier and Meyer 2020b). 8.1 Disclaimer This feature requires {shiny} &gt;= 1.6.0. 8.2 Plug and play customization Like {fresh}, {bslib} offers a high level set of functions allowing to quickly customize shiny apps. For many users, this step will be enough. bs_theme() seamlessly modifies the main CSS properties like: The background color, namely bg. The foreground color, namely fg. Change default theme colors, also called accents. Modify the font. This leverages the font_google(), font_face() and font_link() functions. In practice, font_google() caches the font resources so that they are always available to the user. Additionally, it gives the flexibility to choose Bootstrap version with version_default(). As shown in Chapter 2, Shiny primarily relies on Bootstrap 3. This function has 3 flavors: Bootstrap 3, with \"3\". Bootstrap 4 + compatibility with Bootstrap 3, with \"4\". Advanced users appreciate a ... slot to add extra variables through bs_add_variables(), with literally hundreds of choices. library(bslib) bs_theme( version = version_default(), bootswatch = NULL, ..., bg = NULL, fg = NULL, primary = NULL, secondary = NULL, success = NULL, info = NULL, warning = NULL, danger = NULL, base_font = NULL, code_font = NULL, heading_font = NULL ) bs_update_theme() is able to update a give theme object, generated with bs_theme(). At any time, developers may preview to resulting theme with bs_theme_preview(), passing the newly created theme as main parameter. For instance: library(shiny) neon_theme &lt;- bs_theme( bg = &quot;#000000&quot;, fg = &quot;#FFFFFF&quot;, primary = &quot;#9600FF&quot;, secondary = &quot;#1900A0&quot;, success = &quot;#38FF12&quot;, info = &quot;#00F5FB&quot;, warning = &quot;#FFF100&quot;, danger = &quot;#FF00E3&quot;, base_font = &quot;Marker Felt&quot;, heading_font = &quot;Marker Felt&quot;, code_font = &quot;Chalkduster&quot; ) bs_theme_preview(neon_theme, with_themer = FALSE) This gives the result shown in Figure 8.1. FIGURE 8.1: bs_theme_preview feature in action Passing with_themer = TRUE will show a live theming tools to modify the current theme. Let’s try with another example. We would like to bring a refreshment to the Bootstrap UI elements with one of the most modern UI kit to date, namely 98.css, a windows 98 CSS kit. The CSS assets may be accessed from jsdelivr, as shown below. {bslib} exposes neat tools to import extra CSS in the current theme, such as bs_add_rules(), which calls sass::sass_file() under the hood: theme %&gt;% bs_add_rules( &#39;@import &quot;https://cdn.jsdelivr.net/npm/98.css@0.1.16/dist/98.min.css&quot;&#39; ) The three theme colors are #c0c0c0 for the background and all colors (except primary), #03158b for primary and #222222 for the text. We also disable the rounded option so that button borders stay squared. windows98_theme &lt;- bs_theme( bg = &quot;#c0c0c0&quot;, fg = &quot;#222222&quot;, primary = &quot;#03158b&quot;, base_font = c(&quot;Times&quot;, &quot;Arial&quot;), secondary = &quot;#c0c0c0&quot;, success = &quot;#c0c0c0&quot;, danger = &quot;#c0c0c0&quot;, info = &quot;#c0c0c0&quot;, light = &quot;#c0c0c0&quot;, dark = &quot;#c0c0c0&quot;, warning = &quot;#c0c0c0&quot;, &quot;font-size-base&quot; = &quot;0.75rem&quot;, &quot;enable-rounded&quot; = FALSE ) %&gt;% bs_add_rules( &#39;@import &quot;https://cdn.jsdelivr.net/npm/98.css@0.1.16/dist/98.min.css&quot;&#39; ) windows98_theme %&gt;% bs_theme_preview() When you run the above demonstration, you’ll notice that the slider input is not properly styled. It’s not surprising since the slider is not shaped by Bootstrap but Ion.RangeSlider. Therefore, if you want a better appearance, like in 98.css, we would need extra work. The output is shown Figure 8.2. FIGURE 8.2: Modern Windows 98 theme for Shiny 8.3 Dynamic theming Now, let’s say you design an app and want to give the choice between the vanilla shiny design and your new cyberpunk theme, created in the previous section. We leverage the new session$setCurrentTheme tool that allows to pass {bslib} generated themes to JavaScript through the session object. Our Shiny app contains a toggle, which value is either TRUE or FALSE. On the JavaScript side, we first create a custom shiny input with Shiny.setInputValue that get the current mode value from the toggle. If TRUE, then the custom theme is applied by session$setCurrentTheme in an observeEvent. As the {bslib} theme does not apply to static plots (they are not HTML element, thus not part of the DOM), we leverage {thematic}, that in short, provides a sort of CSS interface for base R plots, ggplot and lattice. Specifically, in the Shiny context, we choose thematic_shiny(). By default, it sets the appropriate background, foreground and accent colors, like {bslib}. library(thematic) theme_toggle &lt;- function() { div( class = &quot;custom-control custom-switch&quot;, tags$input( id = &quot;custom_mode&quot;, type = &quot;checkbox&quot;, class = &quot;custom-control-input&quot;, onclick = HTML(&quot;Shiny.setInputValue(&#39;dark_mode&#39;, document.getElementById(&#39;custom_mode&#39;).value);&quot;) ), tags$label( &quot;Custom mode?&quot;, `for` = &quot;custom_mode&quot;, class = &quot;custom-control-label&quot; ) ) } default &lt;- bs_theme() ui &lt;- fluidPage( theme = default, theme_toggle(), sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$custom_mode, { session$setCurrentTheme( if (input$custom_mode) neon_theme else default ) }) output$distPlot &lt;- renderPlot({ Sys.sleep(2) hist(rnorm(input$obs)) }) } thematic_shiny() shinyApp(ui, server) Note: An issue with shiny::bindCache described here, with shiny 1.6. 8.4 Custom elements For other elements than core shiny components like numericInput or {thematic} compatible elements such as plotOutput, {bslib} provides tools to create dynamically themeable custom components. Let’s take the example of a simple card where the Sass code is defined below: .supercard has a shadow, takes half of the page width and has a fixed height. Notice the background-color that takes the value of the $primary SAAS variable, inherited from Bootstrap 4. .supercard_body adds padding to the card body content. .supercard { box-shadow: 0 4px 10px 0 rgb(0, 0, 0), 0 4px 20px 0 rgb(0, 0, 0); width: 50%; height: 200px; background-color: $primary; .supercard_body { padding: 0.01em 16px; } } Below, for convenience, we put that Sass code inside a R string, even though best practice would be to save it in a file and compile it with sass::sass_file. sass_str &lt;- &quot; .supercard { box-shadow: 0 4px 10px 0 rgb(0, 0, 0), 0 4px 20px 0 rgb(0, 0, 0); width: 50%; height: 200px; background-color: $primary; .supercard_body { padding: 0.01em 16px; } }&quot; If you try to run sass::sass(input = sass_str), it will fail, as $primary is not defined. Now the goal is to link this custom Sass code to the main app theme, created with bs_theme. We leverage the bs_dependency function where: input refers to a list of Sass rules, that is sass_str in our example. theme is a theme generated with bs_theme. name and version are metadata. In case we are not in a {bslib} context, ie the app does not pass a bs_theme element, we create a fallback containing the card CSS code. library(htmltools) super_card_dependency &lt;- function(theme) { dep_name &lt;- &quot;supercard&quot; dep_version &lt;- &quot;1.0.0&quot; if (is_bs_theme(theme)) { bs_dependency( input = sass_str, theme = theme, name = dep_name, version = dep_version ) } else { htmlDependency( name = dep_name, version = dep_version, src = &quot;supercard-1.0.0/css&quot;, stylesheet = &quot;super-card.css&quot;, package = &quot;OSUICode&quot; ) } } As shown, in Chapter 4, we have to add this dependency to the card tag. Importantly, we wrap it inside bs_dependency_defer that enables us to dynamically update the theme on the server side, each time session$setCurrentTheme is invoked. super_card &lt;- function(...) { div( class = &quot;supercard&quot;, div(class = &quot;supercard_body&quot;, ...), bs_dependency_defer(super_card_dependency) ) } We then create two simple theme, namely white and dark and run the app: white_theme &lt;- bs_theme() dark_theme &lt;- white_theme %&gt;% bs_theme_update(bg = &quot;black&quot;, fg = &quot;white&quot;, primary = &quot;orange&quot;) ui &lt;- fluidPage( theme = white_theme, theme_toggle(), br(), super_card(&quot;Hello World!&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$custom_mode, { session$setCurrentTheme( if (input$custom_mode) dark_theme else white_theme ) }) } shinyApp(ui, server) The reader is invited to exploit the run_with_themer capabilities, that allows to dynamically modify the current them, as shown Figure 8.3. FIGURE 8.3: bs_theme_preview with custom component Below, we try without passing any theme to fluidPage: ui &lt;- fluidPage(super_card(&quot;Hello World!&quot;)) server &lt;- function(input, output) {} shinyApp(ui, server) 8.5 Further resources The reader will refer to the {bslib} various vignettes. References "],["survival-kit-javascript.html", "Chapter 9 JavaScript for Shiny 9.1 Shiny JavaScript sources 9.2 Introduction to JavaScript 9.3 Setup 9.4 Programming with JS: basis 9.5 jQuery 9.6 Shiny, JavaScript and the HTML inspector 9.7 Exercises", " Chapter 9 JavaScript for Shiny To understand how Shiny works from inside, especially how inputs are handled, we’ll gradually dive into its core which contains a substantial amount of JavaScript (JS). This chapter is a very brief introduction to JS and jQuery but still necessary as this book is supposed to be standalone. Advanced JS users may skip this part. MDN web docs by Mozilla is an excellent resource. 9.1 Shiny JavaScript sources Let’s have a look at the {shiny} (Chang et al. 2021) github project. As a R package, it is composed of standard folders like R, man, tests and other elements. The inst folder contains resources for external dependencies like Bootstrap 3, jQuery, datatables, fontawesome, … mentioned in Chapter 2 sorted in the www/shared sub-folder as well as the whole CSS and JS Shiny codes. Notice the presence of minified files like shiny.min.js and non minified elements such as shiny.css. Overall, the minification process reduces the loading time of a web page by removing comments, extra spaces, thereby decreasing the file size. For instance shiny.js has 6628 lines of code, while shiny.min.js has only 4. Notice the srcjs/ folder shown in Figure 9.1. It actually contains all pieces to reconstruct the whole shiny.js file. FIGURE 9.1: Shiny JavaScript sources The _start.js and _end.js are used by the Gruntfile.js, that is a grunt-based tool to run different tasks such as concatenate multiple JavaScript files, lint the code, minify it … See here for a summary. grunt.registerTask(&#39;default&#39;, [ &#39;concat&#39;, &#39;string-replace&#39;, &#39;validateStringReplace&#39;, &#39;eslint&#39;, &#39;configureBabel&#39;, &#39;babel&#39;, &#39;uglify&#39; ]); Since in Chapter (shiny-input-system) we’ll use some of those script, a little understanding of the basic underlying JavaScript concepts is necessary. 9.2 Introduction to JavaScript JavaScript was created in 1995 by Brendan Eich and is also known as ECMAScript (ES). Interestingly, you might have heard about ActionScript, which is no more than an implementation of ES by Adobe Systems. Nowadays, JavaScript is the centerpiece of web development across all websites. Here is a quick example. If you have a personal blog, you probably know Hugo or Jekyll, especially the R interfaces like blogdown (Xie, Dervieux, and Presmanes Hill 2021). These tools allow one to rapidly develop a nice looking blog in just a few minutes, focusing on the content rather than technical aspects, which is really the point! Now, if you open the HTML inspector introduced in Chapter 1.2, click on the elements tab, which may open by default, and uncollapse the &lt;head&gt; tag, you see that a lot of scripts are included, as shown in Figure 9.2. Similarly for the &lt;body&gt; tag. FIGURE 9.2: A website is full of JavaScript There are three ways to include scripts: Use the &lt;script&gt; tag with the JS code inside Add the onclick attribute to an HTML tag (preferably a button) to trigger JS as soon as it is clicked (This is similar to event listeners, see below) Import an external file containing the JS code and only &lt;script type=&quot;text/javascript&quot;&gt; // JS code here &lt;/script&gt; &lt;button id=&quot;hello&quot; onclick=&quot;jsFunction()&quot;&gt;Hello World&lt;/button&gt; &lt;!-- We use the src attribute to link the external file --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;file.js&quot;&gt; Whether to choose the first, second or third method depends on the content of your script. If we consider the JS library jQuery, it unfortunately contains so much code making it a challenge to understand. This often makes users avoid the first method. 9.3 Setup Like R or Python, JavaScript (JS) is an interpreted language. It is executed client-side, in other words in the browser. This also means that JS code may not be run without a suitable tool. In the following, we’ll list some tools to test JS code, even though JS may also be run through the web browser developer tools, as demonstrated in section 9.6. 9.3.1 Node Node contains an interpreter for JS as well as a dependencies manager, npm (Node Package Manager). To install Node on your computer, browse to the website and follow the installation instructions. Afterwards, open a terminal and check if $ which node $ node --version returns something. If not, Node may not be properly installed. If you prefer not installing Node, there exists alternatives like repl.it, offering a Node.js online compiler environment. This will be more than enough to follow the exercises of this part. 9.3.2 Choose a good IDE Personally, I really like VSCode for coding with JS, as it contains a Node interpreter allowing you to seamlessly execute any JS code. As a side note, I encourage you to try the dracula color theme, which is my favorite! As R user, I also like Rstudio IDE, provided that you have Node installed. Below, we will explain how to run a JS code in both IDE’s. In section 9.6, we will show how to manipulate JS code directly in the web browser, through the HTML inspector. This is the method we will mostly use in the remaining of the book since we will also work with HTML and CSS at the same time. 9.3.3 First Script Let’s write our first script: console.log(&quot;Hello World&quot;); You notice that all instruction end by ;. You can run this script either in Rstudio IDE or VSCode. FIGURE 9.3: Run JS in VSCode In VSCode, clicking on the run arrow (top center) of Figure 9.3, triggers the node hello.js command, which tells Node to run the script. We see the result in the right panel (code=0 means the execution is fine and we even have the compute time). To run this script in the RStudio IDE, one needs to click on the terminal tab (you could also open a basic terminal) and type node hello.js (or node mycustompath/hello.js if you are not in the folder containing the script). You should see the Hello World message in the console (see Figure 9.4). FIGURE 9.4: Run JS in a terminal 9.4 Programming with JS: basis We are now all set to introduce the basis of JS. As many languages, JS is made of variables and instructions. All instructions end by the ; symbol. 9.4.1 JS types JS defines several types: Number: does not distinguish between integers and others (in R for instance, numeric contains integers and double) String: characters (‘blabla’) Boolean: true/false To check the type of an element, we may use the typeof operator. typeof 1; // number typeof &#39;pouic&#39;; // string In JS, typeof is not a function like in R!!! Therefore don’t write typeof('string');. 9.4.2 Variables Variables are key elements to programming languages. They allow to store intermediate results and do other manipulations. In JS, a variable is defined by: a type a name a value A valid variable name: Doesn’t use a reserved JS name like typeof! Doesn’t start with a number (123soleil)! Doesn’t include any space (total price)! Besides, code style is a critical element in programming, increasing readability, and general consistence. There are several styles, the main ones being snake_case and camelCase. I personally use the camelCase syntax to write variables in JS. There are two ways to create variables in JavaScript. 9.4.2.1 Const In JavaScript, a variable may be created with const: const n = 1; n = 2; // error const n = 3; // error const a; a = 1; // errors As shown above, such variables: Cannot be modified Cannot share the same name Must be assigned a value 9.4.2.2 let Another way to define a variable: let myVariable = &#39;welcome&#39;; myVariable = 1; console.log(myVariable); Then we may use all mathematical operators to manipulate our variables. let myNumber = 1; // affectation myNumber--; // decrement console.log(myNumber); // print 0 List of numerical operators in JS: + - * / % (modulo) ++ (incrementation) -- (decrementation) To concatenate two strings, we use the+ symbol. You may also know var to declare variables. What is the difference with let? It is mainly a scope reason: var i = 1; { var i = 2; // this will modify i globally, not locally } console.log(`i is ${i}`); // i is 2. let j = 1; { let j = 2; // j is only declared locally and not globally! } console.log(`j is ${j}`); // j is 1 You will see later that we still use var in the shiny core and many other R packages. 9.4.3 Conditions Below are the operators to check conditions. === (A equal value, equal type B) == (A equal to B) !== (A not equal value or not equal type B) != (A not equal to B) &gt;, &gt;= &lt;, &lt;= AND (A AND B) or &amp;&amp; OR (A OR B) or || Importantly, prefer === and !== to compare elements since 5 == \"5\" would return true, generally not what you want! To test conditions there exists several ways: if (condition) { console.log('Test passed'); } if (condition) { instruction A} else { instruction B } The ternary operator is a shortcut condition ? instruction if true : instruction if false that may be chained. For complex instructions, we recommend not using it, as it may affect code readability. Whenever a lot of possible conditions have to be evaluated, it is better to choose the switch. switch (variable) { case val1: // instruction 1 break; // don&#39;t forget the break! case val2: // instruction 2 break; default: // when none of val1 and val2 are satisfied } 9.4.4 Objects JavaScript is an object oriented programming language (like Python). An object is defined by: a type some properties some methods (to manipulate properties) Let’s construct our first object: const me = { name : &#39;Divad&#39;, age : 29, music : &#39;&#39;, printName: function() { console.log(`I am ${this.name}`); } } me.geek = true; // works (see const variables above) console.log(JSON.stringify(me)); // print a human readable object. console.log(me.name); console.log(me.age); console.log(me.music); // don&#39;t repeat yourself!!! for (let key in me) { // here is it ok to use `in` console.log(`me[${key}] is ${me[key]}`); } me.printName(); me = { name: &#39;Paul&#39;, age: 40 } // error (see const variables above) Some comments on the above code: To access an object property, we use object.&lt;propertiy_name&gt;. To print a human readable version of the object, JSON.stringify will do the job. We introduced string interpolation with ${*}. * may be any valid expression. Methods are accessed like properties (we may also pass parameters). We use this to refer to the object itself. Take note, we will see it a lot! In JavaScript, there are already predefined objects to interact with arrays, dates. 9.4.4.1 Arrays An array is a structure allowing to store information for instance: const table = [1, &#39;plop&#39;]; table.push(&#39;hello&#39;); table = [2]; // error (as explain in above in the variable part) console.log(table); Array may be nested: const nested = [1, [&#39;a&#39;, [1, 2, 3]], &#39;plop&#39;]; console.log(nested); In arrays, elements may be accessed by their index, but as mentioned before, the first index is 0 (not 1 like in R). A convenient way to print all array’s elements is to use an iteration: const nested = [1, [&#39;a&#39;, [1, 2, 3]], &#39;plop&#39;]; for (let i of nested) { console.log(i); } // or with the classic approach for (let i = 0; i &lt; nested.length; i++) { console.log(nested[i]); } Note that the length method returns the size of an array and is very convenient in for loops. Below is a table referencing the principal methods for arrays (we will use some of them later). Method/Property Description length Return the number of elements in an array Join(string separator) Transform an array in a string concat(array1, array2) Assemble 2 arrays pop() Remove the last element of an array shift() Remove the first element of an array unshift(el1, el2, …) Insert elements at the beginning of an array push(el1, el2, …) Add extra elements at the end of an array sort() Sort array elements by increasing value of alphabetical order reverse() Symetric of sort() Quite honestly, we mainly use push and length in the next chapters. 9.4.4.2 Strings Below are the main methods related to the String object (character in R). Method/Property/Operator Description + (operator) String concatenation length String length indexOf() Gives the position of the character following the input string toLowerCase() Put the string in small letters toUpperCase() Put the string in capital letters 9.4.4.3 Math Below we mention some useful methods to handle mathematical objects. Method Description parseInt() Convert a string to integer parseFloat() Conversion to floating number All classic functions like sqrt, trigonometric functions are of course available. We call them with the Math.* prefix. 9.4.5 Iterations Iterations allow to repeat an instruction or a set of instructions multiple times. Let’s assume we have an array containing 100000 random numbers. How would you do to automatically print them? This a what we are going to see below! 9.4.5.1 For loops The for loop has multiple uses. Below is a classic case where we start by defining the index (variable). We then set an upper bound (the array length) and we finish by incrementing the index value. The code between curly braces is then executed. const table = [...Array(100).keys()]; // create an empty array of length 100 (so from 0 to 99, not from 1 to 100 like in R!!!) for (let i = 0; i &lt; table.length; i++) { console.log(table[i]); } The way we created the array is a bit special and deserves some explanations: Array is a method to define a new array. We call it this way Array(arrayLength) since we don’t want to write 100 values 1 by 1. But if you try console.log(Array(10)); you will get [ &lt;10 empty items&gt; ], meaning that 10 slots are available but nothing is inside yet. keys defines keys for each table index. As a reminder, since Array(10) is an object (check with console.log(typeof Array(10));) we may use Array(10).keys(). This creates an Array Iterator. ... is a spread syntax, and is called with an iterable object (see above). Contrary to R, JavaScript index starts from 0 (not from 1)! This is good to keep in mind when we will mix both R and JS. Let’s have a look at the forEach method for arrays (introduced in ES5): const letters = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]; letters.forEach((letter) =&gt; { console.log(letter); }); Below is another way to create a for loop (introduced in ES6): const samples = [&#39;blabla&#39;, 1, null]; // this is an array! for (let sample of samples) { console.log(sample); } What for loop should we use? The answer is: it depends on the situation! Actually, there even exists other ways (replace of by in and you get the indexes of the array, like with the first code, but this is really not recommended). 9.4.5.2 Other iterations: while While loops are another way to iterate, as long as the condition defined is TRUE. The incrementation step is done at the end of the instruction. const h = 3; i = 0; while (i &lt;= h) { console.log(i); i++; // we need to increment to avoid infinite loop } 9.4.6 Functions Functions are useful to wrap a succession of instructions to accomplish a given task. Defining functions allows programmers to save time (less copy and paste, less search and replace), make less errors and easily share code. In modern JavaScript (ES6), functions are defined as follows: const a = 1; const fun = (parm1, parm2) =&gt; { console.log(a); let p = 3; return Math.max(parm1, parm2); // I use the Math object that contains the max method } let res = fun(1, 2); console.log(res); // prints a and 2. a global console.log(p); // fails because p was defined inside the function This above functions computes the maximum of 2 provided numbers. Some comments about scoping rules: variables defined inside the function are available for the function, but are not available outside the function definition. It should be noted that functions may use global variables defined outside of it. 9.4.6.1 Export functions: about modules What happens if you wrote 100 functions that you want to reuse in different scripts? To prevent copying and pasting, we will now introduce the concept of modules. Let’s save the below function in a script utils.js: const findMax = (parm1, parm2) =&gt; { return Math.max(parm1, parm2); // I use the Math object that contains the max method } module.exports = { findMax : findMax } We create a test.js script in the same folder that calls the findMax function. To do this, we import the corresponding module: const {findMax} = require(&#39;./utils.js&#39;); findMax(1, 2); // prints 2 9.4.7 Event listeners When you explore a web application, clicking on a button usually triggers something like a computation, a modal or an alert. How does this work? In JavaScript, interactivity plays a critical role. Indeed, you want the web application to react to user inputs like mouse clicks or keyboard events. Below we introduce DOM events. Let’s consider a basic HTML button. &lt;button id=&quot;mybutton&quot;&gt;Go!&lt;/button&gt; On the JavaScript side, we first capture the button element using its id selector (getElementById). const btn = document.getElementById(&#39;mybutton&#39;); We then apply the addEventListener method. In short, an event listener is a program that triggers when a given event occurs (we can add multiple event listeners per HTML element). It takes 2 main parameters: the event: click, change, mouseover, … the function to call btn.addEventListener(&#39;click&#39;, function() { alert(&#39;Thanks!&#39;); }); We could compare the JavaScript events to Shiny observeEvent in which we are listening to a specific user input: observeEvent(trigger, { # instructions }) 9.5 jQuery 9.5.1 Introduction jQuery is a famous JavaScript library providing a user friendly interface to manipulate the DOM and is present in almost all actual websites. It is slightly easier (understand more convenient to use) than vanilla JS, even though web developers tend to avoid it to go back to vanilla JS (Bootstrap 5, the next iteration of Bootstrap will not rely on jQuery anymore). To use jQuery in a web page, we must include its code either by downloading the code and putting the minified JS file in our HTML or setting a link to a CDN: &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Including jQuery&lt;/title&gt; &lt;!-- How to include jQuery --&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;script&gt; $(&#39;p&#39;).css(&#39;color&#39;, &#39;red&#39;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 9.5.2 Syntax Below is a minimal jQuery code representing its philosophy (“write less, do more.”): $(selector).action(); The selector slot stands for any jQuery selector like class, id, element, [attribute], :input (will select all input elements) and many more. As a reminder, let’s consider the following example: &lt;p class=&quot;text&quot;&gt;Hello World&lt;/p&gt; To select and interact with this element, we use JavaScript and jQuery: let inner = document.getElementsByClassName(&#39;text&#39;).innerHTML; // vanilla JS let inner = $(&#39;.text&#39;).html(); // jQuery This is of course possible to chain selectors: &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot; id=&quot;precious-item&quot;&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;list&quot; id=&quot;list2&quot;&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;4&lt;/li&gt; &lt;/ul&gt; let items = $(&#39;.list .item&#39;); // will return an array containing 8 li tags let otherItems = $(&#39;#list2 .item&#39;); // will select only li tags from the second ul element let lists = $(&#39;ul&#39;); // will return an array with 2 ul elements let firstItem = $(&#39;#list2:first-child&#39;); // will return the first li element of the second ul. 9.5.3 Useful functions There exist filtering functions dedicated to simplify item selection. Below are is a list containing the mostly used in Shiny. 9.5.3.1 Travel in the DOM Method Description children() Get the children of each element passed in the selector (important: only travels a single level down the DOM tree) first() Given an list of elements, select the first item last() Given an list of elements, select the last item find() Look for a descendant of the selected element(s) that could be multiple levels down in the DOM closest() Returns the first ancestor matching the condition (travels up in the DOM) filter() Fine tune element selection by applying a filter. Only return element for which the condition is true siblings() Get all siblings of the selected element(s) next() Get the immediately following sibling prev() Get the immediately preceding sibling not() Given an existing set of selected elements, remove element(s) that match the given condition 9.5.3.2 Manipulate tags Below is a list of the main jQuery methods to manipulate tags (adding class, css property…) Method Description addClass() Add class or multiple classes to the set of matched elements hasClass() Check if the matched element(s) have a given class removeClass() Remove class or multiple classes to the set of matched elements attr() Get or set the value of a specific attribute after() Insert content after before () Insert content before css() Get or set a css property remove() Remove element(s) from the DOM val() Get the current value of the matched element(s) TO DO: add more methods 9.5.4 Chaining jQuery methods A lot of jQuery methods may be chained, that is like pipe operations in R. &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;/ul&gt; We end the chain by ; and each step is indented by 2 spaces in the right direction: $(&#39;ul&#39;) .first() .css(&#39;color&#39;, &#39;green&#39;) // add some style with css .attr(&#39;id&#39;, &#39;myAwesomeItem&#39;) // add an id attribute .addClass(&#39;amazing-ul&#39;); 9.5.5 Iterations Like in vanilla JavaScript, it is possible to do iterations in jQuery. Let’s consider the following HTML elements: &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt; We apply the each method to change the style of each matched element step by step: $(&#39;li&#39;).each(function() { $(this).css(&#39;visibility&#39;, &#39;hidden&#39;); // will hide all li items }); Notice that the following code $('li').css('visibility', 'hidden'); will do exactly the same! This is explained by the implicit iteration process handled by most of jQuery methods. The map methods has a different purpose. It creates a new object based on the provided one. const items = [0, 1, 2, 3, 4, 5]; const threshold = 3; let filteredItems = $.map(items, function(i) { // removes all items &gt; threshold if (i &gt; threshold) return null; return i; }); 9.5.6 Good practice It is recommended to wrap any jQuery code as follows: $(document).ready(function(){ // your code }); // or a shortcut $(function() { // your code }); Indeed, do you guess what would happen if you try to modify an element that does not even exist? The code above will make sure that the document is ready before starting any jQuery manipulation. 9.5.7 Events In jQuery there exists a significant number methods related to events. Below are the most popular: $(element).click(); // click event $(element).change(); // trigger change on an element $(element).on(&#39;click&#39;, function() { // whatever }); // attach an event handler function. Here we add click for the example $(element).one(&#39;click&#39;, function() { // whatever }); // the difference with on is that one will trigger only once $(element).resize(); // useful to trigger plot resize in Shiny so that they correctly fit their container $(element).trigger(&#39;change&#39;) // similar to $(element).change(); You will find it in the Shiny core. The .on event is frequently used in Shiny since it allows to pass custom events which are not part of the JS predefined events. For instance {shinydashboard} (Chang and Borges Ribeiro 2018) relies on a specific HTML/JavaScript/CSS template including a homemade API for handling the dashboard events. Don’t worry if this section is not clear at the moment. We will see practical examples in the following chapters. 9.5.8 Extending objects A last feature we need to mention about jQuery is the ability to extend objects with additional properties and/or method. // jQuery way $(function() { let object1 = { apple: 0 }; $.extend(object1, { print: function() { console.log(this); } }); object1.print(); }); With vanilla JS we would use Object.defineProperty: // pure JavaScript Object.defineProperty(object1, &#39;print&#39;, { value: function() { console.log(this); }, writable: false }); 9.6 Shiny, JavaScript and the HTML inspector In the above part we gave some elementary JS knowledge. This section comes back to the main point of this book, that is Shiny. We describe how to leverage the developer tools so as to test,run and debug JavaScript code related to a Shiny app. 9.6.1 The console panel While developing JS code, we often put some console.log(var) calls to track the content of a given variable and check that our code is doing what it is supposed to do. The resulting messages, errors or warnings are printing in the console, also called a Read-eval-print loop (REPL) suitable to experiment and practice your new JS/jQuery skills. 9.6.1.1 A real REPL As a warm up, run the shiny app below and open the Chrome DevTools. Notice the 2 Console tabs (next to Elements and at the bottom), as depicted in Figure 9.5. I prefer using the bottom one to still see the Elements tab and preview DOM modifications in real time. ui &lt;- fluidPage() server &lt;- function(input, output, session) {} shinyApp(ui, server) FIGURE 9.5: Console panel in the DevTools Interestingly, you may access any element contained in the window. Copy and paste $(\"body\").addClass(\"plop\"); in the prompt. Notice what happens in the Elements tab. 9.6.1.2 Track errors and warnings As discussed earlier in the book, a lot of Shiny app issues on Stack Overflow or in the RStudio community could be more easily solved by quickly inspecting the console. 9.6.2 Debug Shiny/JS code with the inspector To debug Shiny apps from the inspector, you all your scripts have to be in a folder accessible by the app like the www/ folder or by using shiny::addResourcePath. Moreover, if you have minified files, there must be source maps, which will allow to reconstruct the original scripts, that is as they were before the minification process. For instance, Shiny has the shiny.min.js.map. In practice, most R packages bundling HTML templates do not ship these files since they could be quite large (see package size restriction for CRAN). The framework7 HTML template, on top of which is built {shinyMobile} [R-shinyMobile] has source maps but the size can reach 5MB which is obviously too big to include in the R package. In the following, we consider a very simple shiny app deployed on shinyapps.io, where a notification is displayed with JavaScript as soon as a user clicks an action button. I also made some typos in my code and the goal is to find and fix them. Browse to the app Open the Chrome DevTools Click on the action button (I am pretty sure you clicked before step 2 ;)) As expected and shown Figure 9.6, the console displays an error message: Uncaught TypeError: Cannot read property 'show' of undefined. Sounds good isn’t it? FIGURE 9.6: Error in the console panel Expand the error message to show the stack trace. We see that the error occurred during an onclick event calling the sendNotif function. Interestingly, we can open this file by clicking on the provided link (notif.js:2). You should get a layout similar to Figure 9.7, depending on your screen width. FIGURE 9.7: Inspect the source causing the error Let’s briefly describe Figure 9.7. On the left side, you can navigate through all files accessible by the web server, that is shiny internal resources, shiny external dependencies (like Bootstrap 3) as well as your own scripts. If the app is deployed on shinyapps.io, all scripts are located in a folder starting by _w_, which corresponds to the shinyapps.io workerId (this is a detail and not important to understand. See more here). The central part contains any opened script like a classic IDE. The right side displays debugging tools which you may trigger by clicking on the corresponding accordion. The scope shows all variables/object values at a break point, watch allows to track specific elements and Event listener Breakpoints allows to stop at given listener type. We could create a new “watcher” by entering typeof message and clicking the add icon to check the message type within the sendNotif function. Watched expressions are saved when you close the browser. Put a break point line 2 by clicking on the left side of the center panel and click again on the action button to trigger the break point. I also additionally set 2 Watch Expressions (for message and duration) which type is string and number, respectively, as depicted on Figure 9.8. According to the results, nothing seems wrong for the function arguments. FIGURE 9.8: Inspection of the scope at the breakpoint The error message Uncaught TypeError: Cannot read property 'show' of undefined actually means that notification does not exist. Try yourself by typing Shiny.notification in the console. You’ll get undefined. Instead, the console suggests Shiny.notifications. Let’s replace the wrong code in the notif.js script and then save it. Click on the “Resume script execution” blue button (top left of the right panel). Notice that a notification is displayed and no more error is thrown. Congrats! You’ve just debugged your first shiny app from the web inspector. In practice, your code is probably much more complex than this example but the workflow remains the same. 9.7 Exercises Because the JavaScript console is a REPL, all JavaScript exercises may be done inside, except exercise 3 which also involves HTML. In that case, the reader may browse to jsfiddle. 9.7.1 Exercise 1: define variables Play with the example below let myNumber = 1; // affectation myNumber--; // decrement console.log(myNumber); // print 0 9.7.2 Exercise 2: define objects Below is an object skeleton. const me = { name : , age : , music : , printName: function() { console.log(`I am ${}`); } } Fill it with some random values. Access the name property. Create the printAge method, which returns the age. Hint: this refers to the object itself. For instance this.name gives the name property. 9.7.3 Exercise 3: jQuery JSFiddle allows to insert HTML, CSS and JavaScript to test code, share and more. It also does not require you to have any specific configuration on your machine so that you focus on testing! Go to JSFiddle Insert the following HTML code chunk in the HTML sub-window. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; This is a very basic HTML skeleton In the JavaScript windows, select jQuery 3.4.1 in the dropdown menu (why 3.4.1? The latest Shiny release relies on that version. It is therefore best practice to ensure dependencies are similar, at least the major version). Since it is best practice to run jQuery code only when the document is ready (avoiding to target non existing elements), we wrap our JS code in the following: $(function() { // your code }); // or a more explicit syntax $(document).ready(function() { // code }); Create an event listener to change the third item color as soon as one click on it. Hint 1: To select the a specific item you may use $(selector:eq(i)) where i is the index of the element. Keep in mind that JavaScript starts from 0 and not 1 like R! Hint 2: as a reminder, to create an event listener in jQuery, we use the following pattern. $(&quot;selector&quot;).on(&quot;event_name&quot;, function(e) { // your logic }); 9.7.4 Exercise 4: a pure JS action button Below is another example of a button element with an attached event listener. Clicking on the button will increment its value by 1. Fill in the blanks! &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;click&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; $(function() { // recover the button inner html const btnText = ...; // event listener for button element $(...).click(function() { var val = ...; // (1) increment button // (2) add the button value to the inner text ... // show alert given condition if (val &gt; 3) { // do whatever you want ... } }); }); References "],["shiny-intro.html", "Chapter 10 Shiny’s internal: session and websockets 10.1 The Shiny JavaScript object 10.2 Websocket: R/JS bidirectional communication", " Chapter 10 Shiny’s internal: session and websockets In this chapter, we will answer to the following question: How is the R/JavaScript communication achieved? At this point, users may find options(shiny.minified = FALSE) to debug the Shiny.js core. 10.1 The Shiny JavaScript object The Shiny object is exported at the top of the shiny.js file.3 In other words, this means that we may use this object and any of its properties within the HTML inspector console tab, in any JavaScript file or shiny app as below: ui &lt;- fluidPage( tags$script( &quot;$(function() { console.log(Shiny); }); &quot; ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) This object contains many properties and methods as shown in Figure 10.1. Some of particular interest, such as like Shiny.setInputValue, Shiny.addCustomMessageHandler, Shiny.shinyapps, Shiny.bindAll, … will be detailed later. FIGURE 10.1: The Shiny JavaScript object 10.2 Websocket: R/JS bidirectional communication How does R (server) and JavaScript (client) communicate? This is a built-in Shiny feature highlighted here, which leverages the httpuv package. 10.2.1 What is a websocket? Before going further let’s define what is a websocket. It is an advanced technology allowing bidirectional communication between a (or multiple) client(s) and a server. For instance, a chat system may be built on top of a websocket.4 The server is generally created using Node.js libraries like ws and the client with JavaScript. In the R context, the server is created from {httpuv} (Cheng and Chang 2021) and the client either with {websocket} (Chang et al. 2020) (see below) or directly from JavaScript, as described later: library(httpuv) # set the server s &lt;- startServer(&quot;127.0.0.1&quot;, 8080, list( onWSOpen = function(ws) { # The ws object is a WebSocket object cat(&quot;Server connection opened.\\n&quot;) ws$onMessage(function(binary, message) { cat(&quot;Server received message:&quot;, message, &quot;\\n&quot;) ws$send(&quot;Hello client!&quot;) }) ws$onClose(function() { cat(&quot;Server connection closed.\\n&quot;) }) } ) ) On the server side, startServer expects a host, port and an app. In the case of websockets, app is a list containing the onWSOpen function defining all actions to perform after the connection is established. Those actions are defined in the {httpuv} WebSocket R6 class: onMessage is invoked whenever a message is received on this connection. onClose is invoked when the connection is closed. send sends a message from the server (to the client). On the client, we may use the {websocket} WebSocket class provided by the websocket package. As soon as the new socket instance is created, the server onWSOpen function is called which displays the welcome message. Then a message is sent from the client, received on the server and sent back to the client. library(websocket) # set the client ws &lt;- websocket::WebSocket$new(&quot;ws://127.0.0.1:8080/&quot;) ws$onMessage(function(event) { cat(&quot;Client received message:&quot;, event$data, &quot;\\n&quot;) }) # Wait for a moment before running next line ws$send(&quot;Hello server!&quot;) # Close client ws$close() However, Shiny does not use {websocket}! As mentioned earlier, the client is be built directly from JS as below: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;script language=&quot;javascript&quot;&gt; // displays an alert var mySocket = new WebSocket(&quot;ws://127.0.0.1:8080&quot;); mySocket.onopen = function (event) { // exampleSocket.send(&quot;Client connected!&quot;); }; mySocket.onmessage = function (event) { console.log(event.data); }; &lt;/script&gt; &lt;title&gt;Websocket Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- onclick attributes applies the JavaScript function changeColor define above --&gt; &lt;button onclick=&quot;mySocket.send(&#39;Hello server!&#39;)&quot;&gt;Say hello to the server&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; host and port must be identical on both server and client side! If you open this file in a web browser, clicking on the button will send a message to the server, as shown on Figure 10.2. FIGURE 10.2: Server client communication The reader must understand that when Shiny inputs/outputs are modified on the client by an end user, there are a lot of exchanges between R and JS, through the websocket. In the following, we briefly describe how Shiny leverages this technology, on both server and client side. 10.2.2 Shiny app life-cycle Let’s first try to reconstruct the life cycle of a Shiny app. What really happens when one browse to a shiny app url? Shiny Apps are usually hosted on environments running different versions of shiny server: Shiny server open source. Shiny server pro. RStudio Connect. shinyapps.io. Whenever a user (client) accesses a shiny app with his web browser, a series of events occurs (Figure 10.3): The client sends a HTTP CONNECT request to the server (Shiny server). The server starts the targeted app with runApp. Under the hood, the latter does: Call shinyApp that returns a shiny app object composed of a server function and the UI. uiHttpHandler is responsible for adding all internal shiny dependencies like json2, jQuery and shiny css/javascript files to the provided piece of UI, as discussed in chapter 2. Call startApp that creates HTTP and websocket (WS) handlers. WS handlers are responsible for controlling the WS behavior when the app starts, when a message is received from a client and when the app closes. It also creates static path containing all CSS, JS files that may be accessed by the browser. Call startServer from {httpuv}, that starts the HTTP server and opens the server websocket connection. If the R code does not contain errors, the server returns the Shiny UI HTML code to the client, which is displayed in the web browser. The returned HTML contains all the necessary JavaScript to subsequently open the client websocket connection. FIGURE 10.3: Shiny App lifecycle From there, client and server are free to exchange information. In the following part, we provide details on both server and client websocket connection. 10.2.3 The Shiny session object We won’t be able to go anywhere without giving some reminders about the Shiny session object. Why do we say object? session is actually an instance of the ShinySession R6 class. Importantly, the session is unique to a given user. It means that 2 different clients cannot share the same session. This is important since it contains all information about input, output, client data… Upon calling ShinySession$new(), the initialization method takes one parameter, namely the websocket. As shown in the last section, the websocket allows bidirectional exchanges between R and JS. The session object exposes two methods to communicate with JavaScript: sendCustomMessage sends messages from R to JS. It calls the private sendMessage method which itself calls write. The message is sent only when the session is opened, through the websocket private$websocket$send(json). If the shiny.trace option is TRUE, a message showing the sent JSON is displayed, which is useful for debugging. sendInputMessage is used to update inputs from the server. The message is stored in a message queue and ultimately sent through the websocket private$websocket$send(json). The below code is extracted from the shiny.R file. sendCustomMessage = function(type, message) { data &lt;- list() data[[type]] &lt;- message private$sendMessage(custom = data) } sendInputMessage = function(inputId, message) { data &lt;- list(id = inputId, message = message) # Add to input message queue private$inputMessageQueue[[length(private$inputMessageQueue) + 1]] &lt;- data # Needed so that Shiny knows to actually flush the input message queue self$requestFlush() } sendMessage = function(...) { # This function is a wrapper for $write msg &lt;- list(...) if (anyUnnamed(msg)) { stop(&quot;All arguments to sendMessage must be named.&quot;) } private$write(toJSON(msg)) } write = function(json) { if (self$closed){ return() } traceOption &lt;- getOption(&#39;shiny.trace&#39;, FALSE) if (isTRUE(traceOption) || traceOption == &quot;send&quot;) message(&#39;SEND &#39;, gsub(&#39;(?m)base64,[a-zA-Z0-9+/=]+&#39;,&#39;[base64 data]&#39;,json,perl=TRUE)) private$websocket$send(json) } # ... No worry if it is not clear at the moment. We will discuss those elements in the following sections. 10.2.4 Shiny and websocket 10.2.4.1 Server websocket On the server, that is R, a websocket is initiated in the startApp function, leveraging the {httpuv} package. Websocket handlers are defined by createAppHandlers: ws = function(ws) { # many things shinysession &lt;- ShinySession$new(ws) ws$onMessage(function(binary, msg) { # If unhandled errors occur, make sure they get properly logged withLogErrors(messageHandler(binary, msg)) }) ws$onClose(function() { shinysession$wsClosed() appsByToken$remove(shinysession$token) appsNeedingFlush$remove(shinysession$token) }) return(TRUE) } Overall, they drive the server websocket behavior. When the Shiny session is initialized, a message is sent through the WS, providing the sessionId, workerId and user to the client (see Shiny.shinyapp.config and section 10.1): private$sendMessage( config = list( workerId = workerId(), sessionId = self$token, user = self$user ) ) ws$onMessage describes what should happen when the server receives an message from the client. It applies the messageHandler function that, in short, does: Decode the received message. Process the message. At initialization, the client send a message with an init method tag, which tells Shiny to manage input (manageInputs(msg$data, now = TRUE)) before running any observer (since input don’t have value yet). After initialization, client messages have the update tag, meaning that we wait for observers to run before. Finally, when the server connection is closed, all client connections are also closed. All those handlers are applied by handlerManager$addWSHandler(appHandlers$ws, \"/\", tail = TRUE): # see middleware.R httpuvApp &lt;- handlerManager$createHttpuvApp() onWSOpen = function(ws) { return(wsHandlers$invoke(ws)) } addWSHandler = function(wsHandler, key, tail = FALSE) { wsHandlers$add(wsHandler, key, tail) } Note that the R option options(shiny.trace = TRUE) allows the websocket messages to be displayed directly in the R console. 10.2.4.2 Websocket client side On the JS side, the socket creation occurs in the shinyapps.js file: var ws = new WebSocket(protocol + &#39;//&#39; + window.location.host + defaultPath); through the WebSocket object. protocol is the chosen protocol (either ws or wss if using https). window.location.host contains the host name and its port. Once the connection is opened, events are handled with the onopen event registry: socket.onopen = function() { hasOpened = true; $(document).trigger({ type: &#39;shiny:connected&#39;, socket: socket }); self.onConnected(); // remove overlay socket.send(JSON.stringify({ method: &#39;init&#39;, data: self.$initialInput })); while (self.$pendingMessages.length) { var msg = self.$pendingMessages.shift(); socket.send(msg); } } The shiny:connected event is triggered, any disconnected overlay (the famous grayed out screen) is then removed from the DOM. Initial input values are sent to the server via the send method. The onmessage registry aims at handling messages received from the server: socket.onmessage = function(e) { self.dispatchMessage(e.data); }; It subsequently invokes the dispatchMessage method that sends message to all handlers (through _sendMessagesToHandlers), triggering the shiny:message event. Shiny has internal and custom provided handlers (understand user-defined) stored in separate arrays. Each time, a message type matches a given handler, it is treated. For instance, there is a dedicated internal handler for input messages, that bridges the gap between a given input and the corresponding input binding. This handler eventually triggers the inputBinding.receiveMessage method so that the input value is updated on the client. We discuss this in detail in the following section 12.2. Finally the onclose method is called when the websocket connection is closed. socket.onclose = function() { // These things are needed only if we&#39;ve successfully opened the // websocket. if (hasOpened) { $(document).trigger({ type: &#39;shiny:disconnected&#39;, socket: socket }); self.$notifyDisconnected(); } self.onDisconnected(); // Must be run before self.$removeSocket() self.$removeSocket(); } If the connection was opened, the shiny:disconnected event is triggered. Then, the disconnect overlay is added to the DOM (grayed out screen) and the socket is removed. Should any error occurs in the R code, the server sends the error through the websocket, which is captured by the client and displayed. 10.2.5 Example In the following, we will show how to inspect the websocket exchanges in a web browser. Let’s run the following app (see 10.4, left panel): library(shiny) shinyApp( ui = fluidPage( selectInput(&quot;variable&quot;, &quot;Variable:&quot;, c(&quot;Cylinders&quot; = &quot;cyl&quot;, &quot;Transmission&quot; = &quot;am&quot;, &quot;Gears&quot; = &quot;gear&quot;)), tableOutput(&quot;data&quot;) ), server = function(input, output) { output$data &lt;- renderTable({ mtcars[, c(&quot;mpg&quot;, input$variable), drop = FALSE] }, rownames = TRUE) } ) After opening the HTML inspector, we select the network tab and search for websocket in the list. By choosing the message tab, you may inspect what R and JavaScript say to each others. As stated above, the first message sent contains initial input values. Then Shiny recalculates the table, notify when the recalculation is done and becomes idle. The second message received from R is after updating the select input, which triggers the same event cycle. Although complex, it is extremely useful to check whether the input / output communication is working properly. If not, we would see the error field identifying the issue. Shiny.shinyapp.$socket.readyState returns the state of the socket connection. It should be 1 if your app is running. In some instances when the socket is closed, an error would be raised. FIGURE 10.4: Shiny websocket We see below that we can even bypass the UI element and update the input value directly via the websocket using Shiny.shinyapp.$sendMsg with the update method. This is captured on the server side which triggers the output recalculation. We’ll discuss more about this in the next section 11. updateObsVal &lt;- function(value) { sprintf( &quot;Shiny.shinyapp.$sendMsg(JSON.stringify({ method: &#39;update&#39;, data: {obs: %s} }));&quot;, value ) } # below we shunt the slider input by sending message # directly through the websocket ui &lt;- fluidPage( tags$button( &quot;Update obs value&quot;, onclick = updateObsVal(4) ), sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) 10.2.6 Recap Below is a summary of the server and client websocket parts. The Shiny app shown in Figure 10.5 consists in an actionButton and a sliderInput. Clicking on the action button triggers an observeEvent that fires updateSlideInput. Under the hood, clicking on the action button sends a message from the client to the server. This message is processed and the corresponding input value is updated on the server, thereby invalidating any observer, reactive element. updateSlideInput sends a message back to the client containing the id of the input to update. This message is received and processed by the onMessage event manager, which redirects the message to the related message handler, thereby updating the corresponding input element on the client. The underlying mechanisms are going to be detailed in the next part 11. You may imagine that when the slider is updated, it also sends a message to the server, triggering a cascade of reactions. It let you imagine how many messages are exchanged for more complex apps! FIGURE 10.5: Websocket allows communication between server and client. References "],["shiny-input-system.html", "Chapter 11 Shiny’s input system 11.1 Input bindings 11.2 Secondary inputs 11.3 Utilities to quickly define new inputs 11.4 Custom data format", " Chapter 11 Shiny’s input system Shiny inputs are key elements of Shiny apps since they are a way for the end-user to interact with the app. You may know sliderInput, numericInput, checkboxInput but sometimes you may need fancier elements like knobInput from shinyWidgets, as depicted on Figure 11.1 or even more sophisticated inputs like the smartSelect of shinyMobile (Figure 11.1, right panel). Have you ever wondered what are the mechanisms behind inputs? Have you ever dreamt to develop your own? The goal of this section is to understand how Shiny inputs work and how to create new ones. FIGURE 11.1: Custom shiny inputs. left: knobInput from shinyWidgets; right: smart select from shinyMobile 11.1 Input bindings When we run our app, most of the time it works just fine! The question is, how are the inputs (and outputs) handled to allow this to happen? Upon initialization, Shiny runs several JavaScript functions. Some are accessible to the programmer (see a usecase here). To illustrate what they do, let’s run the app below. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) We then open the HTML inspector and run Shiny.unbindAll(document) (document is the scope, that is where to search). Try to change the slider input. You will notice that nothing happens. Now let’s type Shiny.bindAll(document) and update the slider value. Moving the slider successfully update the plot. Magic isn’t it? This simply shows that when inputs are not bound, nothing happens so binding inputs is necessary. We consider another example with multiple inputs. ui &lt;- fluidPage( actionButton(&quot;unbind&quot;, &quot;Unbind inputs&quot;, onclick = &quot;Shiny.unbindAll();&quot;), actionButton(&quot;bind&quot;, &quot;Bind inputs&quot;, onclick = &quot;Shiny.bindAll();&quot;), lapply(1:3, function(i) { textInput(paste0(&quot;text_&quot;, i), paste(&quot;Text&quot;, i)) }), lapply(1:3, function(i) { uiOutput(paste0(&quot;val_&quot;, i)) }) ) server &lt;- function(input, output, session) { lapply(1:3, function(i) { output[[paste0(&quot;val_&quot;, i)]] &lt;- renderPrint(input[[paste0(&quot;text_&quot;, i)]]) }) } shinyApp(ui, server) Let’s see below what is an input binding and how it works. 11.1.1 Input structure An input element is given by the &lt;input&gt; tag as well as several attributes. &lt;input id = inputId type = &quot;text&quot; class = &quot;input-text&quot; value = value&gt; id guarantees the input uniqueness and a way for shiny to recover it in the input$&lt;id&gt; element. type like checkbox, button, text …type may also be a good target for the input binding find method, as explained below. class may be required to find the element in the DOM. It is more convenient for an input binding to target a class (and all associated elements) rather than an id which corresponds to one element by definition. It is also used by CSS to apply styles. value holds the input value. 11.1.2 Binding Shiny inputs An input binding allows Shiny to identify each instance of a given input and what you may do with this input. For instance, a slider input must update whenever the range is dragged or when the left and right arrows of the keyboard are pressed. It relies on a class defined in the input_binding.js file. Let’s describe each method chronologically. For better convenience, the book side package contains step by step demonstrations which may be found here. Each example is called by the customTextInputExample, which takes the input binding step as only parameter. For instance customTextInputExample(1) will invoke the first step. 11.1.2.1 Find the input The first step, is critical which is to locate the input in the DOM. On the R side, we define an input, with a specific attribute that will serve as a receptor for the binding. For most of inputs, this may be handled by the type attribute. In other cases, this may be the class, like for the actionButton. On the JS side, we need a method that will identify this receptor. Moreover, two different types of inputs (for instance radioButton and selectInput) cannot have the same receptor for conflict reasons, whereas two instances of the same input type can. If your app contains 10 sliders, they all share the same input binding, and this is where the thing is powerful since they are all bound in one step. The receptor identifier is provided by the find method of the InputBinding class. This method must be applied on a scope, that is the document. find accepts any valid jQuery selector. Note the console.log only here for debugging purpose. find: function(scope) { console.log($(scope).find(&#39;.input-text&#39;)); return $(scope).find(&#39;.input-text&#39;); } Figure 11.2 summarizes this important step. FIGURE 11.2: How to find inputs? Below, we are going to create a new binding for the textInput, with only two methods mentioned in the previous section, that is find and getValue. For that, we need to create a customized text input, customTextInput to make it unique. We now add the input-text class and make our own input binding pointing to that specific class. customTextInput &lt;- function (inputId, label, value = &quot;&quot;, width = NULL, placeholder = NULL) { # this external wrapper ensure to control the input width div( class = &quot;form-group shiny-input-container&quot;, style = if (!is.null(width)) { paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;) }, # input label shinyInputLabel(inputId, label), # input element + JS dependencies tagList( customTextInputDeps(), tags$input( id = inputId, type = &quot;text&quot;, class = &quot;form-control input-text&quot;, value = value, placeholder = placeholder ) ) ) } The last part of the code contains a tagList with two elements: The element input binding The input tag Below is an example of how we managed the dependency creation in our side package. Considering multiple inputs, we will add more script to the dependency by passing a vector to the script parameter. customTextInputDeps &lt;- function() { htmlDependency( name = &quot;customTextBindings&quot;, version = &quot;1.0.0&quot;, src = c(file = system.file(&quot;chapter5/input-bindings&quot;, package = &quot;OSUICode&quot;)), script = &quot;customTextInputBinding.js&quot; ) } In the shinyMobile package, we chose a more robust approach. All bindings are contained in a folder and compressed so that we generate only one minified file containing all collapsed bindings. Figure 11.3 shows the main elements of the textInput widget. In the above code, shinyInputLabel is a Shiny internal function that creates the numeric input label, or in other word the text displayed next to it. The core input element is wrapped by tags$input. No worry if the structure seems unclear, we will give more details about shiny tags in the Chapter 3. FIGURE 11.3: Shiny’s textInput elements We invite the reader to run the full working demonstration with customTextInputExample(1). In short this example consists in a simple text input and an output showing the current text input value: customTextInputExample &lt;- function(binding_step) { ui &lt;- fluidPage( customTextInput( inputId = &quot;caption&quot;, label = &quot;Caption&quot;, value = &quot;Data Summary&quot;, binding_step = binding_step ), textOutput(&quot;custom_text&quot;) ) server &lt;- function(input, output) { output$custom_text &lt;- renderText(input$caption) } shinyApp(ui, server) } We open the developer tools to inspect the customTextInputBinding.js script, put a breakpoints in the find method and reload the page. Upon reload, the JavaScript debugger opens, as shown Figure 11.4. Type $(scope).find('.input-text') in the console and see what is displayed. This is the DOM element which you may highlight when you hover over the JavaScript output. Building input bindings like this significantly ease the debugging process and you’ll get more chances to be successful! FIGURE 11.4: Find is the first method triggered Now, let’s see why it is better to target elements by type or class. We run the customTextInputExampleBis() example. This is a demonstration app containing two text inputs. Moreover, the binding has been modified so that it looks for element having a specific id: find: function(scope) { return $(scope).find(&#39;#mytextInput&#39;); } If you repeat the above debugging steps, $(scope).find('.input-text') only targets the first text input, meaning that the second input will not be found and bound, as demonstrated in Figure 11.5. FIGURE 11.5: Find by id is a rather bad idea As a side note, you’ll also get an error in the binding (Uncaught Not implemented), indicating that the getValue method is not implemented yet. Fear not! We are going to add it very soon. 11.1.2.2 Initialize inputs Upon initialization, Shiny calls the initializeInputs function that takes all input bindings and call their initialize method before binding all inputs. Note that once an input has been initialized, it has a _shiny_initialized tag to avoid initializing it twice. The initialize method is not always defined but some elements require to be explicitly initialized or activated. For instance the Framework7 API, on top of which shinyMobile is built, require to instantiate all elements. Below is an example for the toggle input: // what is expected let toggle = app.toggle.create({ el: &#39;.toggle&#39;, on: { change: function () { console.log(&#39;Toggle changed&#39;) } } }); el: '.toggle' means that we are looking at the element(s) having the toggle class. app.toggle.create is internal to the Framework7 API. The corresponding shinyMobile input binding starts as follows: var f7ToggleBinding = new Shiny.InputBinding(); $.extend(f7ToggleBinding, { initialize: function(el) { app.toggle.create({el: el}); }, // other methods }); Once initialized, we may use all specific methods provided by the API. Framework7 is clearly a gold mine, as its API provides many possible options for many inputs / widgets. We provide more examples in Chapters 24 and 26. 11.1.2.3 Get the value getValue(el) returns the input value. The way to obtain the value is different for almost all inputs. For instance, the textInput is pretty simple since the value is located in the value attribute. el refers to the element holding the id attribute and recognized by the find method. Figure 11.6 shows the result of a console.log($(el));. FIGURE 11.6: About el getValue: function(el) { console.log($(el)); return $(el).val(); } To get the value, we apply the jQuery method val on the $(el) element and return the result. customTextInputExample(2) This time, the input value is returned. Notice that when you try to change the text content, the output value does not update as we would normally expect. We are actually missing a couple of methods so that the binding is fully working. We will introduce them in the following sections! Similarly as in the find section, we run customTextInputExample(2) and open the developer tools to inspect the customTextInputBinding.js script. We put a breakpoints in the getValue method and reload the page. Upon reload, the JavaScript debugger opens starts in find. You may click on the next blue arrow to jump to the next breakpoints that is getValue, as shown Figure 11.7. Typing $(el).val() in the console shows the current text value. FIGURE 11.7: getValue returns the current input value Clicking on next again exit the debugger. Interestingly, you’ll notice that a text appears below the input, meaning that the input$caption element exists and is internally tracked by shiny. 11.1.2.4 Set and update setValue(el, value) is used to set the value of the current input. This method is necessary so that the input value may be updated. It has to be used in combination with receiveMessage(el, data), which is the JavaScript part of all the R updateInput functions. We usually call the setValue method inside. setValue: function(el, value) { $(el).val(value); } Let’s create a function to update our custom text input. Call it updateCustomTextInput. It requires at least 3 parameters: inputId tells which input to update. value is the new value. This will be taken by the setValue JS method in the input binding session is the Shiny session object mentioned earlier. We will use the sendInputMessage to send values from R to JavaScript. The receiveMessage method will apply setValue with the data received from R. updateCustomTextInput &lt;- function(inputId, value = NULL, session = getDefaultReactiveDomain()) { session$sendInputMessage(inputId, message = value) } We add setValue and receiveMessage to custom input binding. updateCustomTextInputExample(3) Figure 11.8 illustrates the main mechanisms. FIGURE 11.8: Events following a click on the update button. This figure demonstrates how R and JS communicate, through the websocket. If we have to pass multiple elements to update, we would have to change the updateCustomTextInput function such as: updateCustomTextInput &lt;- function(inputId, value = NULL, placeholder = NULL, session = getDefaultReactiveDomain()) { message &lt;- dropNulls( list( value = value, placeholder = placeholder ) ) session$sendInputMessage(inputId, message) } dropNulls is an internal function ensuring that the list does not contain NULL elements. We send a list from R, which is then serialized to a JSON object. In the receiveMessage method, properties like value may be accessed using the . notation: receiveMessage: function(el, data) { console.log(data); if (data.hasOwnProperty(&#39;value&#39;)) { this.setValue(el, data.value); } // other parameters to update... } Similarly as in the previous sections, we run updateCustomTextInputExample(3) and open the developer tools to inspect the customTextInputBinding.js script. We put a breakpoints in the receiveMessage and setValue methods and reload the page. Upon reload, the JavaScript debugger opens starts in find. You may click on the next blue arrow until you reach receiveMessage, as shown Figure 11.9. Inspecting the data object, it contains only one property namely the value. In practice, there may be more complex structure. As an exercise, you may change the data.value to whatever value you want. FIGURE 11.9: Receive a message from R Click on the next arrow makes us jump in the next call that is setValue, where we can print the value to check whether it is correct. Running $(el).val(value); in the debugger console instantaneously update the DOM element with the new text, as shown on Figure 11.10. FIGURE 11.10: Set the new value So far so good! We managed to update the text input value on the client. Yet, after clicking the button, the output value does not change. We are going to fix this missing step in the next section. 11.1.2.5 Subscribe subscribe(el, callback) listens to events defining Shiny to update the input value and make it available in the app. Some API like Bootstrap explicitly mention those events (like hide.bs.tab, shown.bs.tab, …). Going back to our custom text input, what event would make it change? After a key is release on the keyboard. We may listen to keyup After copying and pasting any text in the input field or dictating text. The input event may be helpful We may add those events to our binding using an event listener seen at the end of Chapter 9. $(el).on(&#39;keyup.customTextBinding input.customTextBinding&#39;, function(event) { callback(true); }); callback ensures that the new value is captured by Shiny. We will come back later on the callback parameter, which is rather complex. updateCustomTextInputExample(4) We run the above example, open the HTML inspector, select the customTextInputBinding_4.js script and put a break point in the getValue as well as subscribe method. We enter a new text inside the input field, which triggers the debugger inside the subscribe call. Inspecting the event object, the type indicate the action, which is an input action and the target is the text input element itself, depicted on Figure 11.11. FIGURE 11.11: Subscribe method after a manual update of the text input We click on next and notice that we go back in the getValue method to get the new value. You may check typing $(el).val() in the debugger console, like on Figure 11.12. Clicking next again shows the updated output value. FIGURE 11.12: Subscribe is followed by a new getValue Hooray! The output result is successfully changed when the input value is manually updated. However, it is not modified when we click on the update button. What did we miss? Looking back at the receiveMessage method, we changed the input value but how does Shiny knows that this step was successful? To check that no event is raised, we put a console.log(event); in the subscribe method. Any action like removing the text content or adding new text triggers event but clicking on the action button does not. Therefore, we must trigger an event and add it to the subscribe method. We may choose the change event, that triggers when an element is updated. Notice the parameter passed to callback. We discuss it in the next part! $(el).on(&#39;change.customTextBinding&#39;, function(event) { callback(false); }); Besides, in the receiveMessage we must trigger a change event to trigger the subscribe method: receiveMessage: function(el, data) { if (data.hasOwnProperty(&#39;value&#39;)) { this.setValue(el, data.value); $(el).trigger(&#39;change&#39;); } } Let’s try again. updateCustomTextInputExample(5) We put a new break point in the second event listener, that is the one for the change event. Clicking on the button only triggers the change event, as shown Figure 11.13. FIGURE 11.13: We may add multiple event listeners inside the subscribe method Note: in some situations, we have to be careful with the this element. Indeed, called in an event listener, this refers to the element that triggered the event and not to the input binding object. For instance below is an example where we need to trigger the getValue method inside an event listener located in the subscribe method. If you call this.getValue(el), you’ll get an error. The trick consists in creating a variable namely self that take this as value, outside the event listener. In that case self refers to the binding itself and it make sens to call self.getValue(el): subscribe: function(el, callback) { self = this; $(el).on(&#39;click.button&#39;, function(e) { var currentVal = self.getValue(el); $(el).val(currentVal + 1); callback(); }); } Perfect? Not exactly. 11.1.2.6 Setting rate policies It would be better to only change the input value once the keyboard is completely released for some time (and not each time a key is released). This is what we call debouncing, which allows a delay before telling Shiny to read the new value, and is achieved using the getRatePolicy method. Additionally, we must also pass true to the callback in the subscribe method, in order to apply our specific rate policy (debounce, throttle). This is useful for instance when we don’t want to flood the server with useless update requests. For example when using a slider, we only want to send the value as soon as the range stops moving and not all intermediate values. Those elements are defined here. Run the app below and try to manually change the text input value by adding a couple of letters as fast as you can. What do you notice? We see the output value only updates when we release the keyboard. customTextInputExample(6) You may adjust the delay according to your needs, but we caution to not set the delay too long as this becomes problematic too. If you want to get an overview of all binding steps, you may try the following slide from the 2020 R in Pharma workshop. 11.1.2.7 Register an input binding At the end of the input binding definition, we register it for Shiny. let myBinding = new Shiny.inputBinding(); $.extend(myBinding, { // methods go here }); Shiny.inputBindings.register(myBinding, &#39;reference&#39;); Although the Shiny documentation mentions a Shiny.inputBindings.setPriority method to handle conflicting bindings, this case almost never happens. 11.1.2.8 Other binding methods There are a couple of methods not described above that are contained in the InputBinding class prototype. They were not described before since most of the time, we don’t need to change them and can rely on the defaults: getId returns the object id (Figure 11.14). If you don’t provide your own method, the binding falls back to the default one provided in the InputBinding class. This method is called after find. The next Chapter 12 provides more details. getType required to handle custom data format. It is called after getId. See section 11.4. getState ? FIGURE 11.14: The binding getId method 11.1.3 Edit an input binding In some cases, we would like to access the input binding and change it’s default behavior, even though not always recommended, since it will affect all related inputs. As bindings are contained in a registry, namely Shiny.inputBindings, one may seamlessly access and modify them. This is a 5 steps process: Wait for the shiny:connected event Unbind all inputs with Shiny.unbindAll() Access the binding registry, Shiny.inputBindings Extend the binding and edit its content with $.extend(... {...}) Apply the new changes with Shiny.bindAll() $(function() { $(document).on(&#39;shiny:connected&#39;, function(event) { Shiny.unbindAll(); $.extend(Shiny .inputBindings .bindingNames[&#39;shiny.actionButtonInput&#39;] .binding, { // do whathever you want to edit existing methods }); Shiny.bindAll(); }); }); 11.1.4 Update a binding from the client The interest of receiveMessage and setValue is to be able to update the input from the server side, that is R, through the session$sendInputMessage. Yet, this task might be done directly on the client, thereby lowering the load on the server. We consider the following example: a shiny app contains 2 actions buttons, clicking on the first one increases the value of the second by 10. This won’t be possible with the classic approach since a button click only increases by 1. How do we proceed? We first set an event listener on the first button. We target the second button and get the input binding with $obj.data('shiny-input-binding') We recover the current value We call the setValue method of the input binding adding 10 to the current value Importantly, to let Shiny update the value on the R side, we must trigger an event that will be detected in the subscribe method of the action button input binding. The action button only has 1 event listener but other may be added. Don’t forget that triggering a click event would also increment the button value by 1! In the following we have to customize the subscribe method to work around: $(function() { // each time we click on #test (a button) $(&#39;#button1&#39;).on(&#39;click&#39;, function() { var $obj = $(&#39;#button2&#39;); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); var val = $obj.data(&#39;val&#39;) || 0; inputBinding.setValue($obj, val + 10); $obj.trigger(&#39;event&#39;); }); }); If you click on the second button, the value increments only by 1 and the plot will be only visible after 10 clicks, while only 1 click is necessary on the first button. The reset button resets the second action button value to 0. It implements the feature discussed in the previous part, where we extend the button binding to add a reset method and edit the subscribe method to add a change event listener, simply telling shiny to get the new value. Contrary to click, change does not increment the button value. $.extend(Shiny.inputBindings.bindingNames[&#39;shiny.actionButtonInput&#39;].binding, { reset: function(el) { $(el).data(&#39;val&#39;, 0); }, subscribe: function(el, callback) { $(el).on(&#39;click.actionButtonInputBinding&#39;, function(e) { var $el = $(this); var val = $el.data(&#39;val&#39;) || 0; $el.data(&#39;val&#39;, val + 1); callback(); }); // this does not trigger any click and won&#39;t change the button value $(el).on(&#39;change.actionButtonInputBinding&#39;, function(e) { callback(); }); } }); The whole JS code is found below: $(function() { $(document).on(&#39;shiny:connected&#39;, function(event) { Shiny.unbindAll(); $.extend(Shiny .inputBindings .bindingNames[&#39;shiny.actionButtonInput&#39;] .binding, { reset: function(el) { $(el).data(&#39;val&#39;, 0); }, subscribe: function(el, callback) { $(el).on(&#39;click.actionButtonInputBinding&#39;, function(e) { var $el = $(this); var val = $el.data(&#39;val&#39;) || 0; $el.data(&#39;val&#39;, val + 1); callback(); }); $(el).on(&#39;change.actionButtonInputBinding&#39;, function(e) { debugger; callback(); }); } }); Shiny.bindAll(); }); $(&#39;#button1&#39;).on(&#39;click&#39;, function() { var $obj = $(&#39;#button2&#39;); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); var val = $obj.data(&#39;val&#39;) || 0; inputBinding.setValue($obj, val + 10); $obj.trigger(&#39;change&#39;); }); $(&#39;#reset&#39;).on(&#39;click&#39;, function() { var $obj = $(&#39;#button2&#39;); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); inputBinding.reset($obj); $obj.trigger(&#39;change&#39;); }); }); Below is the working app: editBindingExample() whose output is shown Figure 11.15. FIGURE 11.15: Edit and trigger an input binding from the client This trick has been extensively used in the virtual physiology simulator to trigger animations. 11.2 Secondary inputs The Shiny input binding system is too convenient to be only used for primary input elements like textInput, numericInput. It is a super powerful tool to unleash apps’s interactivity. In the following, we show how to add an input to an element that was not primarily designed to be a user input. 11.2.1 {shinydashboard} boxes on steroids In {shinydashboard}, you may know the box function. Boxes are containers with a title, body, footer, as well as optional elements. It would be nice to capture the state of the box in an input, so as to trigger other actions as soon as this input changes. Since an input value is unique, we must add an inputId parameter to the box function. You may inspect the code here. Since we may collapse and uncollapse the box, we create the updateBox2 function, which will toggle it: updateBox2 &lt;- function(inputId, session = getDefaultReactiveDomain()) { session$sendInputMessage(inputId, message = NULL) } When collapsed, a box gets the collapsed-box class, which is useful to keep in mind for the input binding design. As mentioned above, it is also necessary to know when to tell Shiny to update the value with the subscribe method. Most of the time, the change event might be sufficient, but as {shinydashboard} is built on top of AdminLTE2, it has an API to control the box behavior. We identify 2 events corresponding to the collapsible action: expanded.boxwidget (Triggered after the box is expanded) collapsed.boxwidget (Triggered after the box is collapsed) Unfortunately, after further investigations, those events are not possible to use since the AdminLTE library does not trigger them in the main JS code (see the collapse method line 577-612). There are other solutions, as shown below with the click event. To toggle the box, we use the toggleBox method. let boxBinding = new Shiny.InputBinding(); $.extend(boxBinding, { find: function(scope) { return $(scope).find(&#39;.box&#39;); }, getValue: function(el) { let isCollapsed = $(el).hasClass(&#39;collapsed-box&#39;) return {collapsed: isCollapsed}; // this will be a list in R }, setValue: function(el, value) { $(el).toggleBox(); }, receiveMessage: function(el, data) { this.setValue(el, data); $(el).trigger(&#39;change&#39;); }, subscribe: function(el, callback) { $(el).on(&#39;click&#39;, &#39;[data-widget=&quot;collapse&quot;]&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); $(el).on(&#39;change&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); }, unsubscribe: function(el) { $(el).off(&#39;.boxBinding&#39;); } }); Shiny.inputBindings.register(boxBinding, &#39;box-input&#39;); Some comments about the binding: getValue returns an object which will give a list in R. This is in case we add other elements like the remove action available in AdminLTE setValue calls the plug and play toggleBox method receiveMessage must trigger a change event so that Shiny knows when the value needs to be updated subscribe listens to the click event on the [data-widget=\"collapse\"] element and delays the callback call by a value which is slightly higher than the default AdminLTE2 animation to collapse the box (500ms). If you omit this part, the input will not have time to properly update! We don’t need an extra listener for the updateBox2 function since it also triggers a click on the collapse button, thereby forwarding to the corresponding listener Let’s try our new toy in a simple app. The output is depicted on Figure 11.16. FIGURE 11.16: {shinydashboard} box with custom input binding listening to the box collapse state ui &lt;- fluidPage( # import shinydashboard deps without the need of the dashboard template useShinydashboard(), tags$style(&quot;body { background-color: ghostwhite};&quot;), br(), box2( title = textOutput(&quot;box_state&quot;), &quot;Box body&quot;, inputId = &quot;mybox&quot;, collapsible = TRUE, plotOutput(&quot;plot&quot;) ), actionButton(&quot;toggle_box&quot;, &quot;Toggle Box&quot;, class = &quot;bg-success&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ req(!input$mybox$collapsed) plot(rnorm(200)) }) output$box_state &lt;- renderText({ state &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; paste(&quot;My box is&quot;, state) }) observeEvent(input$toggle_box, { updateBox2(&quot;mybox&quot;) }) } shinyApp(ui, server) Even though animations are nice, it appears rather sub-optimal to wait 500 ms for a box to collapse. AdminLTE options allow to change this through the $.AdminLTE.boxWidget object. We specify the animationSpeed property to 10 milliseconds and update the input binding script to reduce the delay in the subscribe method (50 ms seems reasonable). To get a comparison try to run the example below. # You&#39;ll need the devel version of shinydashboardPlus #remotes::install_github(&quot;RinteRface/shinydashboardPlus&quot;) library(shiny) library(shinydashboard) library(shinydashboardPlus) ui &lt;- dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody( tags$style(&quot;body { background-color: ghostwhite}&quot;), actionButton(&quot;toggle_box&quot;, &quot;Toggle Box&quot;), br(), box( title = textOutput(&quot;box_state&quot;), &quot;Box body&quot;, inputId = &quot;mybox&quot;, collapsible = TRUE, closable = TRUE, plotOutput(&quot;plot&quot;) ) ) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ req(!input$mybox$collapsed) plot(rnorm(200)) }) output$box_state &lt;- renderText({ state &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; paste(&quot;My box is&quot;, state) }) observeEvent(input$toggle_box, { updateBox(&quot;mybox&quot;, action = &quot;toggle&quot;) }) observeEvent(input$mybox$collapsed, { collapsed &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; message &lt;- paste(&quot;My box is&quot;, collapsed) showNotification(message, type = &quot;warning&quot;, duration = 1) }) } shinyApp(ui, server) 11.2.2 Going further We may imagine leveraging the input binding system to update any box property and get rid of the classic renderUI approach. Indeed, until now, there would be only one way to update a box from the server (Figure 11.17): ui &lt;- fluidPage( # import shinydashboard deps without the need of the dashboard template useShinydashboard(), tags$style(&quot;body { background-color: ghostwhite};&quot;), br(), uiOutput(&quot;custom_box&quot;), selectInput(&quot;background&quot;, &quot;Background&quot;, choices = shinydashboard:::validColors) ) server &lt;- function(input, output, session) { output$custom_box &lt;- renderUI({ box2( title = &quot;Box&quot;, &quot;Box body&quot;, background = input$background ) }) } shinyApp(ui, server) FIGURE 11.17: {shinydashboard} box updated with shiny::renderUI The whole piece of UI is re-rendered each time, while only the box class should be modified. This does not have much impact here but for a very complex app festooned with inputs/outputs, the overall user experience may be altered. Let’s provide some optimization and get rid of the renderUI. We proceed in 2 steps. The first part consists in customizing the box function to gather as many parameter as possible in an option list. For instance, we choose to extract background, width and title. width and background are expected to be numeric and character, respectively, while title might be any HTML tag, justifying the use of as.character. box2 &lt;- function(..., id = NULL, title = NULL, footer = NULL, background = NULL, width = 6, height = NULL, collapsible = FALSE, collapsed = FALSE) { props &lt;- dropNulls( list( title = as.character(title), background = background, width = width ) ) # I removed some of the code to highlight that part } This properties list has to be treated on the JS side. Before, we must make it accessible within the box2 HTML tag. We choose the following approach, where we convert our properties to a JSON with jsonlite::toJSON and embed them in a script tag. Note the data-for attribute with the unique id parameter. This will guarantee the uniqueness of our configuration script. box2 &lt;- function(..., id = NULL, title = NULL, footer = NULL, background = NULL, width = 6, height = NULL, collapsible = FALSE, collapsed = FALSE) { # code not shown boxTag &lt;- shiny::tags$div( class = if (!is.null(width)) paste0(&quot;col-sm-&quot;, width), shiny::tags$div( id = id, class = boxClass, headerTag, shiny::tags$div( class = &quot;box-body&quot;, style = style, ..., sidebar[c(1, 3)], ), if (!is.null(footer)) shiny::tags$div( class = if (isTRUE(footerPadding)) &quot;box-footer&quot; else &quot;box-footer no-padding&quot;, footer) ), # this will make our props accessible from JS shiny::tags$script( type = &quot;application/json&quot;, `data-for` = id, jsonlite::toJSON( x = props, auto_unbox = TRUE, json_verbatim = TRUE ) ) ) boxTag } Then, we have to update the updateBox2 such that it handles both toggle and update possibilities. options contains all updatable properties like background, title and width. We don’t describe the toggle case since it is quite similar to the previous implementations. When the action is update, we enter the if statement and options must be processed. If the option element is a shiny tag or a list of shiny tag (tagList), we convert it to character. The returned message is a vector containing the action as well as the option list. updateBox2 &lt;- function(id, action = c(&quot;toggle&quot;, &quot;update&quot;), options = NULL, session = getDefaultReactiveDomain()) { # for update, we take a list of options if (action == &quot;update&quot;) { # handle case where options are shiny tag or a list of tags ... options &lt;- lapply(options, function(o) { if (inherits(o, &quot;shiny.tag&quot;) || inherits(o, &quot;shiny.tag.list&quot;)) { o &lt;- as.character(o) } o }) message &lt;- dropNulls(c(action = action, options = options)) session$sendInputMessage(id, message) } else { session$sendInputMessage(id, message = action) } } On the JS side, we modify the setValue method to import our newly defined properties. The boxTag has two children, the box and the configuration script. $(el) refers to the box, therefore we have to look one level up to be able to use the find method (find always goes deeper in the DOM), namely $(el).parent(). From there, we only have to target the script tag $(el).parent().find(\"script[data-for='\" + el.id + \"']\"). Once captured in a variable, we parse the corresponding element to convert it to an objects that we can manipulate: for instance config.width returns the initial width. value.options.width will contain the new width value provided in the updateBox2 message output. Good practice is to check whether value.options.width exists with value.options.hasOwnProperty(\"width\"). If yes we ensure whether its value and config.width are different. We always choose === which compares the type and the value (== only compares the value such that \"1\" == 1 is true). We then call the internal method _updateWidth which is defined in the input binding. It has 3 parameters, el, o and n (o and n being the old and new values, respectively): _updateWidth: function(el, o, n) { // removes old class $(el).parent().toggleClass(&quot;col-sm-&quot; + o); $(el).parent().addClass(&quot;col-sm-&quot; + n); // trigger resize so that output resize $(el).trigger(&#39;resize&#39;); } We must trigger a resize event so that output correctly scale. The internal method is identified by an underscore since it is not an inherited Shiny.InputBinding method. We finally update the config value by the newly set value and repeat the process for any other property. setValue: function(el, value) { var config = $(el).parent().find(&quot;script[data-for=&#39;&quot; + el.id + &quot;&#39;]&quot;); config = JSON.parse(config.html()); // JS logic if (value.action === &quot;update&quot;) { if (value.options.hasOwnProperty(&quot;width&quot;)) { if (value.options.width !== config.width) { this._updateWidth(el, config.width, value.options.width) config.width = value.options.width; } } // other items to update // replace the old JSON config by the new one to update the input value $(el) .parent() .find(&quot;script[data-for=&#39;&quot; + el.id + &quot;&#39;]&quot;) .replaceWith( &#39;&lt;script type=&quot;application/json&quot; data-for=&quot;&#39; + el.id + &#39;&quot;&gt;&#39; + JSON.stringify(config) + &#39;&lt;/script&gt;&#39; ); } else { // other tasks } } Don’t forget to update the config script attached to the card tag at the end of the update condition, otherwise the input value won’t be updated: $(el) .parent() .find(&quot;script[data-for=&#39;&quot; + el.id + &quot;&#39;]&quot;) .replaceWith( &#39;&lt;script type=&quot;application/json&quot; data-for=&quot;&#39; + el.id + &#39;&quot;&gt;&#39; + JSON.stringify(config) + &#39;&lt;/script&gt;&#39; ); If it represents a significant amount of work, it is also the guarantee to lower the load on the server side, thereby offering a faster end user experience. A working prototype has been implemented in {shinydashboardPlus} and {bs4Dash}: shinyAppDir(system.file(&quot;vignettes-demos/box-api&quot;, package = &quot;shinydashboardPlus&quot;)) 11.3 Utilities to quickly define new inputs 11.3.1 Introduction If you ever wondered where the Shiny.onInputChange or Shiny.setInputValue comes from (see article), it is actually defined in the initShiny function. exports.setInputValue = exports.onInputChange = function(name, value, opts) { opts = addDefaultInputOpts(opts); inputs.setInput(name, value, opts); }; Briefly, this function avoids creating an input binding. It is faster to code but there is a price to pay: losing the ability to easily update the new input. Indeed, all input functions like sliderInput have their own update function like updateSliderInput, because of the custom input binding system (We will see it very soon)! 11.3.2 Examples Shiny.setInputValues becomes powerful when combined to the numerous Shiny JavaScript events listed here. This is what we use in the shinyMobile package to store the current device information in a shiny input. Briefly, Framework7 (on top of which is built shinyMobile) has a method Framework7.device, which gives many details related to the user device. $(document).on(&#39;shiny:connected&#39;, function(event) { Shiny.setInputValue(&#39;deviceInfo&#39;, Framework7.device); }); This allows to conditionally display elements and deeply customize the interface. In the example below, the card will not show on mobile devices. library(shinyMobile) shinyApp( ui = f7Page( title = &quot;My app&quot;, f7SingleLayout( navbar = f7Navbar( title = &quot;shinyMobile info&quot;, hairline = FALSE, shadow = TRUE ), # main content uiOutput(&quot;card&quot;), verbatimTextOutput(&quot;info&quot;), ) ), server = function(input, output, session) { output$info &lt;- renderPrint(input$shinyInfo) # generate a card only for desktop output$card &lt;- renderUI({ if (!input$deviceInfo$desktop) { f7Card( &quot;This is a simple card with plain text, but cards can also contain their own header, footer, list view, image, or any other element.&quot; ) } else { f7Toast( session, &quot;You are on desktop! The card will not display&quot;, position = &quot;center&quot; ) } }) } ) 11.4 Custom data format In some cases, the automatic Shiny R to JS data management may not meet our needs. 11.4.1 The dirty way For instance, assume we create a date in JS with new Date() and store it in a shiny input with Shiny.setInputValue. On the R side, we will not obtain a date but a character, which is not convenient. This is where input handlers are useful since they allow to manipulate data generated on the JS side before injecting them in R. Such handlers are created with shiny::registerInputHandler that takes 2 parameters: type allows to connect the handler to Shiny.setInputValue. Note that the id is followed by the handler type, for instance Shiny.setInputValue('test:handler', ...) is connected to shiny::registerInputHandler('handler', ...). As recommended by the Shiny documentation, if the input handler is part of a package, it is best practice to name it like packageName.widgetName. a function to transform data, having data as main parameter Below we exceptionally include JS code directly in the shiny app snippet, which is not best practice but convenient for the demonstration. Only the second input will give the correct result. registerInputHandler(&quot;OSUICode.textDate&quot;, function(data, ...) { if (is.null(data)) { NULL } else { res &lt;- try(as.Date(unlist(data)), silent = TRUE) if (&quot;try-error&quot; %in% class(res)) { warning(&quot;Failed to parse dates!&quot;) # as.Date(NA) data } else { res } } }, force = TRUE) ui &lt;- fluidPage( tags$script( &quot;$(function(){ $(document).on(&#39;shiny:connected&#39;, function() { var currentTime = new Date(); Shiny.setInputValue(&#39;time1&#39;, currentTime); Shiny.setInputValue(&#39;time2:OSUICode.textDate&#39;, currentTime); }); }); &quot; ), verbatimTextOutput(&quot;res1&quot;), verbatimTextOutput(&quot;res2&quot;) ) server &lt;- function(input, output, session) { output$res1 &lt;- renderPrint(list(class(input$time1), input$time1)) output$res2 &lt;- renderPrint(list(class(input$time2), input$time2)) } shinyApp(ui, server) 11.4.2 The clean way: leverage getType The cleanest way is to leverage the getType method from the InputBinding class. Let’s take our text input so that it handles dates. On the R side, in the customTextInput() function, we check the current value’s type: type &lt;- if (inherits(value, &quot;Date&quot;)) { &quot;date&quot; } else { NULL } We add a custom data attribute to the input tag, which won’t be displayed if the value is not a date: tags$input( id = inputId, type = &quot;text&quot;, class = &quot;form-control input-text&quot;, value = value, placeholder = placeholder, `data-data-type` = type ) We then define our custom handler. This code is run when the package is loaded and usually located in a zzz.R script: .onLoad &lt;- function(...) { registerInputHandler(&quot;OSUICode.textDate&quot;, function(data, ...) { if (is.null(data)) { NULL } else { res &lt;- try(as.Date(unlist(data)), silent = TRUE) if (&quot;try-error&quot; %in% class(res)) { warning(&quot;Failed to parse dates!&quot;) # as.Date(NA) data } else { res } } }, force = TRUE) } Note: shiny already handles dates and we could use the built-in input handler. The current handler was only designed for teaching purposes. On the JavaScript side, we refer to the OSUICode.textDate defined input handler. We recover the data-type value passed from R and call the handler if the type is a date. We return false otherwise, which is the default behavior: getType: function getType(el) { var dataType = $(el).data(&quot;data-type&quot;); if (dataType === &quot;date&quot;) return &quot;OSUICode.textDate&quot;; // if (dataType === &quot;date&quot;) return &quot;shiny.date&quot; else return false; } To use the shiny built-in handler we could return \"shiny.date\" instead. We then run: customTextInputHandlerExample(7) which sets the value as text by default. After opening the HTML inspector and setting a break point in the getType method (Figure 11.18), we check that the data type is not defined. Therefore the input handler will not apply. FIGURE 11.18: Example where getType does not call the input handler For the second example, we give a date value to the function: customTextInputHandlerExample(7, Sys.Date()) As illustrated Figure 11.19, the date is properly processed. Moreover, if you type any other valid date in the text field like 2020-11-12, it will be recognized as a date, while entering a text will return a character element. This is a way to obtain a slightly more clever text input widget. FIGURE 11.19: Passing a date to a text input correctly processes it Importantly, since the data-type is set at app startup by checking the class of the value, it will never change later. For instance, if you start the app with the text input value to be a simple text, setting it to a date through the app does not convert it into a date since $(el).data(\"data-type\") always return undefined! Therefore, if you want to be able to use both text and dates, be sure to wisely set the initial value. To finish, we could seamlessly make out text input even more clever, by handling numbers. Even though shiny has a shiny.number input handler, it simply makes sure that whenever the input is missing a value, NA is returned instead of \"\". (Figure 11.20). FIGURE 11.20: shiny.number input handler ensures that an empty numericInput returns NA instead of \"\" What we want is an handler that recognizes the string \"1\" and convert it to a number. In R, converting a string to a number gives NA: as.numeric(&quot;test&quot;) ## Warning: NAs introduced by coercion ## [1] NA Therefore, if we obtain NA, we return original data so that the input returns the correct type. Right after our previous handler, we can write: registerInputHandler(&quot;OSUICode.textNumber&quot;, function(data, ...) { if (is.null(data)) { NULL } else { res &lt;- as.numeric(unlist(data)) if (is.na(res)) { data } else { res } } }, force = TRUE) We also update the JavaScript getType method as follows: getType: function getType(el) { var dataType = $(el).data(&quot;data-type&quot;); if (dataType === &quot;date&quot;) return &quot;OSUICode.textDate&quot;; else if (dataType === &quot;number&quot;) return &quot;OSUICode.textNumber&quot;; else return false; } On the R side, don’t forget to add an extra else if statement to the customTextInput() function: type &lt;- if (inherits(value, &quot;Date&quot;)) { &quot;date&quot; } else if (inherits(value, &quot;numeric&quot;)) { &quot;number&quot; } else { NULL } If we run: customTextInputHandlerExample(7, 1) we obtain the desired behavior shown Figure 11.21. FIGURE 11.21: Passing a number to a text input correctly processes it "],["shiny-input-lifecycle.html", "Chapter 12 Shiny inputs lifecycles 12.1 App initialization 12.2 Update input", " Chapter 12 Shiny inputs lifecycles In the following, we recap everything we see from chapter 10. 12.1 App initialization When a shiny apps starts, Shiny runs initShiny on the client. This function has 3 main tasks: Bind all inputs and outputs with _bindAll(). Initialize all inputs (if necessary) with initializeInputs. Initialize the client websocket connection mentioned in the previous chapter 10 and send initial values to the server. Most input bindings are in principle bundled in the {shiny} package. Some may be user-defined like in {shinyMobile} or even in a simple shiny app. In any case, they are all contained in a binding registry, namely inputBindings built on top the following class (the same apply for output bindings): var BindingRegistry = function() { this.bindings = []; this.bindingNames = {}; } This class has method to register binding. This is the one we call when doing Shiny.inputBindings.register(myBinding, 'reference');, which appends the newly created binding to the bindings array. When shiny starts, it has to find all defined bindings with the getBindings method. Once done, for each binding, find is triggered. If no corresponding element is found in the DOM, nothing is done. For each found input, the following methods are triggered: getId (no described before) returns the input id. This ensures the uniqueness and is critical! getType optionally handles any registerInputHandler defined by the user on the R side. getValue gets the initial input value. subscribe registers event listeners driving the input behavior. The data attribute shiny-input-binding is then added. This allows shiny or any end-users to access the input binding methods from the client (in practice, very few end-users will do that). The shiny-bound-input class is added, the corresponding input is appended to the boundInputs object (listing all bound inputs) and shiny:bound triggered on the client. Once done, shiny stores all initial values in a variable initialInput, also containing all client data and pass them to the Shinyapp.connect method. As shown in 10, the latter opens the client websocket connection, raises the shiny:connected event and send all values to the server (R). Few time after, shiny:sessioninitialized is triggered. FIGURE 12.1: What Shiny does client side on initialization In chapter 10, we briefly described the shiny JavaScript object. As an exercise, let’s explore what the Shiny.shinyApp object contains. The definition is located in the shinyapps.js script. var ShinyApp = function() { this.$socket = null; // Cached input values this.$inputValues = {}; // Input values at initialization (and reconnect) this.$initialInput = {}; // Output bindings this.$bindings = {}; // Cached values/errors this.$values = {}; this.$errors = {}; // Conditional bindings (show/hide element based on expression) this.$conditionals = {}; this.$pendingMessages = []; this.$activeRequests = {}; this.$nextRequestId = 0; this.$allowReconnect = false; }; It creates several properties, some of them are easy to guess like inputValues or initialInput. Let’s run the example below and open the HTML inspector. Notice that the sliderInput is set to 500 at t0 (initialization). ui &lt;- fluidPage( sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Figure 12.2 shows how to access Shiny’s initial input value with Shiny.shinyapp.$initialInput.obs. After changing the slider position, its value is given by Shiny.shinyapp.$inputValues.obs. $initialInput and $inputValues contains many more elements, however we are only interested in the slider function in this example. FIGURE 12.2: Explore initial input values 12.2 Update input Below we try to explain what are the mechanisms to update an input from the server on the client. As stated above, it all starts with an update&lt;name&gt;Input function call, which actually sends a message through the current session. This message is received by the client websocket message manager: socket.onmessage = function(e) { self.dispatchMessage(e.data); }; which sends the message to the appropriate handler, that is inputMessages: addMessageHandler(&#39;inputMessages&#39;, function(message) { // inputMessages should be an array for (var i = 0; i &lt; message.length; i++) { var $obj = $(&#39;.shiny-bound-input#&#39; + $escape(message[i].id)); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); // Dispatch the message to the appropriate input object if ($obj.length &gt; 0) { var el = $obj[0]; var evt = jQuery.Event(&#39;shiny:updateinput&#39;); evt.message = message[i].message; evt.binding = inputBinding; $(el).trigger(evt); if (!evt.isDefaultPrevented()) inputBinding.receiveMessage(el, evt.message); } } }); In short, this does get the inputId and access the corresponding input binding. Then it triggers the shiny:updateinput event and call the input binding receiveMessage method. This fires setValue and subscribe. The way subscribe works is not really well covered in the official documentation. The callback function is actually defined during the initialization process: function valueChangeCallback(binding, el, allowDeferred) { var id = binding.getId(el); if (id) { var value = binding.getValue(el); var type = binding.getType(el); if (type) id = id + &quot;:&quot; + type; let opts = { priority: allowDeferred ? &quot;deferred&quot; : &quot;immediate&quot;, binding: binding, el: el }; inputs.setInput(id, value, opts); } } valueChangeCallback ultimately calls inputs.setInput(id, value, opts). The latters involves a rather complex chain of reactions (which is not described here). Overall, the result is stored in a queue, namely pendingData and sent to the server with shinyapp.sendInput: this.sendInput = function(values) { var msg = JSON.stringify({ method: &#39;update&#39;, data: values }); this.$sendMsg(msg); $.extend(this.$inputValues, values); // other things ... } The message has an update tag and is sent through the client websocket, only if the connection is opened. If not, it is added to the list of pending messages. this.$sendMsg = function(msg) { if (!this.$socket.readyState) { this.$pendingMessages.push(msg); } else { this.$socket.send(msg); } }; Finally, current inputValues are updated. On the server side, the new value is received by the server websocket message handler, that is ws$onMessage(message). FIGURE 12.3: What Shiny does client side on initialization "],["shiny-input-gems.html", "Chapter 13 Hidden gems about inputs 13.1 Get the last changed input", " Chapter 13 Hidden gems about inputs We present some tools that may be useful…TO FINISH 13.1 Get the last changed input 13.1.1 Motivations We probably all had this question one day: How can I get the last changed input in Shiny? There are already some methods like this one provided by Dean Attali. runApp( shinyApp( ui = shinyUI( fluidPage( textInput(&#39;txt_a&#39;, &#39;Input Text A&#39;), textInput(&#39;txt_b&#39;, &#39;Input Text B&#39;), uiOutput(&#39;txt_c_out&#39;), verbatimTextOutput(&quot;show_last&quot;) ) ), server = function(input, output, session) { output$txt_c_out &lt;- renderUI({ textInput(&#39;txt_c&#39;, &#39;Input Text C&#39;) }) values &lt;- reactiveValues( lastUpdated = NULL ) observe({ lapply(names(input), function(x) { observe({ input[[x]] values$lastUpdated &lt;- x }) }) }) output$show_last &lt;- renderPrint({ values$lastUpdated }) } ) ) Shouldn’t this be easier? Could we do that from the client instead, thereby reducing the server load? 13.1.2 JavaScript, my friend Here comes our friend, JavaScript. If you insert this snippet in the head of your app, you will be able to get the last changed input (name, value and type). $(document).on(&#39;shiny:inputchanged&#39;, function(event) { Shiny.setInputValue(&#39;pleaseStayHome&#39;, {name: event.name, value: event.value, type: event.binding.name.split(&#39;.&#39;)[1]}); }); If you use this code in a custom shiny template, it is possible that input bindings don’t have name, which would thereby make event.binding.name.split('.')[1] crash because event.binding is undefined. If so, you may remove this part: $(document).on(&#39;shiny:inputchanged&#39;, function(event) { Shiny.setInputValue(&#39;pleaseStayHome&#39;, {name: event.name, value: event.value}); }); 13.1.3 Example {shinyMobile} natively implements this feature that may be accessed with input$lastInputChanged. library(shinyMobile) shinyApp( ui = f7Page( title = &quot;My app&quot;, f7SingleLayout( navbar = f7Navbar( title = &quot;Single Layout&quot;, hairline = FALSE, shadow = TRUE ), toolbar = f7Toolbar( position = &quot;bottom&quot;, f7Link(label = &quot;Link 1&quot;, src = &quot;https://www.google.com&quot;), f7Link(label = &quot;Link 2&quot;, src = &quot;https://www.google.com&quot;, external = TRUE) ), # main content, f7Card( f7Text(inputId = &quot;text&quot;, label = &quot;Text&quot;), f7Slider(inputId = &quot;range1&quot;, label = &quot;Range&quot;, min = 0, max = 2, value = 1, step = 0.1), f7Stepper(inputId = &quot;stepper1&quot;, label = &quot;Stepper&quot;, min = 0, max = 10, value = 5), verbatimTextOutput(&quot;lastChanged&quot;) ) ) ), server = function(input, output) { output$lastChanged &lt;- renderPrint(input$lastInputChanged) } ) This approach has the advantage not to overload the server part with complex logic. 13.1.4 About {shinylogs} The {shinylogs} package developed by dreamRs contains this feature with much more advanced options. library(shinylogs) shinyApp( ui = fluidPage( numericInput(&quot;n&quot;, &quot;n&quot;, 1), sliderInput(&quot;s&quot;, &quot;s&quot;, min = 0, max = 10, value = 5), verbatimTextOutput(&quot;lastChanged&quot;) ), server = function(input, output, session) { # specific to shinylogs track_usage(storage_mode = store_null()) output$lastChanged &lt;- renderPrint(input$`.shinylogs_lastInput`) } ) "],["shiny-custom-handler.html", "Chapter 14 Dynamically manage content with handlers 14.1 Introduction 14.2 The renderUI case 14.3 Other Shiny handlers 14.4 Custom handlers", " Chapter 14 Dynamically manage content with handlers The three previous chapters are largely dedicated to Shiny input elements. Yet, not everything is input in Shiny. This chapter shows how one may leverage the internal Shiny JavaScript tools to build highly interactive and optimized interfaces. 14.1 Introduction As shown in the Mastering Shiny book, there exists tools to update UI components from the server. You can use all update&lt;INPUT_NAME&gt; functions like updateTextInput or updateTabsetPanel. Other tools to manage your UI consist in toggle functions like hideTab, showTab, the limit being the very few number of them, which often obliges us to use packages like shinyjs (Attali 2020) or write custom JavaScript code. Finally, insertUI/removeUI allows to dynamically insert or remove any element, anywhere in the DOM, which is quite powerful. Let’s start this chapter with the less optimized approach, that is renderUI, to highlight its caveats and introduce better tools to optimize your apps. 14.2 The renderUI case One may know the renderUI/uiOutput that allows to render any HTML block from the server. While the update&lt;INPUT_NAME&gt; and toggle tools are component specific, meaning they only target the element to modify, renderUI/uiOutput re-renders the whole block each time an associated reactive dependency is invalidated, even though only a little part should be re-rendered. This approach is usually to avoid since it implies poor performances. Let’s see below, where I simulate a computationally intensive task for three seconds, corresponding to the time to obtain the slider value: library(shiny) ui &lt;- fluidPage( uiOutput(&quot;moreControls&quot;) ) server &lt;- function(input, output) { sliderValue &lt;- reactive({ # computationally intensive task Sys.sleep(3) 1 }) output$moreControls &lt;- renderUI({ sliderInput(&quot;n&quot;, &quot;N&quot;, sliderValue(), 1000, 500) }) } shinyApp(ui, server) The same example with the updateSliderInput functions: ui &lt;- fluidPage( sliderInput(&quot;n&quot;, &quot;N&quot;, 100, 1000, 500) ) server &lt;- function(input, output, session) { sliderValue &lt;- reactive({ # computationally intensive task Sys.sleep(3) 50 }) observeEvent(sliderValue(), { updateSliderInput( session, &quot;n&quot;, value = sliderValue() ) }) } shinyApp(ui, server) The first approach’s biggest problem is the absence of anything for 3 seconds, which may discourage the end user. Although not ideal, the second approach is already much better. Below is an very naive and dirty example where renderUI makes the entire dropdown menu re-render each time something changes in the renderUI expression, which may not be optimal. For instance in React, we only re-render what needs to be updated! Run the app below, open the HTML inspector and click to add 1 message. Notice that the entire block is updated, whereas only the corresponding HTML element should (Figure 14.1). No doubt that any advanced user see a place for insertUI. library(bs4Dash) library(tibble) new_message &lt;- tibble( message = &quot;New message&quot;, from = &quot;Paul&quot;, src = &quot;https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg&quot;, time = &quot;yesterday&quot;, status = &quot;success&quot;, type = &quot;message&quot; ) shinyApp( ui = bs4DashPage( navbar = bs4DashNavbar( rightUi = uiOutput(&quot;messages&quot;, container = tags$li) ), sidebar = bs4DashSidebar(), controlbar = bs4DashControlbar(), footer = bs4DashFooter(), title = &quot;test&quot;, body = bs4DashBody(actionButton(&quot;add&quot;, &quot;Add message&quot;)) ), server = function(input, output) { messages &lt;- reactiveValues( items = tibble( message = rep(&quot;A message&quot;, 10), from = LETTERS[1:10], src = rep(&quot;https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg&quot;, 10), time = rep(&quot;yesterday&quot;, 10), status = rep(&quot;success&quot;, 10), type = rep(&quot;message&quot;, 10) ) ) observeEvent(input$add, { messages$items &lt;- add_row(messages$items, new_message) }) output$messages &lt;- renderUI({ dropdownMenu( show = FALSE, status = &quot;danger&quot;, src = &quot;https://www.google.fr&quot;, lapply(seq_len(nrow(messages$items)), function(r) { temp &lt;- messages$items[r, ] dropdownMenuItem( message = temp$message, from = temp$from, time = temp$time, status = temp$status, type = temp$type, src = temp$src ) }) ) }) } ) FIGURE 14.1: renderUI is not specific This non specificity property justifies why you should avoid this method as much as possible, as it overloads the server. Later in this chapter, we leverage custom handlers to solve this problem. Overall, it’s more work, maybe more complex but ensures to be specific and more optimized. 14.3 Other Shiny handlers As mentioned in Chapter 12.2, all update&lt;INPUT_NAME&gt; functions are Shiny defined messages handlers. 14.3.1 The insertUI case Under the hood, insertUI sends a R message through session$sendInsertUI, via the websocket: session$sendInsertUI( selector = selector, multiple = multiple, where = where, content = processDeps(ui, session) ) sendInsertUI = function(selector, multiple, where, content) { private$sendMessage( `shiny-insert-ui` = list( selector = selector, multiple = multiple, where = where, content = content ) ) } The content has been treated with shiny:::processDeps that: Finds and resolve any HTML dependency, as shown in Chapter 4. For each dependency, makes sure the corresponding files can be accessed on the server with createWebDependency and addResourcePath. Returns a list of the HTML element and dependencies. The HTML will be accessed by message.content.html and dependencies by message.content.deps. On the UI side, Shiny has a predefined message handler: addMessageHandler(&#39;shiny-insert-ui&#39;, function(message) { var targets = $(message.selector); if (targets.length === 0) { // render the HTML and deps to a null target, so // the side-effect of rendering the deps, singletons, // and &lt;head&gt; still occur console.warn(&#39;The selector you chose (&quot;&#39; + message.selector + &#39;&quot;) could not be found in the DOM.&#39;); exports.renderHtml(message.content.html, $([]), message.content.deps); } else { targets.each(function (i, target) { exports.renderContent(target, message.content, message.where); return message.multiple; }); } }) It checks whether the provided selector corresponds to multiple DOM elements. If at least 1 item is found, it calls renderContent(html, el, dependencies) that triggers renderHtml(html, el, dependencies): Processes the provided HTML (treat the head, body and singletons). Renders all given dependencies into the page’s head. Insert the HTML into the page at the position provided in the insertUI where parameter. Internally this calls the insertAdjacentHTML method. Initialize any input and bind them to the scope and send the value to the server so that output/observers are invalidated. Outputs are also bound. If this step is missed the newly inserted input won’t react, so is the related output and any observer. Keep renderContent and renderHtml in mind, we’ll use them in section 14.4.2. 14.3.2 Example Going back to the previous example, why don’t we just go for insertUI: shinyApp( ui = bs4DashPage( navbar = bs4DashNavbar( rightUi = dropdownMenu( show = FALSE, status = &quot;danger&quot;, src = &quot;https://www.google.fr&quot; ) ), sidebar = bs4DashSidebar(), controlbar = bs4DashControlbar(), footer = bs4DashFooter(), title = &quot;test&quot;, body = bs4DashBody(actionButton(&quot;add&quot;, &quot;Add dropdown item&quot;)) ), server = function(input, output, session) { observeEvent(input$add, { insertUI( selector = &quot;.dropdown-menu &gt; .dropdown-item.dropdown-footer&quot;, where = &quot;beforeBegin&quot;, ui = dropdownMenuItem( inputId = paste0(&quot;triggerAction_&quot;, input$add), message = paste(&quot;message&quot;, input$add), from = &quot;Divad Nojnarg&quot;, src = &quot;https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg&quot;, time = &quot;today&quot;, status = &quot;danger&quot;, type = &quot;message&quot; ) ) }) } ) Well, if the item is inserted, the item counter as well as the dropdown text are not, as depicted Figure 14.2! We can’t blame insertUI for this, since this is the fault of the {bs4Dash} component that actually has interconnected HTML pieces. Indeed, the dropdownMenu function generates HTML, detecting the number of dropdownMenuItem. This works well when the app fires but the component is not able to maintain an up to date state. FIGURE 14.2: insertUI is not enough specific We may fix that by adding extra insertUI() and removeUI() to replace those parts (insertUI() does not update the targeted item). Moreover, you we must set correct priority for each observeEvent (try to remove them, it will fail) to ensure that remove happens before insert. shinyApp( ui = bs4DashPage( navbar = bs4DashNavbar( rightUi = dropdownMenu( show = FALSE, status = &quot;danger&quot;, src = &quot;https://www.google.fr&quot; ) ), sidebar = bs4DashSidebar(), controlbar = bs4DashControlbar(), footer = bs4DashFooter(), title = &quot;test&quot;, body = bs4DashBody(actionButton(&quot;add&quot;, &quot;Add dropdown item&quot;)) ), server = function(input, output, session) { observeEvent(input$add, { insertUI( selector = &quot;.dropdown-menu &gt; .dropdown-item.dropdown-footer&quot;, where = &quot;beforeBegin&quot;, ui = dropdownMenuItem( inputId = paste0(&quot;triggerAction_&quot;, input$add), message = paste(&quot;message&quot;, input$add), from = &quot;Divad Nojnarg&quot;, src = &quot;https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg&quot;, time = &quot;today&quot;, status = &quot;danger&quot;, type = &quot;message&quot; ) ) }) # remove old badge observeEvent(input$add, { removeUI(selector = &quot;.badge-danger.navbar-badge&quot;) }, priority = 1) # insert new badge observeEvent(input$add, { insertUI( selector = &quot;[data-toggle=\\&quot;dropdown\\&quot;]&quot;, where = &quot;beforeEnd&quot;, ui = tags$span(class = &quot;badge badge-danger navbar-badge&quot;, input$add) ) }) # remove old text counter observeEvent(input$add, { removeUI(selector = &quot;.dropdown-item.dropdown-header&quot;) }, priority = 1) # insert new text counter observeEvent(input$add, { insertUI( selector = &quot;.dropdown-menu&quot;, where = &quot;afterBegin&quot;, ui = tags$span(class=&quot;dropdown-item dropdown-header&quot;, sprintf(&quot;%s Items&quot;, input$add)) ) }) } ) So many observeEvent for a simple action! Imagine if we had 10 similar tasks… Isn’t there a way to do all of this at once, thereby reducing the server code? In general setting priorities in observeEvent is a rather bad smell of poorly designed shiny app. It seems that we have to create our own message handler! 14.4 Custom handlers Custom handlers are a specific category of message handlers, as they are user defined. 14.4.1 Theory Shiny provides tools to ease the communication between R and JavaScript, as illustrated in section 10.2. We already discussed the usage of sendInputMessage() in the input binding section 11. The other important method is sendCustomMessage(type, message). It works by pair with the JS method Shiny.AddCustomMessageHandler, linked with the type parameter. say_hello_to_js &lt;- function(text, session = getDefaultReactiveDomain()) { session$sendCustomMessage(type = &#39;say-hello&#39;, message = text) } The JavaScript part is defined below: $(function() { Shiny.AddCustomMessageHandler(&#39;say-hello&#39;, function(message) { alert(`R says ${message} to you!`) }); }); The shiny app below will simply print a welcome message every 5 seconds. We obviously set options(shiny.trace = TRUE) so as to capture all messages sent between R and JS. Figure 14.3 summarizes the main mechanisms involved in the R to JS communication. The corresponding code may be found here. shinyAppDir(system.file(&quot;chapter6/say_hello&quot;, package = &quot;OSUICode&quot;)) FIGURE 14.3: From R to JavaScript Combining Shiny.setInputValue and Shiny.addCustomMessageHandler, here is a fun example that sets the body background as a result of a simple button click. We defined 3 JS pieces: getPokemon whose script is adapted from Colin Fay et al. (see here). This function fetch the pokeapi. data and if successful set an input value, which will be available on the R side An event listener is set to the only button of the page so that each time we click, we call getPokemon to select a random background image. input$pokeData is actually a quite complex list (deeply nested JSON) and some manipulation is done from R in the observeEvent block. Once done, we send the data back to JS through the websocket (the session object sends a message). On the JS side, the last block is a custom message handler that will add some inline CSS properties to the body element. $(function() { // Taken from Colin const getPokemon = () =&gt; { // FETCHING THE API DATA let randId = Math.floor(Math.random() * (+151 + 1 - +1)) + +1; fetch(&#39;https://pokeapi.co/api/v2/pokemon/&#39; + randId) // DEFINE WHAT HAPPENS WHEN JAVASCRIPT RECEIVES THE DATA .then((data) =&gt;{ // TURN THE DATA TO JSON data.json().then((res) =&gt; { // SEND THE JSON TO R Shiny.setInputValue(&#39;pokeData&#39;, res, {priority: &#39;event&#39;}) }) }) // DEFINE WHAT HAPPENS WHEN THERE IS AN ERROR FETCHING THE API .catch((error) =&gt; { alert(&#39;Error catching result from API&#39;) }) }; // add event listener $(&#39;#button&#39;).on(&#39;click&#39;, function() { getPokemon(); }); // update background based on R data Shiny.addCustomMessageHandler(&#39;update_background&#39;, function(message) { $(&#39;body&#39;).css({ &#39;background-image&#39;:&#39;url(&#39; + message +&#39;)&#39;, &#39;background-repeat&#39;:&#39;no-repeat&#39; }); }); }); A demonstration may be run from the {OSUICode} side package: library(OSUICode) runPokemonExample() 14.4.2 Toward custom UI management functions 14.4.2.1 An insertDropdownItem function In this example, we go back to the {bs4Dash} dropdownMenu issue, discussed earlier in the chapter. We propose a method involving only custom message handlers. insertDropdownItem &lt;- function(item, session = shiny::getDefaultReactiveDomain()) { session$sendCustomMessage(&quot;add-dropdown-item&quot;, message = as.character(item)) } We create the insertDropdownItem function with 2 parameters: item, the HTML element we want to insert in the DOM. session, used to send a message to JavaScript with session$sendCustomMessage. We don’t use processDeps as it is very unlikely that our dropdownMenuItem contains any extra dependency. item is converted to a character (important) and sent to JavaScript through the shiny session R6 object. We give it a type, that is ‘add-dropdown-item’, to be able to identify it from JavaScript with Shiny.addCustomMessageHandler. $(function() { Shiny.addCustomMessageHandler(&#39;add-dropdown-item&#39;, function(message) { // convert string to HTML var itemTag = $.parseHTML(message)[0]; $(itemTag).insertBefore($(&#39;.dropdown-item.dropdown-footer&#39;)); // since we do not re-render the dropdown, we must update its item counter var $items = $(&#39;button.dropdown-item&#39;).length; $(&#39;.dropdown-item.dropdown-header&#39;).html($items + &#39; Items&#39;); $(&#39;.nav-item.dropdown&#39;).find(&#39;.navbar-badge&#39;).html($items); }); }); We recover the sent message on the JS side with Shiny.addCustomMessageHandler, then parse the string to HTML with $.parseHTML and insert it before the footer (that is the next UI element of the dropdown body). We also update dropdown menu item counter as well as the icon text since the dropdown menu is not re-rendered. These two extra JS steps save us to create extra observeEvent on the server, as shown before. The dropdownMenu is modified so that dependencies are attached: dropdownDeps &lt;- function() { htmltools::htmlDependency( name = &quot;bs4-dropdown&quot;, version = &quot;1.0.0&quot;, src = c(file = &quot;chapter6/add-dropdown-item&quot;), script = &quot;add-dropdown-item.js&quot;, package = &quot;OSUICode&quot; ) } dropdownMenu &lt;- function(..., show = FALSE, labelText = NULL, src = NULL, status = c(&quot;primary&quot;, &quot;warning&quot;, &quot;danger&quot;, &quot;info&quot;, &quot;success&quot;), menuIcon = &quot;bell&quot;, align = &quot;right&quot;) { status &lt;- match.arg(status) items &lt;- list(...) n_items &lt;- length(items) # remove the divider from the last item #items[[n_items]][[2]] &lt;- NULL labelText &lt;- n_items tagList( dropdownDeps(), shiny::tags$li( class = if (isTRUE(show)) &quot;nav-item dropdown show&quot; else &quot;nav-item dropdown&quot;, shiny::tags$a( class = &quot;nav-link&quot;, `data-toggle` = &quot;dropdown&quot;, href = &quot;#&quot;, shiny::icon(menuIcon), shiny::tags$span( class = paste0(&quot;badge badge-&quot;, status, &quot; navbar-badge&quot;), labelText ) ), shiny::tags$div( class = if (isTRUE(show)) { sprintf(&quot;dropdown-menu dropdown-menu-lg dropdown-menu-%s show&quot;, align) } else { sprintf(&quot;dropdown-menu dropdown-menu-lg dropdown-menu-%s&quot;, align) }, shiny::tags$span( class = &quot;dropdown-item dropdown-header&quot;, paste0(n_items, &quot; Items&quot;) ), shiny::tags$div(class = &quot;dropdown-divider&quot;), ..., shiny::tags$a( class = &quot;dropdown-item dropdown-footer&quot;, href = src, target = &quot;_blank&quot;, &quot;See more&quot; ) ) ) ) } You may run the example yourself. Note we load {OSUICode} to overwrite the {bs4Dash} function: # shinyAppDir(system.file(&quot;chapter6/add-dropdown-item&quot;, package = &quot;OSUICode&quot;)) library(OSUICode) shinyApp( ui = bs4DashPage( navbar = bs4DashNavbar( rightUi = dropdownMenu( show = FALSE, status = &quot;danger&quot;, src = &quot;https://www.google.fr&quot; ) ), sidebar = bs4DashSidebar(), controlbar = bs4DashControlbar(), footer = bs4DashFooter(), title = &quot;test&quot;, body = bs4DashBody(actionButton(&quot;add&quot;, &quot;Add dropdown item&quot;)) ), server = function(input, output, session) { observeEvent(input$add, { insertDropdownItem( dropdownMenuItem( inputId = paste0(&quot;triggerAction_&quot;, input$add), message = paste(&quot;message&quot;, input$add), from = &quot;Divad Nojnarg&quot;, src = &quot;https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg&quot;, time = &quot;today&quot;, status = &quot;danger&quot;, type = &quot;message&quot; ) ) }) } ) This solution significantly lightens the server code since everything may be done on the JS side in one step. 14.4.2.2 A chat system for shinydashboardPlus User messages in {shinydashboardPlus} (latest development version) provide an easy way to create a chat system within a shiny app. userMessages hosts the main container while userMessage are the message elements. All of this is pure HTML: &lt;div class=&quot;direct-chat-msg&quot;&gt; &lt;div class=&quot;direct-chat-info clearfix&quot;&gt; &lt;span class=&quot;direct-chat-name pull-left&quot;&gt;Alexander Pierce&lt;/span&gt; &lt;span class=&quot;direct-chat-timestamp pull-right&quot;&gt;23 Jan 2:00 pm&lt;/span&gt; &lt;/div&gt; &lt;!-- /.direct-chat-info --&gt; &lt;img class=&quot;direct-chat-img&quot; src=&quot;dist/img/user1-128x128.jpg&quot; alt=&quot;message user image&quot;&gt; &lt;!-- /.direct-chat-img --&gt; &lt;div class=&quot;direct-chat-text&quot;&gt;Is this template really for free? That&#39;s unbelievable! &lt;/div&gt; &lt;!-- /.direct-chat-text --&gt; &lt;/div&gt; Figure 14.4 shows the overall output. FIGURE 14.4: Chat user interface for AdminLTE2 Given that no JavaScript API is available to handle messages, that is send/receive/edit/remove any message, we are going to design a custom R/JavaScript API step by step. 14.4.2.2.1 HTML elements The message container is a simple div element: &lt;div class=&quot;direct-chat-messages&quot;&gt;...&lt;/div&gt; where ... receives all messages. From the AdminLTE demonstration page, the class direct-chat-warning gives the yellow color to the sent messages, while received messages are always gray. In {shinydashboardPlus}, the container is defined as below: userMessages &lt;- function(..., id = NULL, status, width = 4, height = NULL) { cl &lt;- &quot;direct-chat-messages direct-chat&quot; if (!is.null(height)) shiny::validateCssUnit(height) if (!is.null(status)) { validateStatus(status) cl &lt;- paste0(cl, &quot; direct-chat-&quot;, status) } msgtag &lt;- shiny::tags$div( class = cl, ..., style = if (!is.null(height)) { sprintf(&quot;height: %s; overflow-y: auto;&quot;, height) } else { &quot;height: 100%;&quot; } ) shiny::tags$div( id = id, class = if (!is.null(width)) paste0(&quot;col-sm-&quot;, width), msgtag ) } The most important element is the id parameter that makes the link with the custom message handler on the JavaScript side. The message element is defined as: userMessage &lt;- function(..., author, date = NULL, image = NULL, type = c(&quot;sent&quot;, &quot;received&quot;)) { type &lt;- match.arg(type) messageCl &lt;- &quot;direct-chat-msg&quot; if (type == &quot;sent&quot;) messageCl &lt;- paste0(messageCl, &quot; right&quot;) # message info messageInfo &lt;- shiny::tags$div( class = &quot;direct-chat-info clearfix&quot;, shiny::tags$span( class = if (type == &quot;right&quot;) { &quot;direct-chat-name pull-right&quot; } else { &quot;direct-chat-name&quot; }, author ), if (!is.null(date)) { shiny::tags$span( class = if (type == &quot;right&quot;) { &quot;direct-chat-timestamp right&quot; } else { &quot;direct-chat-timestamp&quot; }, date ) } ) # message Text messageTxt &lt;- shiny::tags$div(class = &quot;direct-chat-text&quot;, ...) # message author image messageImg &lt;- shiny::tags$img(class = &quot;direct-chat-img&quot;, src = image) shiny::tags$div( class = messageCl, messageInfo, messageImg, messageTxt ) } There are 3 parts: The author tag, defined in the messageInfo variable. The message itself, defined in the messageTxt variable. The author image, contained in the messageImg variable. The class of the message varies depending whether it is received or sent, which actually changes its position (left or right). Note the corresponding HTML classes like direct-chat-text since we will use them in JS. 14.4.2.2.2 Handle interactions userMessages and userMessage alone only provide a static API. Let’s design an updateMessages function that offers way to update the message container. That function must allow to: Add any message to the list. Remove any existing message. Update a given message. For now, we assume to add only one message at a time. updateMessages is linked to any userMessages container by the id parameter. In order to delete/update a message, we need to define an index parameter. Don’t forget that R starts from 1 while JS starts from 0. Consequently, we have to decrease the R index by 1 so that JS receives the correct number. We must also provide a content slot so as to update any existing message content. The content has to be compatible we the userMessage structure. We expect the user to pass a list like: list( author = &quot;David&quot;, date = &quot;Now&quot;, image = &quot;https://i.pinimg.com/originals/f1/15/df/f115dfc9cab063597b1221d015996b39.jpg&quot;, type = &quot;received&quot;, text = tagList( sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) Interestingly, we may offer the ability to add input/output element in the message content (as shown above) with dependencies that are not yet made available to shiny. We therefore assume that if the content is a shiny tag or a list of shiny tags, it may contain elements with extra dependencies and leverage the processDeps function on the R side for all elements with lapply function. Finally, the message is going to be sent with session$sendCustomMessage: updateUserMessages &lt;- function(id, action = c(&quot;add&quot;, &quot;remove&quot;, &quot;update&quot;), index = NULL, content = NULL, session = shiny::getDefaultReactiveDomain()) { action &lt;- match.arg(action) content &lt;- lapply(content, function(c) { if (inherits(c, &quot;shiny.tag&quot;) || inherits(c, &quot;shiny.tag.list&quot;)) { # necessary if the user pass input/output with deps # that are not yet available in the page before inserting the new tag c &lt;- processDeps(c, session) } c }) session$sendCustomMessage( &quot;user-messages&quot;, list( id = session$ns(id), action = action, index = index, body = content ) ) } We have to send the container id so as to be able to select the good target on the JS side. Note the session$ns that actually make sure this function can work within shiny modules. As a reminder, the message handler name has to be the same on the JS side! Now we are all done for the R side but still have to design the JS interface. The first step is to create a custom message handler skeleton: Shiny.addCustomMessageHandler(&quot;user-messages&quot;, function(message) { // JS logic }); where the message parameter is actually the message sent through the R updateUserMessages function. We recall that is we send a list, it is converted into a JS object. Therefore, to access the container id element, we do: message.id and similarly for other elements. There may be nested list, for instance the message content is one, which is not very complex to handle: we simply use the . JS notation to access lower level elements, that is message.content.text for the message text. The second step is to store all message elements in variables, which may be separated by commas. This step is not mandatory but improves the code readability: Shiny.addCustomMessageHandler(&quot;user-messages&quot;, function(message) { var id = message.id, action = message.action, content = message.body, index = message.index; }); In the following we show how to process any message content. For sake of simplicity, we assume to be able to only edit the message text. As mentioned earlier, there are 2 possible cases: The text is simple text or simple HTML without any extra dependency, we do nothing more than storing it into a meaningful variable. The text is a list of shiny tags containing input/output with extra dependencies like sliderInput, we have to use the renderHtml method to correctly process the missing dependencies passed from R via processDeps in updateUserMessages. This yields: Shiny.addCustomMessageHandler(&quot;user-messages&quot;, function(message) { var id = message.id, action = message.action, content = message.body, index = message.index; if (content.hasOwnProperty(&quot;text&quot;)) { var text; if (content.text.html === undefined) { text = content.text; } else { text = Shiny.renderHtml(content.text.html, $([]), content.text.deps).html; } } }); Note the hasOwnProperty that checks whether content has a text property. Then, the next step is to consider the multiple options provided by the user (update, add, remove). We consider the simplest case, that is remove a message. We remind the reader that the action contains the user choice in updateUserMessages. What do we need to remove a given message: It’s index contained in the index variable. The container id. Remember/notice that a message has the direct-chat-msg class. Use the remove jQuery method. We therefore target the main container with $(\"#\" + id), look for its messages with find(\".direct-chat-msg\"), specify the target using eq(index - 1) (index is the R value) and apply the remove method: if (action === &quot;remove&quot;) { $(&quot;#&quot; + id).find(&quot;.direct-chat-msg&quot;).eq(index - 1).remove(); } We could add more security with console.warn whenever the user wants to delete a message that does not exist. We leave it to the reader as an exercise. The second case is to add a new message. In that case, we define new variables containing the author, the date, the image and the message type. Below is a reminder of the message HTML structure: &lt;div class=&quot;direct-chat-msg&quot;&gt; &lt;div class=&quot;direct-chat-info clearfix&quot;&gt; &lt;span class=&quot;direct-chat-name pull-left&quot;&gt;AUTHOR (TO REPLACE)&lt;/span&gt; &lt;span class=&quot;direct-chat-timestamp pull-right&quot;&gt;DATE (TO REPLACE)&lt;/span&gt; &lt;/div&gt; &lt;!-- /.direct-chat-info --&gt; &lt;img class=&quot;direct-chat-img&quot; src=&quot;IMAGE URL (TO REPLACE)&quot; alt=&quot;message user image&quot;&gt; &lt;!-- /.direct-chat-img --&gt; &lt;div class=&quot;direct-chat-text&quot;&gt;MAIN CONTENT (TO REPLACE) &lt;/div&gt; &lt;!-- /.direct-chat-text --&gt; &lt;/div&gt; In our JS logic, we use the same template and replace any relevant element (see capital letters) by the previously created variables. We might use the string interpolation but this is not compatible with all web browsers. We wrap all of these elements in a direct-chat-msg div which class may vary depending on the message type. If sent, the class is direct-chat-msg right and direct-chat-msg otherwise. The final step is to target the main container with $(\"#\" + id), look for the messages slot find(\".direct-chat-messages\") (the message container is nested in the main wrapper) and append it to the DOM. We used append which add the message at the end but could choose prepend to add on top of all other messages. This behavior may be defined by the programmer with no option for the end-user. Alternatively, the developer could expose an external parameter to control the add position. // other condition before ... else if (action === &quot;add&quot;) { var author = content.author, date = content.date, image = content.image, type = content.type; // build the new message var newMessage = &#39;&lt;div class=&quot;direct-chat-info clearfix&quot;&gt;&#39; + &#39;&lt;span class=&quot;direct-chat-name&quot;&gt;&#39; + author + &#39;&lt;/span&gt;&#39; + &#39;&lt;span class=&quot;direct-chat-timestamp&quot; style=&quot;margin-left: 4px&quot;&gt;&#39; + date + &#39;&lt;/span&gt;&#39; + &#39;&lt;/div&gt;&#39; + &#39;&lt;img class=&quot;direct-chat-img&quot; src=&quot;&#39; + image + &#39;&quot;/&gt;&#39; + &#39;&lt;div class=&quot;direct-chat-text&quot;&gt;&#39; + text + &#39;&lt;/div&gt;&#39; // build wrapper var newMessageWrapper; if (type === &quot;sent&quot;) { newMessageWrapper = &#39;&lt;div class=&quot;direct-chat-msg right&quot;&gt;&#39; + newMessage + &#39;&lt;/div&gt;&#39; } else { newMessageWrapper = &#39;&lt;div class=&quot;direct-chat-msg&quot;&gt;&#39; + newMessage + &#39;&lt;/div&gt;&#39; } // append message $(&quot;#&quot; + id).find(&quot;.direct-chat-messages&quot;).append(newMessageWrapper); } Finally, the last case is to update a given message. As stated above, we assume to only edit the message text and the date. To update the message, we target the messages container with $(\"#\" + id), look for all texts with find(\".direct-chat-text\"), refine our choice by targeting the good element with eq(index - 1), call replaceWith containing the new text element. else if (action === &quot;update&quot;) { // today&#39;s date var d = new Date(); var month = d.getMonth() + 1; var day = d.getDate(); var today = d.getFullYear() + &#39;/&#39; + ((&#39;&#39;+month).length&lt;2 ? &#39;0&#39; : &#39;&#39;) + month + &#39;/&#39; + ((&#39;&#39;+day).length&lt;2 ? &#39;0&#39; : &#39;&#39;) + day; // we assume only text may be updated. Does not make sense to modify author $(&quot;#&quot; + id) .find(&quot;.direct-chat-text&quot;) .eq(index - 1) .replaceWith(&#39;&lt;div class=&quot;direct-chat-text&quot;&gt;&lt;small class=&quot;text-red&quot;&gt;(modified: &#39; + today +&#39;)&lt;/small&gt;&lt;br&gt;&#39; + text + &#39;&lt;/div&gt;&#39;) } Don’t forget to unbind, re-initialize and bind all inputs by calling Shiny.unbindAll();, Shiny.initializeInputs(); and Shiny.bindAll();. If you ommit this part, the newly inserted input/output elements won’t work! The whole JS code may be found below: // userMessages // ------------------------------------------------------------------ // This code creates acustom handler for userMessages Shiny.addCustomMessageHandler(&quot;user-messages&quot;, function(message) { var id = message.id, action = message.action, content = message.body, index = message.index; // message text // We use Shiny.renderHtml to handle the case where the user pass input/outputs in the updated content that require a new dependency not available in the // page at startup. if (content.hasOwnProperty(&quot;text&quot;)) { var text; if (content.text.html === undefined) { text = content.text; } else { text = Shiny.renderHtml(content.text.html, $([]), content.text.deps).html; } } // unbind all Shiny.unbindAll(); if (action === &quot;remove&quot;) { $(&quot;#&quot; + id).find(&quot;.direct-chat-msg&quot;).eq(index - 1).remove(); } else if (action === &quot;add&quot;) { var author = content.author, date = content.date, image = content.image, type = content.type; // build the new message var newMessage = &#39;&lt;div class=&quot;direct-chat-info clearfix&quot;&gt;&#39; + &#39;&lt;span class=&quot;direct-chat-name&quot;&gt;&#39; + author + &#39;&lt;/span&gt;&#39; + &#39;&lt;span class=&quot;direct-chat-timestamp&quot; style=&quot;margin-left: 4px&quot;&gt;&#39; + date + &#39;&lt;/span&gt;&#39; + &#39;&lt;/div&gt;&#39; + &#39;&lt;img class=&quot;direct-chat-img&quot; src=&quot;&#39; + image + &#39;&quot;/&gt;&#39; + &#39;&lt;div class=&quot;direct-chat-text&quot;&gt;&#39; + text + &#39;&lt;/div&gt;&#39; // build wrapper var newMessageWrapper; if (type === &quot;sent&quot;) { newMessageWrapper = &#39;&lt;div class=&quot;direct-chat-msg right&quot;&gt;&#39; + newMessage + &#39;&lt;/div&gt;&#39; } else { newMessageWrapper = &#39;&lt;div class=&quot;direct-chat-msg&quot;&gt;&#39; + newMessage + &#39;&lt;/div&gt;&#39; } // append message $(&quot;#&quot; + id).find(&quot;.direct-chat-messages&quot;).append(newMessageWrapper); } else if (action === &quot;update&quot;) { // today&#39;s date var d = new Date(); var month = d.getMonth() + 1; var day = d.getDate(); var today = d.getFullYear() + &#39;/&#39; + ((&#39;&#39;+month).length&lt;2 ? &#39;0&#39; : &#39;&#39;) + month + &#39;/&#39; + ((&#39;&#39;+day).length&lt;2 ? &#39;0&#39; : &#39;&#39;) + day; // we assume only text may be updated. Does not make sense to modify author/date $(&quot;#&quot; + id) .find(&quot;.direct-chat-text&quot;) .eq(index - 1) .replaceWith(&#39;&lt;div class=&quot;direct-chat-text&quot;&gt;&lt;small class=&quot;text-red&quot;&gt;(modified: &#39; + today +&#39;)&lt;/small&gt;&lt;br&gt;&#39; + text + &#39;&lt;/div&gt;&#39;) } // Calls .initialize() for all of the input objects in all input bindings, // in the given scope (document) Shiny.initializeInputs(); Shiny.bindAll(); // bind all inputs/outputs }); Output is shown on Figure 14.5. To reproduce that figure, you may click on add message, then click on update message leaving the numeric input to 1. FIGURE 14.5: Chat user interface for {shinydashboardPlus} as well as a demonstration: library(shiny) shinyAppDir(system.file(&quot;vignettes-demos/userMessages&quot;, package = &quot;shinydashboardPlus&quot;)) Why can’t we use the renderContent function, thereby allowing use to remove the three extra steps (unbind, initialize and bind inputs). This would lead to a timing issue. Indeed, let’s say we first click on add message which creates one slider input and one plot output. It works well the first time since those element don’t exist for Shiny. If we remove the newly created message and click again on add, we obtain an error message Uncaught Duplicate binding for ID distPlot. The root cause is rather obvious and internal to renderContent. The later cannot be called before the target is in the DOM. It means that during some time, we actually added a second output (identical to the first one) without unbinding the first, thereby causing the duplication error. Chapter 20 provide another case study to practice custom handler design. References "],["custom-templates-selection.html", "Chapter 15 Template selection", " Chapter 15 Template selection There are numerous HTML templates all over the web. However, few may be suitable for shiny. shiny is built on top of Bootstrap 3 (HTML, CSS and Javascript framework), and changing the framework will not be a trivial endeavor. However, shinymaterial and shiny.semantic are good examples that show this is possible. shiny relies on jQuery (currently v 3.4.1 for shiny). Consequently, all templates based upon React, Vue and other Javascript framework will not be natively supported. Again, there exist some examples for React with shiny and more generally, the reactR package developed by Kent Russell and Alan Dipert from RStudio. See the github repository for more details about all dependencies related to the shiny package. Notes: As shiny depends on Bootstrap 3.4.1, we recommend the user whom is interested in experimenting with Bootstrap 4 to be consciously aware of the potential incompatibilities. See a working example here with bs4Dash. A good source of open source HTML templates is Colorlib and Creative Tim. In the next chapter, we will focus on the tabler.io dashboard template (See Figure 15.1). FIGURE 15.1: Tabler dashboard overview "],["custom-templates-dependencies.html", "Chapter 16 Define dependencies 16.1 Discover the project 16.2 Identify mandatory dependencies 16.3 Bundle dependencies", " Chapter 16 Define dependencies The Tabler template is a tiny Bootstrap 4 dashboard template. In this chapter, we will describe how to customize Tabler by providing an R wrapper. In this way, the underlying JavaScript code is left untouched yet we are able to incorporate greater functionality. 16.1 Discover the project The first step of any template adaptation consists of exploring the underlying Github repository (if open source) and look for mandatory elements, like CSS/JS dependencies. This is a similar strategy if you want to incorporate an htmlWidget as well. As shown in Figure 16.1, the most important folders are: dist: contains CSS and JS files as well as other libraries like Bootstrap and jQuery. It is also a good moment to look at the version of each dependency that might conflict with Shiny. demo is the website folder used for demonstration purpose. This is our source to explore the template capabilities in depth. The scss and build folder may be used to customize the tabler template directly. However as stated above, directions on how to do so are out of scope for this book. FIGURE 16.1: Github project exploration 16.2 Identify mandatory dependencies Bootstrap 4, jQuery, tabler.min.css and tabler.min.js are key elements for the template, contrary to flag icons which are optional (and take a lot of space). If your goal is to release your template on CRAN, be mindful of the 5 Mb maximum size limit. From personal experience, I can attest that this is quite challenging to manage. To inspect dependencies, we proceed as follows Download or clone the Github repository Go to the demo folder and open the layout-dark.html file Open the HTML inspector As depicted in Figure ?? left-hand side, we need to include the tabler.min.css from the header. If you are not convinced, try to remove it from the DOM and see what happens. jqvmap is actually related to an external visualization plugin used in the demo. Finally the demo.min.css file is for the demo purpose. This will not prevent the template from working, so we will skip it for now. So far so good, we only need one file thus! JavaScript dependencies are shown on the right-hand side and located at the end of the body tag. Because we will not need all chart-related dependencies like apexcharts, jquery.vmap and vmap world and may safely ignore them. We will keep the Bootstrap 4 bundle.js, jQuery core and tabler.min.js (the order is crucial). 16.3 Bundle dependencies With the help of the htmltoolsDependency function, we are going to create our main Tabler HTML dependency containing all assets to allow our template to render properly. In this example, I am going to cheat a bit: instead of handling local files, I will use a CDN (content delivery network) that hosts all necessary Tabler assets. This avoids to include all the necessary files in the R package, as well as in a github repository. tablers_deps &lt;- htmlDependency( name = &quot;tabler&quot;, version = &quot;1.0.7&quot;, # we take that of tabler, src = c(href = &quot;https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/&quot;), script = &quot;js/tabler.min.js&quot;, stylesheet = &quot;css/tabler.min.css&quot; ) I advise the reader to create one HTML dependency per element. The Bootstrap version is v4.3.1 (Shiny relies on 3.4.1) and jQuery is 3.5.0 (Shiny relies on 3.4.1). We can also use a CDN: bs4_deps &lt;- htmlDependency( name = &quot;Bootstrap&quot;, version = &quot;4.3.1&quot;, src = c(href = &quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/&quot;), script = &quot;bootstrap.bundle.min.js&quot; ) jQuery_deps &lt;- htmlDependency( name = &quot;jquery&quot;, version = &quot;3.5.0&quot;, src = c(href = &quot;https://code.jquery.com/&quot;), script = &quot;jquery-3.5.0.slim.min.js&quot; ) We finally create our dependency manager: # add all dependencies to a tag. Don&#39;t forget to set append to TRUE to preserve any existing dependency add_tabler_deps &lt;- function(tag) { # below, the order is of critical importance! deps &lt;- list(bs4_deps, tablers_deps) attachDependencies(tag, deps, append = TRUE) } Notice the dependencies order in the deps list: this will be exactly the same order in the head of the HTML page. Some libraries require to be loaded at a specific place, like the Tabler dependencies which must come after Bootstrap. It is not surprising since Tabler is built on top of Bootstrap 4. Let’s see how to use add_tabler_deps. We consider a &lt;div&gt; placeholder and check for its dependencies with findDependencies (should be NULL). Then, we wrap it with add_tabler_deps. tag &lt;- div() findDependencies(tag) ## NULL tag &lt;- add_tabler_deps(div()) findDependencies(tag) ## [[1]] ## List of 10 ## $ name : chr &quot;Bootstrap&quot; ## $ version : chr &quot;4.3.1&quot; ## $ src :List of 1 ## ..$ href: chr &quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/&quot; ## $ meta : NULL ## $ script : chr &quot;bootstrap.bundle.min.js&quot; ## $ stylesheet: NULL ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[2]] ## List of 10 ## $ name : chr &quot;tabler&quot; ## $ version : chr &quot;1.0.7&quot; ## $ src :List of 1 ## ..$ href: chr &quot;https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/&quot; ## $ meta : NULL ## $ script : chr &quot;js/tabler.min.js&quot; ## $ stylesheet: chr &quot;css/tabler.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; As shown above, our dependencies are applied to the div, in the correct order. This order is set by the list list(bs4_deps, jQuery_deps, tablers_deps) and allows use to avoid potential conflicts. If we try to run this simple tag in a shiny app, we notice that all dependencies are added to the &lt;head&gt; tag, whereas the original template loads JavaScript dependencies in the &lt;body&gt;. Unfortunately, htmltools does not allow developers to distribute dependencies in different places. Here there is no impact but for other templates like Framework7 (which is powering shinyMobile), JavaScript must be place in the body. In practice, this is challenging to guess and may only be solved by manual testing. ui &lt;- fluidPage(tag) server &lt;- function(input, output, session) {} shinyApp(ui, server) Even though the add_tabler_deps function may be applied to any tag, we will use it with the core HTML template, that remain to be designed! Would you like to see if our dependency system works? Let’s meet in the next chapter to design the main dashboard layout. "],["custom-templates-skeleton.html", "Chapter 17 Template skeleton 17.1 Identify template elements 17.2 Design the page layout 17.3 Exercises", " Chapter 17 Template skeleton The list of all available layouts is quite impressive (horizontal, vertical, compressed, right to left, dark, …). In the next steps, we will focus on the dark-compressed template. We leave the reader to try other templates as an exercise. 17.1 Identify template elements We are quite lucky since there is nothing fancy about the tabler layout. As usual, let’s inspect the layout-condensed-dark.html (in the tabler /demo folder) in Figure 17.1 FIGURE 17.1: Tabler condensed layout There are 2 main components: - the header containing the brand logo, the navigation and dropdown - the content containing the dashboard body as well as the footer Something important: the dashboard body does not mean &lt;body&gt; tag! This is all! 17.2 Design the page layout 17.2.1 The page wrapper Do you remember the structure of a basic html page seen in Chapter 1.2? Well, if not, here is a reminder. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; We actually don’t need to include the &lt;html&gt; tag since shiny will automatically do it. Below we construct a list of tags with tagList, including the head and the body. In the head we have the meta tags which has multiple purposes: describe the encoding, how to display the app on different devices. For instance apple-mobile-web-app-status-bar-style is for iOS devices mobile support. Set the favicon, which is an icon representing the website icon, that is the one you may see on the right side of the searchbar. Try twitter for instance. The page title and favicon may be changed by the developer, so they may be included as parameters of the function. If you remember, there also should be CSS in the head but nothing here! Actually, the insertion of dependencies will be achieved by our addDeps function defined in Chapter 16. Tabler comes with 2 main themes, namely white and dark, which may be applied through the &lt;body&gt; class attribute (respectively “antialiased theme-dark” and “antialiased”). The … parameter contain other template elements like the header and the dashboard body, that remain to be created. As shown in Figure 15.1 of Chapter 15, the tabler dashboard template may contain a navigation bar and a footer. As they are not mandatory, we will not create dedicated parameters and pass all elements in the …slot. tabler_page &lt;- function(..., dark = TRUE, title = NULL, favicon = NULL){ # head head_tag &lt;- tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot; width=device-width, initial-scale=1, viewport-fit=cover&quot; ), tags$meta(`http-equiv` = &quot;X-UA-Compatible&quot;, content = &quot;ie=edge&quot;), tags$title(title), tags$link( rel = &quot;preconnect&quot;, href = &quot;https://fonts.gstatic.com/&quot;, crossorigin = NA ), tags$meta(name = &quot;msapplication-TileColor&quot;, content = &quot;#206bc4&quot;), tags$meta(name = &quot;theme-color&quot;, content = &quot;#206bc4&quot;), tags$meta(name = &quot;apple-mobile-web-app-status-bar-style&quot;, content = &quot;black-translucent&quot;), tags$meta(name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot;), tags$meta(name = &quot;mobile-web-app-capable&quot;, content = &quot;yes&quot;), tags$meta(name = &quot;HandheldFriendly&quot;, content = &quot;True&quot;), tags$meta(name = &quot;MobileOptimized&quot;, content = &quot;320&quot;), tags$meta(name = &quot;robots&quot;, content = &quot;noindex,nofollow,noarchive&quot;), tags$link(rel = &quot;icon&quot;, href = favicon, type = &quot;image/x-icon&quot;), tags$link(rel = &quot;shortcut icon&quot;, href = favicon, type=&quot;image/x-icon&quot;) ) # body body_tag &lt;- tags$body( tags$div( class = paste0(&quot;antialiased &quot;, if(dark) &quot;theme-dark&quot;), style = &quot;display: block;&quot;, tags$div(class = &quot;page&quot;, ...) ) ) %&gt;% add_tabler_deps() tagList(head_tag, body_tag) } Below we quickly test if a tabler element renders well which confirms our setup is adequate. To do this, we include a random tabler element taken from the demo html page, using HTML. Let’s be clear: you should avoid as much as possible using HTML because of security issues. This also checks that our basic Shiny input/output system works as expected with a sliderInput linked to a plot output. #thematic_on() #onStop(thematic_off) ui &lt;- tabler_page( &quot;test&quot;, sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;), br(), HTML( &#39;&lt;div class=&quot;col-sm-6 col-lg-3&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;d-flex align-items-center&quot;&gt; &lt;div class=&quot;subheader&quot;&gt;Sales&lt;/div&gt; &lt;div class=&quot;ml-auto lh-1&quot;&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;a class=&quot;dropdown-toggle text-muted&quot; href=&quot;#&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Last 7 days &lt;/a&gt; &lt;div class=&quot;dropdown-menu dropdown-menu-right&quot;&gt; &lt;a class=&quot;dropdown-item active&quot; href=&quot;#&quot;&gt;Last 7 days&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Last 30 days&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Last 3 months&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;h1 mb-3&quot;&gt;75%&lt;/div&gt; &lt;div class=&quot;d-flex mb-2&quot;&gt; &lt;div&gt;Conversion rate&lt;/div&gt; &lt;div class=&quot;ml-auto&quot;&gt; &lt;span class=&quot;text-green d-inline-flex align-items-center lh-1&quot;&gt; 7% &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;icon ml-1&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; stroke-width=&quot;2&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;&gt; &lt;path stroke=&quot;none&quot; d=&quot;M0 0h24v24H0z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;3 17 9 11 13 15 21 7&quot;&gt;&lt;/polyline&gt; &lt;polyline points=&quot;14 7 21 7 21 14&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;progress progress-sm&quot;&gt; &lt;div class=&quot;progress-bar bg-blue&quot; style=&quot;width: 75%&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;75&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;75% Complete&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#39; ), title = &quot;Tabler test&quot; ) server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Ok, our info card and the shiny element work like a charm, which is a good start. Now we may focus on the aesthetics. 17.2.2 The body content In this part, we translate the dashboard body HTML code to R. As a reminder, the html2r by Alan Dipert substantially speeds up the conversion process. You copy the code in the HTML text area, click on convert and get the R shiny output. We create a function called tabler_body. The … parameter holds all the dashboard body elements and the footer is dedicated for the future tabler_footer function. tabler_body &lt;- function(..., footer = NULL) { div( class = &quot;content&quot;, div(class = &quot;container-xl&quot;, ...), tags$footer(class = &quot;footer footer-transparent&quot;, footer) ) } Let’s test it with the previous example. ui &lt;- tabler_page(tabler_body(h1(&quot;Hello World&quot;))) server &lt;- function(input, output) {} shinyApp(ui, server) Way better! 17.2.3 The footer The footer is composed of a left and right containers. We decide to create parameters left and right in which the user will be able to pass any elements. tabler_footer &lt;- function(left = NULL, right = NULL) { div( class = &quot;container&quot;, div( class = &quot;row text-center align-items-center flex-row-reverse&quot;, div(class = &quot;col-lg-auto ml-lg-auto&quot;, right), div(class = &quot;col-12 col-lg-auto mt-3 mt-lg-0&quot;, left) ) ) } All the class attributes are taken from the original HTML template. If you are already familiar with Bootstrap 4, you may easily customize the style. In short, row means that all elements will be aligned on a row, text-center amd align-items-center handle the text and content centering. flex-row-reverse display elements in a reversed order. Notice also that a row element contains columns created with the col class. The Bootstrap grid system relies on the Flexible Box Module, also known as flexbox. As above, let’s check our brand new element. ui &lt;- tabler_page( tabler_body( p(&quot;Hello World&quot;), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;, &quot;More&quot;) ) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) 17.2.4 The navbar (or header) This function is called tabler_header. In the Tabler template, the header has the navbar navbar-expand-md navbar-light classes. We don’t need the navbar-light class since we are only interested in the dark theme. As shown in Figure 17.2, the navbar is composed of 4 elements: the navbar toggler is only visible when we reduce the screen width, like on mobile devices the brand image the navigation the dropdown menus (this is not mandatory) FIGURE 17.2: Tabler header structure You may have a look at the Bootstrap 4 documentation for extra configuration and layout. Each of these element will be considered as an input parameter to the tabler_navbar function, except the navbar toggler which is a default element and must not be removed. Morever, we will only show the brand element when it is provided. The … parameter is a slot for extra elements (between the menu and dropdowns). In the following, we start by creating the main container, that is header_tag and its unique child container_tag. The latter has 4 children toggler_tag, brand_tag, dropdown_tag and navmenu_tag. In this situations, {htmltools} functions like tagAppendChild and tagAppendChildren are game changers to better organize the code and make it more maintainable. One never knows in advance how much extra feature will be added to that component. Hence being cautious at the very beginning is crucial! tabler_navbar &lt;- function(..., brand_url = NULL, brand_image = NULL, nav_menu, nav_right = NULL) { header_tag &lt;- tags$header(class = &quot;navbar navbar-expand-md&quot;) container_tag &lt;- tags$div(class = &quot;container-xl&quot;) # toggler for small devices (must not be removed) toggler_tag &lt;- tags$button( class = &quot;navbar-toggler&quot;, type = &quot;button&quot;, `data-toggle` = &quot;collapse&quot;, `data-target` = &quot;#navbar-menu&quot;, span(class = &quot;navbar-toggler-icon&quot;) ) # brand elements brand_tag &lt;- if (!is.null(brand_url) || !is.null(brand_image)) { a( href = if (!is.null(brand_url)) { brand_url } else { &quot;#&quot; }, class = &quot;navbar-brand navbar-brand-autodark d-none-navbar-horizontal pr-0 pr-md-3&quot;, if(!is.null(brand_image)) { img( src = brand_image, alt = &quot;brand Image&quot;, class = &quot;navbar-brand-image&quot; ) } ) } dropdown_tag &lt;- if (!is.null(nav_right)) { div(class = &quot;navbar-nav flex-row order-md-last&quot;, nav_right) } navmenu_tag &lt;- div( class = &quot;collapse navbar-collapse&quot;, id = &quot;navbar-menu&quot;, div( class = &quot;d-flex flex-column flex-md-row flex-fill align-items-stretch align-items-md-center&quot;, nav_menu ), if (length(list(...)) &gt; 0) { div( class = &quot;ml-md-auto pl-md-4 py-2 py-md-0 mr-md-4 order-first order-md-last flex-grow-1 flex-md-grow-0&quot;, ... ) } ) container_tag &lt;- container_tag %&gt;% tagAppendChildren( toggler_tag, brand_tag, dropdown_tag, navmenu_tag ) header_tag %&gt;% tagAppendChild(container_tag) } The navbar menu is the main component of the navbar. The … parameter is a slot for the menu items. Compared to the original tabler dashboard template where there is only the class navbar-nav, we have to add at least, the nav class to make sure items are correctly activated/inactivated. The nav-pills class is to select pills instead of basic tabs (see here), which is nothing more than a cosmetic consideration. Notice the ul tag that will contain li elements, that is the navbar items. tabler_navbar_menu &lt;- function(...) { tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } Besides, each navbar menu item could be either a simple button or contain multiple menu sub-items. For now, we only focus on simple items. 17.2.4.1 Navbar navigation The navbar is extremely important since it will drive the navigation of the template. We would like to associate each item to a separate page in the body content. This will allow us to go to a new page each time we change an item. In brief, it is very similar to the Shiny tabsetPanel function. In HTML, menu items are &lt;a&gt; tags (links) with a given href attribute pointing to a specific page located in the server files. The point with a Shiny app is that we can’t decide how to split our content into several pages. We only have app.R generating a simple HTML page. The strategy here is to create a tabbed navigation, to mimic multiple pages. Let’s see how tabset navigation works. In the menu list, all items must have: A data-toggle attribute set to tab or pill. A href or data-target attribute holding a unique id. This unique id is mandatory since it will point the menu item to the corresponding body content. Importantly, href navigation appears to be broken on shinyapps.io, RStudio Connect (all rstudio product relying on workers to spread the user load across multiple R processes). Therefore, we’ll choose the data-target attribute. On the body side, tab panels are contained in a tabset panel (simple div container), have a role attribute set to tabpanel and an id corresponding the data-target passed in the menu item. The exact match between id and data-target is mandatory, as shown in Figure 17.3. FIGURE 17.3: Tabler tabset main principle Below, we propose a possible implementation of a menu item, as well as the corresponding body tab panel. The text parameter corresponds to the nav item text displayed in the menu. We also added an optional icon and the ability to select the item at start. tabler_navbar_menu_item &lt;- function(text, tabName, icon = NULL, selected = FALSE) { item_cl &lt;- paste0(&quot;nav-link&quot;, if(selected) &quot; active&quot;) tags$li( class = &quot;nav-item&quot;, a( class = item_cl, `data-target` = paste0(&quot;#&quot;, tabName), `data-toggle` = &quot;pill&quot;, # see https://getbootstrap.com/docs/4.0/components/navs/ `data-value` = tabName, role = &quot;tab&quot;, span(class = &quot;nav-link-icon d-md-none d-lg-inline-block&quot;, icon), span(class = &quot;nav-link-title&quot;, text) ) ) } We also decided to add a fade transition effect between tabs, as per Bootstrap 4 documentation. tabler_tab_items &lt;- function(...) { div(class = &quot;tab-content&quot;, ...) } tabler_tab_item &lt;- function(tabName = NULL, ...) { div( role = &quot;tabpanel&quot;, class = &quot;tab-pane fade container-fluid&quot;, id = tabName, ... ) } What about testing this in a shiny app? ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot; ) ) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, p(&quot;Hello World&quot;) ), tabler_tab_item( tabName = &quot;tab2&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) At this point you might argue that we did not even validated the template elements. For instance, going back to the tabler_navbar_menu_item function, we find the following possible issues: What happens if the user provides an invalid tabName, ie a text that is not valid for jQuery like tab&amp;?++? What happens if the user accidentally activates 2 tabs at start? We will see later in Chapter 18 how to validate those parameter. 17.2.4.2 Fine tune tabs behavior Quite good isn’t it? You will notice however that even if the first tab is selected by default, its content is not shown. To fix this, we will apply our jQuery skills. According to the Bootstrap documentation, we must trigger the show event on the active tab at start, as well as add the classes show and active to the associated tab panel in the dashboard body. We therefore target the nav item that has the active class and if no item is found, we select the first item by default and activate its body content. $(function() { // this makes sure to trigger the show event on the active tab at start let activeTab = $(&#39;#navbar-menu .nav-link.active&#39;); // if multiple items are found if (activeTab.length &gt; 0) { let tabId = $(activeTab).attr(&#39;data-value&#39;); $(activeTab).tab(&#39;show&#39;); $(`#${tabId}`).addClass(&#39;show active&#39;); } else { $(&#39;#navbar-menu .nav-link&#39;) .first() .tab(&#39;show&#39;); } }); This script is included in the www folder of the below app. We’ll see in Chapter 19 that custom input binding may perfectly handle this situation and are preferred. #thematic_on() #onStop(thematic_off) # example with custom JS code to activate tabs shinyAppDir(system.file(&quot;chapter12/tabler_tabs&quot;, package = &quot;OSUICode&quot;)) The result is shown in Figure 17.4. I’d also suggest to include at least 1 input/output per tab, to test whether everything works properly. FIGURE 17.4: Tabler template with navbar Looks like we are done for the main template elements. Actually, wouldn’t it be better to include, at least, card containers? 17.2.5 Card containers Card are a central piece of template as they may contain visualizations, metrics and much more. Fortunately, Tabler has a large range of card containers. 17.2.5.1 Classic card What I call a classic card is like the box container of shinydashboard. The card structure has key elements: a width to control the space taken by the card in the Bootstrap grid a title, in general in the header (tabler does always not follow this rule and header is optional) a body where is the main content style elements like color statuses a footer (optional, tabler does not include this) A comprehensive list of all tabler card features may be found here. To be faster, I will copy the following HTML code in the html2R shiny app to convert it to Shiny tags &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-status-top bg-danger&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h3 class=&quot;card-title&quot;&gt;Title&lt;/h3&gt; &lt;p&gt;Some Text.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Below is the result. The next step consist in replacing all content by parameters to the tabler_card function, whenever necessary. For instance, the first &lt;div&gt; sets the width of the card. The Bootstrap grid ranges from 0 to 12, so why not creating a width parameter to control the card size. We proceed similarly for the title, status, body content. It seems reasonable to allow title to be NULL (if so, the title will not be shown), same thing for the status. Regarding the card default width, a value of six also makes sense, which would take half of the row. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, padding = NULL) { card_cl &lt;- paste0( &quot;card&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) status_tag &lt;- if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) } body_tag &lt;- div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) main_wrapper &lt;- div(class = paste0(&quot;col-md-&quot;, width)) card_wrapper &lt;- div(class = card_cl) card_wrapper &lt;- card_wrapper %&gt;% tagAppendChildren(status_tag, body_tag) main_wrapper %&gt;% tagAppendChild(card_wrapper) } In the meantime, I’d be also nice to be able to display cards in the same row. Let’s create the tabler_row: tabler_row &lt;- function(...) { div(class = &quot;row row-deck&quot;, ...) } Below, we show an example of the tabler_card function, in combination with apexcharter by dreamRs. # test the card data(&quot;economics_long&quot;) economics_long &lt;- economics_long %&gt;% group_by(variable) %&gt;% slice((n()-100):n()) spark_data &lt;- data.frame( date = Sys.Date() + 1:20, var1 = round(rnorm(20, 50, 10)), var2 = round(rnorm(20, 50, 10)), var3 = round(rnorm(20, 50, 10)) ) my_card &lt;- tabler_card( apexchartOutput(&quot;my_chart&quot;), title = &quot;My card&quot;, status = &quot;danger&quot; ) ui &lt;- tabler_page( tabler_body( tabler_row( my_card, tabler_card( apexchartOutput(&quot;spark_box&quot;), title = &quot;My card&quot;, status = &quot;success&quot; ) ) ) ) server &lt;- function(input, output) { output$my_chart &lt;- renderApexchart({ apex(data = economics_long, type = &quot;area&quot;, mapping = aes(x = date, y = value01, fill = variable)) %&gt;% ax_yaxis(decimalsInFloat = 2) %&gt;% # number of decimals to keep ax_chart(stacked = TRUE) %&gt;% ax_yaxis(max = 4, tickAmount = 4) }) output$spark_box &lt;- renderApexchart({ spark_box( data = spark_data[, c(&quot;date&quot;, &quot;var3&quot;)], title = mean(spark_data$var3), subtitle = &quot;Variable 3&quot;, color = &quot;#FFF&quot;, background = &quot;#2E93fA&quot;, title_style = list(color = &quot;#FFF&quot;), subtitle_style = list(color = &quot;#FFF&quot;) ) }) } shinyApp(ui, server) The code output is also shown in Figure 17.5. FIGURE 17.5: Tabler card component 17.2.6 Ribbons: card components Let’s finish this part by including a card component, namely the ribbon. tabler_ribbon &lt;- function(..., position = NULL, color = NULL, bookmark = FALSE) { ribbon_cl &lt;- paste0( &quot;ribbon&quot;, if (!is.null(position)) sprintf(&quot; bg-%s&quot;, position), if (!is.null(color)) sprintf(&quot; bg-%s&quot;, color), if (bookmark) &quot; ribbon-bookmark&quot; ) div(class = ribbon_cl, ...) } Integrating the freshly created ribbon component requires to modify the card structure since the ribbon is added after the body tag, and not parameter is associated with this slot. We could also modify the tabler_card function but htmltools contains tools to help us. Since the ribbon should be put after the card body (but in the card container), we may think about the tagAppendChild function, introduced in Chapter 3: # add the ribbon to a card my_card &lt;- tabler_card(title = &quot;Ribbon&quot;, status = &quot;info&quot;) str(my_card) ## List of 3 ## $ name : chr &quot;div&quot; ## $ attribs :List of 1 ## ..$ class: chr &quot;col-md-6&quot; ## $ children:List of 1 ## ..$ :List of 3 ## .. ..$ name : chr &quot;div&quot; ## .. ..$ attribs :List of 1 ## .. .. ..$ class: chr &quot;card&quot; ## .. ..$ children:List of 2 ## .. .. ..$ :List of 3 ## .. .. .. ..$ name : chr &quot;div&quot; ## .. .. .. ..$ attribs :List of 1 ## .. .. .. .. ..$ class: chr &quot;card-status-top bg-info&quot; ## .. .. .. ..$ children: list() ## .. .. .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## .. .. ..$ :List of 3 ## .. .. .. ..$ name : chr &quot;div&quot; ## .. .. .. ..$ attribs :List of 1 ## .. .. .. .. ..$ class: chr &quot;card-body&quot; ## .. .. .. ..$ children:List of 1 ## .. .. .. .. ..$ :List of 3 ## .. .. .. .. .. ..$ name : chr &quot;h3&quot; ## .. .. .. .. .. ..$ attribs :List of 1 ## .. .. .. .. .. .. ..$ class: chr &quot;card-title&quot; ## .. .. .. .. .. ..$ children:List of 1 ## .. .. .. .. .. .. ..$ : chr &quot;Ribbon&quot; ## .. .. .. .. .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## .. .. .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## - attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; my_card$children[[1]] &lt;- my_card$children[[1]] %&gt;% tagAppendChild( tabler_ribbon( icon(&quot;info-circle&quot;, class = &quot;fa-lg&quot;), bookmark = TRUE, color = &quot;red&quot; ) ) As shown above, the ribbon has been successfuly included in the card tag. Now, we check how it looks in a shiny app. ui &lt;- tabler_page( tabler_body( my_card ) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 17.6: Tabler ribbon component 17.2.7 Icons Not mentioned before but we may include fontawesome icons provided with Shiny, as well as other libraries. Moreover, Tabler has a internal svg library located here. 17.3 Exercises Consider the tab card at the very bottom of the tabler documentation. Propose an implementation of that feature. Have a look at this page. Select 2 elements and create the corresponding R functions. "],["custom-templates-testing.html", "Chapter 18 Testing and validating templates elements 18.1 Validate template functions 18.2 Testing templates elements", " Chapter 18 Testing and validating templates elements Until now, we have been building the template boilerplate, that is the main skeleton functions (page, navbar, navbar menu, …) as well as some components such as cards, ribbons, progress bars. We also exposed some techniques to substantially give more interactivity to the template, leveraging our freshly acquired JavaScript skills. Does this mean we are ready to make the template public? Not yet since some essentials steps are missing: Input validation is a crucial step toward success. Briefly, it consists in checking user inputs so that your functions fail safely and elegantly by providing meaningful error messages or warnings. This concept has already been covered in R for Data Science, Advanced R and a lot of other resources. Hence, I am not trying to reinvent the wheel and we will rely on already existing patterns, whose effectiveness is no longer to be demonstrated. Welcome to the defensive programming world! On the other hand, testing components allows to check if a functions does what it is supposed to do. Consequently, it is a proof of robustness, and increases reproducibility. It significantly reduces the mental load when it comes to start code refactoring, thereby making you feel slightly less guilty about creating breaking changes since, most of the time, your tests will be able to capture those error. 18.1 Validate template functions 18.1.1 Create your own validations Below, we will show some examples to validate user inputs. We first consider the tabler_card element from Chapter 17. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } The first thing is to think about what to validate. Here, I see at least 3 test: checking the status value checking the width value checking the padding value Writing validation tests requires knowledge about the underlying mechanisms. In our case, we must know the Bootstrap 4 grid rules and valid color statuses. The Bootstrap 4 grid ranges from 1 to 12. In other words, a card having a width of 12 will take the full page wherease, we may align 3 cards or width 4. Valid statuses are primary, secondary, success, info, danger, warning, light and dark. It is therefore pretty straightforward to validate the card width: it must be numeric and between 1 and 12. Moreover, since the template has other containers including the width parameter, we will create a function validate_width &lt;- function(width) { if (is.numeric(width)) { if (width &lt; 1 || width &gt; 12) { stop(&quot;width must belong to [1, 12], as per Bootstrap 4 grid documentation. See more at https://getbootstrap.com/docs/4.0/layout/grid/&quot;) } } else { stop(&quot;width must be numeric&quot;) } } # validate_width(-1) # validate_width(13) # validate_width(&quot;string&quot;) To check the status parameter, we save the valid statuses in a vector and take the validStatuses function from shinydashboard utils. It also make sense to create a function since this parameter is widely used among template components. Contrary to the shinydashboard function, our custom valid_status does not fail if the status is NULL since it is not a mandatory parameter. valid_statuses &lt;- c( &quot;primary&quot;, &quot;secondary&quot;, &quot;success&quot;, &quot;info&quot;, &quot;warning&quot;, &quot;danger&quot;, &quot;light&quot;, &quot;dark&quot; ) validate_status &lt;- function(status) { if (is.null(status)) { return(TRUE) } else { if (status %in% valid_statuses) { return(TRUE) } } stop(&quot;Invalid status: &quot;, status, &quot;. Valid statuses are: &quot;, paste(valid_statuses, collapse = &quot;, &quot;), &quot;.&quot;) } We finish by the padding validation. According to the Tabler documentation, there are three possible choices, namely sm, md or lg. valid_paddings &lt;- c(&quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;) validate_padding &lt;- function(padding) { if (!is.null(padding)) { if (!(padding %in% valid_paddings)) { stop(&quot;Invalid status: &quot;, padding, &quot;. Valid choices are: &quot;, paste(valid_paddings, collapse = &quot;, &quot;), &quot;.&quot;) } } } We apply all these validation to our card element. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { validate_status(status) validate_width(width) validate_padding(padding) card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } As of R 4.0.0, the stopifnot function may be a good alternative to stop. We recommend to be reasonable and not to validate every single parameter. 18.1.2 Existing utils functions 18.1.2.1 Validating tags The problem with the above approach is that it may take time to create all validation functions. Fortunately, packages like {shinydashboard} include really powerful validation functions, especially tagAssert. This function has been included in the book side package so that you may use it at any time. myTag &lt;- div(class = &quot;bg-blue&quot;) tagAssert(myTag, type = &quot;div&quot;) tagAssert(myTag, type = &quot;li&quot;) # will fail tagAssert(myTag, class = &quot;bg-blue&quot;) Importantly, tagAssert will raise an error if the condition is not fulfilled. Another function, tagMatches simply returns TRUE/FALSE. It looks for ìd, class, name and any other tag attribute like data-value. Like tagAssert, tagMatches is also available in the book side package. tagMatches(myTag, id = &quot;d&quot;) tagMatches(myTag, class = &quot;bg-blue&quot;) 18.1.2.2 Validating CSS units The validateCssUnit belongs to the Shiny exported function. It is useful to validate any parameter involving a CSS unit like width and height. There is no point to reuse what already exists and these tools will help you to be efficient for validating your template elements. 18.1.3 Example: refine navbar menu items 18.1.3.1 Avoid wrong jQuery selectors In Chapter 17, we developed the tabler_navbar_menu_item function. The tabName parameter is critical since it is responsible for driving the navigation. We must ensure that the value provided by the user is compatible with jQuery selectors conventions. To illustrate the problem, we consider the example below, where the second tab name is hello%%&amp;1: ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( inputId = &quot;mymenu&quot;, tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;hello%%&amp;1&quot; ) ) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ), tabler_tab_item( tabName = &quot;hello%%&amp;1&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;, &quot;More&quot;) ) ) ) server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Notice that we cannot see the second tab content. Below is a proposal for the validate_tab function. We first detect any punctuation in the provided input. Although not mandatory, we extract it to send a meaningful error message. We finally raise an error if any punctuation is found. validate_tabName &lt;- function(tabName) { temp &lt;- grepl(&quot;[[:punct:]]&quot;, tabName) wrong_selector &lt;- stringr::str_extract_all(tabName, &quot;[[:punct:]]&quot;)[[1]] %&gt;% stringr::str_c(collapse = &quot;&quot;) if (temp) stop(paste(&quot;Please do not use punctuation characters like&quot;, wrong_selector,&quot;in tabNames. This might cause JavaScript issues.&quot;)) } # validate_tabName(&quot;test%&quot;) # fails validate_tabName(&quot;plop&quot;) validate_tabName must be then inserted at the beginning of tabler_navbar_menu_item as well as in tabler_tab_item, the latter also relying on tabName. 18.1.3.2 Checking for multiple selected items Another issue is the possibility to have multiple selected tab items at start. Looking back at tabler_navbar_menu, this is not surprising since there are absolutely no checks! tabler_navbar_menu &lt;- function(...) { tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } A classic method to inspect items provided to tabler_navbar_menu is to capture them in a list. We extract the children of those items lapply(list(...) , \"[\", 3) (A shiny tag is a structure where the first position holds the tag name, the second is a named list of attributes and the third slot is for children). For each children we apply the shinydashboard internal function findAttribute, that allows to search for a specific attribute value in a given tag. We use the vapply to return an atomic vector (like c(1, 2), lists are vectors but recursive!) and compute the sum of the vector. Each TRUE occurrence is counted as 1 and FALSE 0. Therefore, if the latter is higher than 1, it means that the user provided more than 1 selected tab, which should subsequently raise an error. tabler_navbar_menu &lt;- function(...) { items &lt;- lapply(list(...) , `[`, 3) res &lt;- sum(vapply(items, findAttribute, &quot;class&quot;, &quot;nav-link active&quot;, FUN.VALUE = logical(1))) if (res &gt; 1) stop(&quot;Cannot have multiple selected items at start!&quot;) tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } # the code below must fail menu &lt;- tabler_navbar_menu( tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot;, selected = TRUE ) ) 18.2 Testing templates elements Imagine if one day, someone or yourself accidentally remove the width validation function, after a significant refactoring. Later, you receive a new message from github, stating that someone opened a new issue. According to the report, the card is not properly displayed although no error is thrown. Among the 400 lines of code provided, you hardly notice that the width parameter is set to 13, which is not in line with the Bootstrap 4 documentation, as it should remain between 1 and 12. You lost 10 minutes, so is your end user, which is even worse. With a proper testing pipeline, this problem could have been avoided. Ironically, writing the corresponding test takes only 2 minutes. A reference for testing functions is the {testthat} package. In short, a unit test consists in setting expectations about our function and check whether they fail or pass. For instance, with our tabler_card example, the validate_width must fail if the given width is not in the expected bounds or not numeric. We apply the test_that function with a description of the test context, followed by the expectations inside the curly brackets. test_that(&quot;validate width works&quot;, { expect_error(tabler_card(width = -1)) expect_error(tabler_card(width = 13)) expect_error(tabler_card(width = &quot;hello world&quot;)) }) ## Test passed  We then test validate_status and validate_padding. test_that(&quot;validate status works&quot;, { expect_error(tabler_card(status = &quot;toto&quot;)) }) ## Test passed 😸 test_that(&quot;validate padding works&quot;, { expect_error(tabler_card(width = &quot;xs&quot;)) }) ## Test passed 🥇 So far so good. In few lines of code, we substantially increased the robustness of our function without increasing its complexity. Now, let’s try to remove the validate_width step from the tabler_card. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { validate_status(status) validate_padding(padding) card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } test_that(&quot;validate width works&quot;, { expect_error(tabler_card(width = -1)) expect_error(tabler_card(width = 13)) expect_error(tabler_card(width = &quot;hello world&quot;)) }) Notice how the 3 above tests elegantly fail. The provided context (“validate width works”) immediately indicates the culprit, which is a game changer for debugging. 18.2.1 Testing template behavior Testing the JavaScript behavior is one of the biggest challenge to validate a template. If the R component has been carefully validated, it does not mean that its JavaScript effects are! For instance, let’s consider the tabler_progress that may be updated with update_tabler_progress: How do we check whether the progress value is correctly set? 18.2.1.1 R side Testing the R side is quite easy. Let’s recall the update_tabler_progress function: update_tabler_progress &lt;- function(id, value, session = shiny::getDefaultReactiveDomain()) { message &lt;- list(id = session$ns(id), value = value) session$sendCustomMessage(type = &quot;update-progress&quot;, message) } This function does 2 things: Captures the id of the targeted progress and its new value Sends the message the JS The test consists in checking whether we send all elements to the session. We first create a dummy session environment which contains ns to mimic the session$ns function and sendCustomMessage to test the message handler part: session &lt;- as.environment( list( ns = identity, sendCustomMessage = function(type, message) { session$lastCustomMessage &lt;- list(type = type, message = message) } ) ) Here, sendCustomMessage simply stores the last sent message in session$lastCustomMessage. We then call update_tabler_progress with some random parameters and capture the last sent message in the res variable: update_tabler_progress(id = &quot;myprogress&quot;, value = 10, session = session) res &lt;- session$lastCustomMessage Importantly, don’t forget to set the session parameter to session, otherwise, it will default to shiny::getDefaultReactiveDomain that is NULL. This is time to set expectations: res must be a list of length 2. The expected custom handler type is update-progress. The sent value is 10. The sent id is myprogress. and translate into {testthat}: test_that(&quot;update progress works&quot;, { session &lt;- as.environment( list( ns = identity, sendCustomMessage = function(type, message) { session$lastCustomMessage &lt;- list(type = type, message = message) } ) ) update_tabler_progress(id = &quot;myprogress&quot;, value = 10, session = session) res &lt;- session$lastCustomMessage expect_length(res, 2) expect_equal(res$type, &quot;update-progress&quot;) expect_length(res$message, 2) expect_equal(res$message$id, &quot;myprogress&quot;) expect_equal(res$message$value, 10) }) This test being set, it ensures to seamlessly capture any breaking change in the API. 18.2.1.2 JS side In the following, we have to test whether this piece of JS works as expected: Shiny.addCustomMessageHandler(&#39;update-progress&#39;, function(message) { $(&#39;#&#39; + message.id) .css(&#39;width&#39;, message.value +&#39;%&#39;) .attr(&#39;aria-valuenow&#39;, message.value); }); We are going to leverage the {crrry} packages developed by Colin Fay from ThinkR. Overall, {crrry} is an adaptation of {crrri} for {shiny}, which is a native Chrome Remote Interface in R using the Chrome Debugging Protocol. In other words, it provides tools to programmatically control the web browser and do many things like inspecting a web page, taking screenshots, testing… You may know {shinytest} that relies on another technology, phantomjs. The latter does not play well with Bootstrap 4 templates, that’s why we’ll not use it here. {crrry} is already introduced in the Engineering Production-Grade Shiny Apps book. The first step is to run the update_tabler_progress example locally and add the returned url to the following code. We run the app in another process with {processx}: p &lt;- processx::process$new( &quot;Rscript&quot;, c( &quot;-e&quot;, &quot;options(&#39;shiny.port&#39;= 3515);OSUICode::update_tabler_progress_example()&quot; ) ) Sys.sleep(2) p$is_alive() That way, we can run our test in the main R process, after checking that p is alive (here the app loads immediately but you may wait some time if there are computations): library(crrry) library(testthat) test &lt;- crrry::CrrryOnPage$new( chrome_bin = pagedown::find_chrome(), chrome_port = httpuv::randomPort(), url = &quot;http://localhost:3515/&quot;, headless = TRUE ) We wait Shiny to be ready: test$wait_for_shiny_ready() Note the --remote-debugging-port=31683 that gives the link to the Chrome devtools link to inspect the current app, as shown Figure 18.1. FIGURE 18.1: Tabler progress bar debug tools It is now time to write the JS testing logic. We know that moving the slider triggers the update_tabler_progress function. This is how we change the slider value, thanks to the noUiSlider API: var slider = document.getElementById(&#39;progress_value&#39;); slider.noUiSlider.set(50); We use call_js to update the slider value within our testing pipeline: test$call_js( &quot;var slider = document.getElementById(&#39;progress_value&#39;); slider.noUiSlider.set(50); &quot; ) According to Figure 18.2, the slider is properly updated, the progress bar also seems to have the expected value. FIGURE 18.2: Updated slider We recover the progress value knowing that it is contained in the aria-valuenow attribute, as a string. We have to convert it to a number with parseInt: val &lt;- test$call_js( &quot;parseInt($(&#39;#progress1&#39;).attr(&#39;aria-valuenow&#39;)); &quot; ) expect_equal(val$result$value, 50) # stop the test whenever satisfied test$stop() The test pass, meaning that our update_tabler_progress, especially the associated custom message handler, works. This test was simple and did not involve any input elements. Yet, {crrry} also support setting input values with shiny_set_input(id, value). 18.2.2 Test input bindings We decide to add more complexity and show how to test a home made input binding. We are going to test the tabler navbar JavaScript logic developed in Chapter 19.3. Before starting to test, we define the expectations: If no tabler_navbar_menu_item is selected by default, at start, the first item is selected. It must have the active class on it. We have to check whether the first &lt;a class=\"nav-link\"&gt; has the active class. Moreover, if one item is selected at start, we have to make sure this item has the active class. We have to ensure that clicking on another link switch the currently selected link so that the corresponding input on the R side is properly updated. When we call update_tabler_tab_item we have to check whether the active link is successfully changed. Each time a navbar item is active, the corresponding body tabler_tab_item must hold the active show class, to make sure the tab content is visible. Only on tab may have those classes at a time. As described above, we run our app in another R process, so as to keep the main process for the test: p &lt;- processx::process$new( &quot;Rscript&quot;, c( &quot;-e&quot;, &quot;options(&#39;shiny.port&#39;= 3515);OSUICode::update_tabler_navbar_example()&quot; ) ) Sys.sleep(2) p$is_alive() test &lt;- crrry::CrrryOnPage$new( chrome_bin = pagedown::find_chrome(), chrome_port = httpuv::randomPort(), url = &quot;http://localhost:3515/&quot;, headless = TRUE ) test$wait_for_shiny_ready() At start, no link was selected, meaning we expect the first link to be active and shown. The navbar may be targeted using the navbar-nav class and we use find to locate the active child which must have the nav-link active classes. We also control that only 1 item is selected by inspecting the length of the active nav link items. We extract its index with index which is contained in the data-value attribute: active &lt;- test$call_js(&quot;$(&#39;.navbar-nav&#39;).find(&#39;.nav-link.active&#39;).length&quot;) expect_equal(active$result$value, 1) test$wait_for_shiny_ready() res1 &lt;- test$call_js(&quot;$(&#39;.navbar-nav&#39;).find(&#39;.nav-link.active&#39;).attr(&#39;data-value&#39;)&quot;) expect_equal(res1$result$value, &quot;tab1&quot;) Now let’s see whether to body tab has the good index. We target the tab-content class and look for the element having active show classes. We recover its id which contains the tab name: res2 &lt;- test$call_js(&quot;$(&#39;.tab-content&#39;).find(&#39;.active.show&#39;).attr(&#39;id&#39;)&quot;) expect_equal(res1$result$value, res2$result$value) We programmatically change the active tab by clicking on the second link. Below we use .nav-link:eq(1) to select the second link but we could use .nav-link:not(.active) since we only have 2 links. We also recover the index of the selected link and the corresponding tab. If everything happens well, we expect their value to be 2: test$call_js(&quot;$(&#39;.navbar-nav .nav-link:eq(1)&#39;).click();&quot;) res3 &lt;- test$call_js(&quot;$(&#39;.navbar-nav&#39;).find(&#39;.nav-link.active&#39;).attr(&#39;data-value&#39;)&quot;) expect_equal(res3$result$value, &quot;tab2&quot;) test$wait_for_shiny_ready() res4 &lt;- test$call_js(&quot;$(&#39;.tab-content&#39;).find(&#39;.active.show&#39;).attr(&#39;id&#39;)&quot;) expect_equal(res3$result$value, res4$result$value) We then click on the “change tab” button, that has the update id. The latter, actually triggers update_tabler_tab_item. We also want to check its behavior and expect to be back on tab 1: test$call_js(&quot;$(&#39;#update&#39;).click();&quot;) res5 &lt;- test$call_js(&quot;$(&#39;.navbar-nav&#39;).find(&#39;.nav-link.active&#39;).attr(&#39;data-value&#39;)&quot;) expect_equal(res5$result$value, &quot;tab1&quot;) test$wait_for_shiny_ready() res6 &lt;- test$call_js(&quot;$(&#39;.tab-content&#39;).find(&#39;.active.show&#39;).attr(&#39;id&#39;)&quot;) expect_equal(res5$result$value, res6$result$value) If the test is successful, it means that the receiveMessage and setValue methods work as expected. We finally test the input value by setting its value to tab2 with shiny_set_input. All Shiny input values are stored in the Shiny.shinyapp.$inputValues object, as shown in Chapter 12: test$shiny_set_input(&quot;current_tab&quot;, &quot;tab2&quot;) tab_input &lt;- test$call_js(&quot;Shiny.shinyapp.$inputValues.current_tab&quot;) expect_equal(tab_input$result$value, &quot;tab2&quot;) test$stop() This does not effect the navbar but triggers the notification. As an exercise, we leave the reader to write a test to check the app behavior when the second tab is active at start. "],["custom-templates-inputs.html", "Chapter 19 Develop custom input widgets 19.1 Tabler action button 19.2 Toggle Switch 19.3 Navbar menu input 19.4 Exercises", " Chapter 19 Develop custom input widgets In the previous chapter, we built template dependencies, the page skeleton, as well as containers like cards. However, it would be nice to customize user interactions by integrating new inputs. In this chapter, we will apply knowledge from Chapter 11 about creating new Shiny input. 19.1 Tabler action button Let’s start with a simple input: the action button. Tabler has built-in HTML buttons with a substantial amount of custom styles, compared to the classic Shiny action button. 19.1.1 Reminders about the action button Below is the code of the actionButton input. actionButton &lt;- function (inputId, label, icon = NULL, width = NULL, ...) { value &lt;- restoreInput(id = inputId, default = NULL) tags$button( id = inputId, style = if (!is.null(width)) paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;), type = &quot;button&quot;, class = &quot;btn btn-default action-button&quot;, `data-val` = value, list(validateIcon(icon), label), ... ) } The button tag has some attributes: id, style, type, class, data-val, label and children passed via ... When the app starts, the action button has the value 0 and each click will increment its value by 1. How is this behaviour created? For each Shiny input element (radio, slider), there is an associated JavaScript file, called input binding, which you can find here. In our case, we are only interested in the action button binding: var actionButtonInputBinding = new InputBinding(); $.extend(actionButtonInputBinding, { find: function(scope) { return $(scope).find(&quot;.action-button&quot;); }, getValue: function(el) { return $(el).data(&#39;val&#39;) || 0; }, // ... other methods }); What you see above is not the whole script since we focus on the first method, that is find. It will look for all elements having the class action-button, making it possible to define multiple action buttons at the same time. Consequently, if we go back to the previous section, the actionButton has the class action-button, thereby making it visible to the binding. Interestingly, all elements having the class action-button will be considered by the same shiny input binding. 19.1.2 Application to Tabler First of all, let’s compare the tabler HTML button to the Shiny action button. &lt;button class=&quot;btn btn-primary&quot;&gt;Button&lt;/button&gt; We convert it to R. The button API contains more style and leave the reader to add extra elements as an exercise. tabler_button &lt;- function(inputId, label, status = NULL, icon = NULL, width = NULL, ...) { btn_cl &lt;- paste0( &quot;btn action-button&quot;, if (is.null(status)) { &quot; btn-primary&quot; } else { paste0(&quot; btn-&quot;, status) } ) value &lt;- restoreInput(id = inputId, default = NULL) # custom right margin if (!is.null(icon)) icon$attribs$class &lt;- paste0( icon$attribs$class, &quot; mr-1&quot; ) tags$button( id = inputId, style = if (!is.null(width)) paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;), type = &quot;button&quot;, class = btn_cl, `data-val` = value, list(icon, label), ... ) } In Tabler, the button status is mandatory, which is the reason why it is a parameter of the function. Moreover, we need to add an horizontal right margin to the icon, if provided so that the label renders well (mr-1, where m stands for margin, r is the right direction and 1 is the margin value). We assume that by default, the button wil have a blue color, that is given by btn-primary. ui &lt;- tabler_page( tabler_body( tabler_button( &quot;btn&quot;, HTML(paste(&quot;Value&quot;, textOutput(&quot;val&quot;), sep = &quot;:&quot;)), icon = icon(&quot;thumbs-up&quot;), width = &quot;25%&quot; ) ) ) server &lt;- function(input, output, session) { output$val &lt;- renderText(input$btn) } shinyApp(ui, server) We easily check that clicking on the button increments the related input. Thus, one may see how easy it is to implement a custom Tabler input button, built on top of the Shiny action button. The output is shown in Figure 19.1. FIGURE 19.1: Tabler action button As a general rule, don’t try to reinvent the wheel and see whether any existing Shiny element may be reused/adapted! 19.2 Toggle Switch We implement the toggle switch component. &lt;label class=&quot;form-check form-switch&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot; checked&gt; &lt;span class=&quot;form-check-label&quot;&gt;Option 1&lt;/span&gt; &lt;/label&gt; Notice that the tabler switch has the checkbox type, which is very similar to the Shiny checkbox (a switch is a checkbox with a different style) checkboxInput(&quot;test&quot;, &quot;Test&quot;, TRUE) Test Therefore, we should again be able to build on top of an existing input binding. We create the tabler_switch function: tabler_switch &lt;- function(inputId, label, value = FALSE, width = NULL) { value &lt;- restoreInput(id = inputId, default = value) input_tag &lt;- tags$input( id = inputId, type = &quot;checkbox&quot;, class = &quot;form-check-input&quot; ) if (!is.null(value) &amp;&amp; value) { input_tag &lt;- input_tag %&gt;% tagAppendAttributes(checked = &quot;checked&quot;) } input_wrapper &lt;- tags$label( class = &quot;form-check form-switch&quot;, style = if (!is.null(width)) { paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;) } ) input_wrapper %&gt;% tagAppendChildren( input_tag, span(class = &quot;form-check-label&quot;, label) ) } Besides, we may also create an update_tabler_switch function similar to the updateCheckboxInput. We will also need dropNulls, a function that removes all NULL elements from a list (this function is often used in all custom Shiny templates). If you remember, the sendInputMessage from R will be received by the receiveMessage method on the JavaScript side. dropNulls &lt;- function (x) { x[!vapply(x, is.null, FUN.VALUE = logical(1))] } update_tabler_switch &lt;- function (session, inputId, label = NULL, value = NULL) { message &lt;- dropNulls(list(label = label, value = value)) session$sendInputMessage(inputId, message) } In the following example, the action button toggles the switch input value when clicked, as shown in Figure 19.2. ui &lt;- tabler_page( tabler_body( fluidRow( tabler_button(&quot;update&quot;, &quot;Go!&quot;, width = &quot;25%&quot;, class = &quot;mr-2&quot;), tabler_switch(&quot;toggle&quot;, &quot;Switch&quot;, value = TRUE, width = &quot;25%&quot;) ) ) ) server &lt;- function(input, output, session) { observe(print(input$toggle)) observeEvent(input$update, { update_tabler_switch( session, &quot;toggle&quot;, value = !input$toggle ) }) } shinyApp(ui, server) FIGURE 19.2: Tabler action button updating a toggle input Et voilà! Two inputs in few minutes. 19.3 Navbar menu input As stated in Chapter 11, it is quite straightforward to bind other elements than pure inputs (HTML elements with the input tag) to Shiny. As a reminder, we created a custom input binding to detect the state of a shinydashboard box (collapsed/uncollapsed). In chapter 17, we created the tabler_navbar as well as the tabler_navbar_menu and tabler_navbar_menu_item. As in shinydashboard, it would be nice to capture the currently selected tab to be able to perform actions on the server side, updating the selected tab based on a button click. Where do we start? First of all, we add an id attribute to the tabler_navbar_menu so that it holds the corresponding input$id. Whether to use inputId or id as a parameter name is up to you, but keep in mind that inputId does not exist in HTML. tabler_navbar_menu &lt;- function(..., inputId = NULL) { tags$ul(id = inputId, class = &quot;nav nav-pills navbar-nav&quot;, ...) } The next step is the navbarMenuBinding creation. We decide to look for the navbar-nav class in the find method. Below, we describe the binding step by step. You may find the whole working code at the end of this example. find: function(scope) { return $(scope).find(&#39;.navbar-nav&#39;); } In the initialize method, we ensure that if no tab is selected at start, the first tab will be selected by default. Otherwise, we select the activated tab. We use the string interpolation to ease the insertion of JS code in strings (${menuId} .nav-link.active). initialize: function(el) { let menuId = &#39;#&#39; + $(el).attr(&#39;id&#39;); let activeTab = $(`${menuId} .nav-link.active`); // if multiple items are found if (activeTab.length &gt; 0) { let tabId = $(activeTab).attr(&#39;data-value&#39;); $(activeTab).tab(&#39;show&#39;); $(`#${tabId}`).addClass(&#39;show active&#39;); } else { $(`${menuId} .nav-link`) .first() .tab(&#39;show&#39;); } } The role of getValue is to return the currently selected tab. As a reminder, here is the tabler_navbar_menu_item function: tabler_navbar_menu_item &lt;- function(text, tabName, icon = NULL, selected = FALSE) { item_cl &lt;- paste0(&quot;nav-link&quot;, if(selected) &quot; active&quot;) tags$li( class = &quot;nav-item&quot;, a( class = item_cl, href = paste0(&quot;#&quot;, tabName), `data-toggle` = &quot;pill&quot;, # see https://getbootstrap.com/docs/4.0/components/navs/ `data-value` = tabName, role = &quot;tab&quot;, span(class = &quot;nav-link-icon d-md-none d-lg-inline-block&quot;, icon), span(class = &quot;nav-link-title&quot;, text) ) ) } From that function, the active item has is the a element with the classes nav-link active. We recover the tab value stored in the data-value attribute. A bit of jQuery will do the trick! getValue: function(el) { let activeTab = $(el).find(&#39;a&#39;).filter(&#39;nav-link active&#39;); return $(activeTab).attr(&#39;data-value&#39;); } setValue is the function allowing to update the active tab. Bootstrap 4 already has predefined methods to activate tabs. The easiest way is to select the tab by name like $('#tabMenu a[href=\"#tab1\"]').tab('show'). The receiveMessage is simply applying the setValue method. setValue: function(el, value) { let hrefVal = &#39;#&#39; + value; let menuId = $(el).attr(&#39;id&#39;); $(`#${menuId} a[href=&quot;${hrefVal}&quot;]`).tab(&#39;show&#39;); } receiveMessage: function(el, data) { this.setValue(el, data); } Besides, we have to create the update_tabler_tab_item function. update_tabler_tab_item &lt;- function(inputId, value, session = getDefaultReactiveDomain()) { session$sendInputMessage(inputId, message = value) } subscribe will tell Shiny when to change the current input value and made it available in the whole app. We may listen to multiple events, keeping in mind that events occur in the following order: hide.bs.tab (on the current active tab) show.bs.tab (on the to-be-shown tab) hidden.bs.tab (on the previous active tab, the same one as for the hide.bs.tab event) shown.bs.tab (on the newly-active just-shown tab, the same one as for the show.bs.tab event) Hence, it makes more sense to listen to shown.bs.tab (wait the current tab to be shown). subscribe: function(el, callback) { // important to use shown.bs.tab and not show.bs.tab! $(el).on(&#39;shown.bs.tab.navbarMenuBinding&#39;, function(e) { callback(); }); }, unsubscribe: function(el) { $(el).off(&#39;.navbarMenuBinding&#39;); } Below is a recap of the binding with the creation and registration included: $(function() { // Input binding let navbarMenuBinding = new Shiny.InputBinding() $.extend(navbarMenuBinding, { find: function(scope) { return $(scope).find(&#39;.navbar-nav&#39;); }, initialize: function(el) { let menuId = &#39;#&#39; + $(el).attr(&#39;id&#39;); let activeTab = $(`${menuId} .nav-link.active`); // if multiple items are found if (activeTab.length &gt; 0) { let tabId = $(activeTab).attr(&#39;data-value&#39;); $(activeTab).tab(&#39;show&#39;); $(`#${tabId}`).addClass(&#39;show active&#39;); } else { $(`${menuId} .nav-link`) .first() .tab(&#39;show&#39;); } }, // Given the DOM element for the input, return the value getValue: function(el) { let activeTab = $(el).find(&#39;a&#39;).filter(&#39;.nav-link.active&#39;); return $(activeTab).attr(&#39;data-value&#39;); }, setValue: function(el, value) { let hrefVal = &#39;#&#39; + value; let menuId = $(el).attr(&#39;id&#39;); $(`#${menuId} a[href=&quot;${hrefVal}&quot;]`).tab(&#39;show&#39;); }, receiveMessage: function(el, data) { this.setValue(el, data); }, subscribe: function(el, callback) { $(el).on(&#39;shown.bs.tab.navbarMenuBinding&#39;, function(event) { callback(); }); }, unsubscribe: function(el) { $(el).off(&#39;.navbarMenuBinding&#39;); } }); Shiny.inputBindings.register(navbarMenuBinding, &#39;navbar-menu&#39;); }); How do we include this custom input binding in our package? In the side package code, we created the following HTML dependency: tabler_custom_js &lt;- htmlDependency( name = &quot;tabler-bindings&quot;, version = &quot;1.0.7&quot;, src = c(href = &quot;tabler&quot;), package = &quot;OSUICode&quot;, script = &quot;input-bindings/navbarMenuBinding.js&quot; ) We also updated the add_tabler_deps, as below. add_tabler_deps &lt;- function(tag) { # below, the order is of critical importance! deps &lt;- list(bs4_deps, tablers_deps, tabler_custom_js) attachDependencies(tag, deps, append = TRUE) } We test the new navbar_menu binding below. ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( id = &quot;current_tab&quot;, tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot; ) ), tabler_button(&quot;update&quot;, &quot;Change tab&quot;, icon = icon(&quot;exchange-alt&quot;)) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ), tabler_tab_item( tabName = &quot;tab2&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) observeEvent(input$current_tab, { showNotification( paste(&quot;Hello&quot;, input$current_tab), type = &quot;message&quot;, duration = 1 ) }) observeEvent(input$update, { newTab &lt;- if (input$current_tab == &quot;tab1&quot;) &quot;tab2&quot; else &quot;tab1&quot; update_tabler_tab_item(&quot;current_tab&quot;, newTab) }) } shinyApp(ui, server) Here we are! 19.4 Exercises Have a look at the Tabler documentation about buttons and extend the tabler_button function accordingly. Propose an implementation of the Advanced selectboxes shown here. Cards are a central elements of all templates. So are tabset panels. Improve the tab_card function developed in exercise 1 of Chapter 17 so that one may easily recover the currently selected tab. Hint: a custom input binding is required. "],["custom-templates-interactivity.html", "Chapter 20 Adding more interactivity 20.1 Custom progress bars 20.2 User feedback: toasts 20.3 Transform an element in a custom action button 20.4 Tab events 20.5 Exercises", " Chapter 20 Adding more interactivity In this part, we are going to add more life to the template element. We first see how to enhance an existing static HTML component. Then we will explore complex feedback mechanisms to provide more interactivity to your app. All the JavaScript handlers described below are gathered in an HTML dependency, as well as the custom input binding(s). # contains bindings and other JS code tabler_custom_js &lt;- htmlDependency( name = &quot;tabler-bindings&quot;, version = &quot;1.0.7&quot;, src = c(href = &quot;tabler&quot;), package = &quot;OSUICode&quot;, script = c( &quot;input-bindings/navbarMenuBinding.js&quot;, &quot;tabler_progress_handler.js&quot;, &quot;tabler_toast_handler.js&quot;, &quot;tabler_dropdown_handler.js&quot;, &quot;tabler_insert_tab_handler.js&quot; ) ) 20.1 Custom progress bars Progress bars are a good way to display metric related to a progress, for instance tracking the number of remaining tasks for a project. In general, those elements are static HTML. Hence, it would be interesting to be able to update the current value from the server side. Since it is not an proper input element, implementing an input binding is inappropriate and we decide to proceed with the sendCustomMessage/addCustomMessageHandler pair. We first create the tabler_progress tag which is mainly composed of: style gives the current progress value. This is the main element min and max are bounds, in general between 0 and 100 id ensures the progress bar uniqueness, thereby avoiding conflicts tabler_progress &lt;- function(id = NULL, value) { div( class = &quot;progress&quot;, div( id = id, class = &quot;progress-bar&quot;, style = paste0(&quot;width: &quot;, value, &quot;%&quot;), role = &quot;progressbar&quot;, `aria-valuenow` = as.character(value), `aria-valuemin` = &quot;0&quot;, `aria-valuemax` = &quot;100&quot;, span(class = &quot;sr-only&quot;, &quot;38% Complete&quot;) ) ) } update_tabler_progress &lt;- function(id, value, session = shiny::getDefaultReactiveDomain()) { message &lt;- list(id = session$ns(id), value = value) session$sendCustomMessage(type = &quot;update-progress&quot;, message) } The next element is the update_tabler_progress function which sends 2 elements from R to JS: The progress id The new value On the JS side, we have a basic addCustomMessageHandler. As mentioned in Chapter 9, sendCustomMessage and addCustomMessageHandler are connected by the type parameter. This is crucial! Moreover, as the sent message is a R list, it becomes an JSON, meaning that elements must be accessed with a . in JS: $(function () { Shiny.addCustomMessageHandler(&#39;update-progress&#39;, function(message) { $(&#39;#&#39; + message.id).css(&#39;width&#39;, message.value +&#39;%&#39;); }); }); We finally test these components in a simple app, whom output is depicted in Figure 20.1: ui &lt;- tabler_page( tabler_body( noUiSliderInput( inputId = &quot;progress_value&quot;, label = &quot;Progress value&quot;, min = 0, max = 100, value = 20 ), tabler_progress(id = &quot;progress1&quot;, 12) ) ) server &lt;- function(input, output, session) { observeEvent(input$progress_value, { update_tabler_progress( id = &quot;progress1&quot;, input$progress_value ) }) } shinyApp(ui, server) FIGURE 20.1: Progress bar component updated by a slider NOTE: How to handle custom messages in shiny modules? Well, it is pretty straightforward: we wrap any id with the module namespace given by session$ns() before sending it to JS. You may even do it by default (without modules) like in the previous example since session$ns() will be \"\". Is there a way to directly update the progress from the client which would avoid to exchange data between R and JS, thereby saving some time? The idea is to get rid of the classic session$sendCustomMessage and Shiny.addCustomMessageHandler method. We could directly create a function that insert a script in the UI taking a trigger and target as main parameters. This function would have to be inserted multiple times if multiple triggers had to update the same target. The JS logic is slightly different: We have to wait for shiny to be connected so that all inputs/bindings are ready We recover the trigger element with any JS/jQuery method We leverage the noUiSlider API to listen to any update in the range. It’s fine because the slider instance has already been initialized/defined in the shinyWidget input binding. This would not work if we were not waiting for shiny to be connected (you may try)! Notice the use of this.get() in the event listener, which avoids to repeat slider.noUiSlider We modify the width CSS property of the target like in the previous example $(document).on(&#39;shiny:connected&#39;, function(event) { var slider = document.getElementById(&#39;triggerId&#39;); slider.noUiSlider.on(&#39;update&#39;, function(event) { $(&#39;#targetId&#39;).css(&#39;width&#39;, this.get() + &#39;%&#39;); }); }); update_tabler_progress2 &lt;- function(trigger, target) { tags$head( tags$script( paste0( &quot;$(document).on(&#39;shiny:connected&#39;, function(event) { var slider = document.getElementById(&#39;&quot;, trigger, &quot;&#39;); slider.noUiSlider.on(&#39;update&#39;, function(event) { $(&#39;#&quot;, target, &quot;&#39;).css(&#39;width&#39;, this.get() + &#39;%&#39;); }); }); &quot; ) ) ) } ui &lt;- tabler_page( update_tabler_progress2(&quot;progress_value&quot;, &quot;progress1&quot;), update_tabler_progress2(&quot;progress_value2&quot;, &quot;progress2&quot;), tabler_body( fluidRow( noUiSliderInput( inputId = &quot;progress_value&quot;, label = &quot;Progress value 1&quot;, min = 0, max = 100, value = 20 ), noUiSliderInput( inputId = &quot;progress_value2&quot;, label = &quot;Progress value 2&quot;, min = 0, max = 100, value = 80, color = &quot;red&quot; ) ), tabler_progress(id = &quot;progress1&quot;, 12), br(), br(), tabler_progress(id = &quot;progress2&quot;, 100) ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) Question: Run the above example in an external web browser, then stop the app from RStudio. Try to move both sliders. What happens for the progress bars? Compare with a classic update function. How could you explain this? Overall this way is a bit more complex since you sometimes need to know the API of the trigger to listen to the correct events. Yet, assuming a very complex app with data manipulation, tons of inputs and visualizations, everything that can be done from the client (web browser) is less work for the R server part and a better end-user experience! Building outstanding shiny apps is not only designing amazing user interfaces, it’s also about optimization and speed as mentioned by Colin Fay et al. in their book. 20.2 User feedback: toasts Toasts are components to send discrete user feedback, contrary to modals which open in the middle of the page. Toasts may open on all sides of the window and are similar to the Shiny notifications (see here). The tabler toast component is built on top of Bootstrap 4. Therefore, we will rely on this documentation. 20.2.1 Toast skeleton The skeleton is the HTML structure of the toast: &lt;div class=&quot;toast show&quot; role=&quot;alert&quot; aria-live=&quot;assertive&quot; aria-atomic=&quot;true&quot; data-autohide=&quot;false&quot; data-toggle=&quot;toast&quot;&gt; &lt;div class=&quot;toast-header&quot;&gt; &lt;span class=&quot;avatar mr-2&quot; style=&quot;background-image: url(...)&quot;&gt;&lt;/span&gt; &lt;strong class=&quot;mr-auto&quot;&gt;Mallory Hulme&lt;/strong&gt; &lt;small&gt;11 mins ago&lt;/small&gt; &lt;button type=&quot;button&quot; class=&quot;ml-2 close&quot; data-dismiss=&quot;toast&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;toast-body&quot;&gt; Hello, world! This is a toast message. &lt;/div&gt; &lt;/div&gt; Toasts are mainly composed of a header and a body. There might be a close button in case the toast does not hide itself. If multiple toasts appear one after each others, they are stacked, the latest being at the bottom of the stack. The position is controled with the style attribute like style=\"position: absolute; top: 0; right: 0;\" for a top-right placement. Accessibility parameters like aria-live are detailed here. 20.2.2 The toast API Toasts have a JS API to control their behaviour, for instance $('&lt;toast_selector&gt;').toast(option), where option is a JSON with the following fields: animation applies a CSS fade transition to the toast and is TRUE by default autohide automatically hides the toast (TRUE by default) delay is the delay to hide the toast (500 ms) There are 3 methods: hide, show and dispose (dispose ensures the toast does not appear anymore). Finally, we may fine tune the toast behavior with 4 events: show.bs.toast, shown.bs.toast, hide.bs.toast, hide.bs.toast, hidden.bs.toast (like for tabs). 20.2.3 R implementation We first create the toast skeleton. We assume our toast will hide automatically, so that we may remove the delete button as well as the data-autohide=\"false attribute. All parameters are optional except the toast id, which is required to toggle the toast: tabler_toast &lt;- function(id, title = NULL, subtitle = NULL, ..., img = NULL) { toast_header &lt;- div( class = &quot;toast-header&quot;, if (!is.null(img)) { span( class = &quot;avatar mr-2&quot;, style = sprintf(&quot;background-image: url(%s)&quot;, img) ) }, if (!is.null(title)) strong(class = &quot;mr-2&quot;, title), if (!is.null(subtitle)) tags$small(subtitle) ) toast_body &lt;- div(class = &quot;toast-body&quot;, ...) toast_wrapper &lt;- div( id = id, class = &quot;toast&quot;, role = &quot;alert&quot;, style = &quot;position: absolute; top: 0; right: 0;&quot;, `aria-live` = &quot;assertive&quot;, `aria-atomic` = &quot;true&quot;, `data-toggle` = &quot;toast&quot; ) toast_wrapper %&gt;% tagAppendChildren(toast_header, toast_body) } We create the show_tabler_toast function. Since the toast automatically hides, it does not make sense to create the hide function, as well as the dispose. show_tabler_toast &lt;- function(id, options = NULL, session = getDefaultReactiveDomain()) { message &lt;- dropNulls( list( id = id, options = options ) ) session$sendCustomMessage(type = &quot;tabler-toast&quot;, message) } The corresponding JS handler is given by: $(function() { Shiny.addCustomMessageHandler(&#39;tabler-toast&#39;, function(message) { $(`#${message.id}`) .toast(message.options) .toast(&#39;show&#39;); // add custom Shiny input to listen to the toast state $(`#${message.id}`).on(&#39;hidden.bs.toast&#39;, function() { Shiny.setInputValue(message.id, true, {priority: &#39;event&#39;}); }); }); }); We first configure the toast and show it. Notice how we chained jQuery methods (see Chapter 9)! We optionally add an event listener to capture the hidden.bs.toast event, so that we may trigger an action when the toast is closed. The input$id will be used for that purpose in combination with the Shiny.setInputValue. Notice the extra parameter {priority: 'event'}: basically, once the toast is closed, input$id will always be TRUE, thereby breaking the reactivity. Adding this extra parameter forces the evaluation of the input, although constant over time. 20.2.4 Wrap up ui &lt;- tabler_page( tabler_toast( id = &quot;toast&quot;, title = &quot;Hello&quot;, subtitle = &quot;now&quot;, &quot;Toast body&quot;, img = &quot;https://preview-dev.tabler.io/static/logo.svg&quot; ), tabler_button(&quot;launch&quot;, &quot;Go!&quot;, width = &quot;25%&quot;) ) server &lt;- function(input, output, session) { observe(print(input$toast)) observeEvent(input$launch, { removeNotification(&quot;notif&quot;) show_tabler_toast( &quot;toast&quot;, options = list( animation = FALSE, delay = 3000 ) ) }) observeEvent(input$toast, { showNotification( id = &quot;notif&quot;, &quot;Toast was closed&quot;, type = &quot;warning&quot;, duration = 1, ) }) } shinyApp(ui, server) FIGURE 20.2: Tabler toast element 20.3 Transform an element in a custom action button As seen in Chapter 19, any &lt;button&gt;, &lt;a&gt; element holding the action-button class may eventually become an action button. The Tabler template has dropdown menus in the navbar and we would like to transform those dropdown items in action buttons. The tabler_dropdown functions takes the following parameters: id is required by the show_tabler_dropdown (see below) function which opens the menu title is the dropdown menu name subtitle is optional text img is an optional image … hosts the tabler_dropdown_item (see below) tabler_dropdown &lt;- function(..., id = NULL, title, subtitle = NULL, img = NULL) { img_tag &lt;- if (!is.null(img)) { span( class = &quot;avatar&quot;, style = sprintf(&quot;background-image: url(%s)&quot;, img) ) } titles_tag &lt;- div( class = &quot;d-none d-xl-block pl-2&quot;, div(title), if (!is.null(subtitle)) { div(class = &quot;mt-1 small text-muted&quot;, subtitle) } ) link_tag &lt;- a( href = &quot;#&quot;, id = id, class = &quot;nav-link d-flex lh-1 text-reset p-0&quot;, `data-toggle` = &quot;dropdown&quot;, `aria-expanded` = &quot;false&quot; ) %&gt;% tagAppendChildren(img_tag, titles_tag) dropdown_tag &lt;- div( class = &quot;dropdown-menu dropdown-menu-right&quot;, `aria-labelledby` = id, ... ) div(class = &quot;nav-item dropdown&quot;) %&gt;% tagAppendChildren( link_tag, dropdown_tag ) } To convert a dropdown item in an action button , we add the action-button class as well as the id parameter to recover the corresponding input id. tabler_dropdown_item &lt;- function(..., id = NULL) { a(id = id, class = &quot;dropdown-item action-button&quot;, href = &quot;#&quot;, ...) } We finally create the show_tabler_dropdown as well as the corresponding Shiny message handler. show_tabler_dropdown &lt;- function(id, session = getDefaultReactiveDomain()) { session$sendCustomMessage(type = &quot;show-dropdown&quot;, message = id) } To show the dropdown, we use the dropdown method which is linked to the data-toggle=\"dropdown\" of tabler_dropdown. $(function() { Shiny.addCustomMessageHandler(&#39;show-dropdown&#39;, function(message) { $(`#${message}`).dropdown(&#39;show&#39;); }); }); Let’s play with it! (See Figure 20.3) ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = NULL, tabler_dropdown( id = &quot;mydropdown&quot;, title = &quot;Dropdown&quot;, subtitle = &quot;click me&quot;, tabler_dropdown_item( id = &quot;item1&quot;, &quot;Show Notification&quot; ), tabler_dropdown_item( &quot;Do nothing&quot; ) ) ), tabler_body( tabler_button(&quot;show&quot;, &quot;Open dropdown&quot;, width = &quot;25%&quot;), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) { observeEvent(input$show, { show_tabler_dropdown(&quot;mydropdown&quot;) }) observeEvent(input$item1, { showNotification( &quot;Success&quot;, type = &quot;message&quot;, duration = 2, ) }) } shinyApp(ui, server) FIGURE 20.3: Tabler dropdown element 20.4 Tab events Do you remember about the navbar element and the tabsetpanel system of Chapter 17? Navs allow to organize any app into several tabs, acting like pages. This is a powerful tool for Shiny since it is currently not straightforward to create multi-pages Shiny apps like anyone would do with a website. Navs relie on the Bootstrap4 API but we only used few JS functions. 20.4.1 Insert/Remove tabs in tabsetpanel How about dynamically inserting/removing tabs from a tabler_navbar? I chose this example since it involves extra technical details about Shiny. How do we proceed? if you remember about the tabler_navbar_menu_item and tabler_tab_item coupling, inserting a tab implies to insert the trigger in the navigation menu as well as the content in the dashboard body. Therefore, we need to know the structure of what we insert. Below is a reminder: tabler_navbar_menu_item are &lt;li&gt; elements tabler_navbar_menu_item is a &lt;div&gt; element with specific classes &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#ww&quot; data-toggle=&quot;pill&quot; data-value=&quot;ww&quot; role=&quot;tab&quot;&gt; &lt;span class=&quot;nav-link-icon d-md-none d-lg-inline-block&quot;&gt;&lt;/span&gt; &lt;span class=&quot;nav-link-title&quot;&gt;ww&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade container-fluid&quot; id=&quot;ww&quot;&gt;&lt;/div&gt; We design the insert_tabler_tab function similar to the Shiny insertTab. To handle shiny modules, we wrap the inputId in the session namespace session$ns. We create the menu item element based on the provided new tab. insert_tabler_tab &lt;- function(inputId, tab, target, position = c(&quot;before&quot;, &quot;after&quot;), select = FALSE, session = getDefaultReactiveDomain()) { inputId &lt;- session$ns(inputId) position &lt;- match.arg(position) navbar_menu_item &lt;- tags$li( class = &quot;nav-item&quot;, a( class = &quot;nav-link&quot;, href = &quot;#&quot;, `data-target` = paste0(&quot;#&quot;, session$ns(tab$attribs$id)), `data-toggle` = &quot;pill&quot;, `data-value` = tab$attribs$id, role = &quot;tab&quot;, tab$attribs$id ) ) tab &lt;- force(as.character(tab)) navbar_menu_item &lt;- force(as.character(navbar_menu_item)) message &lt;- dropNulls( list( inputId = inputId, content = tab, link = navbar_menu_item, target = target, position = position, select = select ) ) session$sendCustomMessage(type = &quot;insert-tab&quot;, message) } On the JS side, we capture the R message (list) in two elements: $divTag contains the tab content $liTag contains the tab link, ie the navigation part Depending on the position parameter, we use the insertAfter and insertBefore jQuery methods. Finally, if the newly inserted tab has to be selected, we activate the corresponding tab element with $(tablink).tab('show'). $(function() { Shiny.addCustomMessageHandler(&#39;insert-tab&#39;, function(message) { // define div and li targets let $divTag = $(message.content); let $liTag = $(message.link); if (message.position === &#39;after&#39;) { $divTag.insertAfter($(&#39;#&#39; + message.target)); $liTag.insertAfter($(&#39;[data-target=&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } else if (message.position === &#39;before&#39;) { $divTag.insertBefore($(&#39;#&#39; + message.target)); $liTag.insertBefore($(&#39;[data-target=&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } if (message.select) { // trigger a click on corresponding the new tab button. let newTabId = $divTag.attr(&#39;id&#39;); $(&#39;#&#39; + message.inputId + &#39; a[data-target=&quot;#&#39; + newTabId +&#39;&quot;]&#39;).tab(&#39;show&#39;); } }); }); insert_tabler_tab_example(1) If the tab is well inserted, we notice that the slider and the plot are not properly shown, as illustrated in Figure 20.4. FIGURE 20.4: The newly inserted tab fails to render its content! How could we explain that? It is a dependency issue: the slider input relies on a specific JS library, namely ionRangesSlider, as depicted in Figure 20.5. In our previous example, if you open the HTML inspector, the dependency is not included in the page. FIGURE 20.5: Slider dependencies. Even stranger, when we use renderUI to conditionally render the slider (note: this is a dummy example), the dependency is only included when the go button is pressed. How does Shiny includes them? ui &lt;- fluidPage( shiny::actionButton(&quot;go&quot;, &quot;Go!&quot;, class = &quot;btn-success&quot;), uiOutput(&quot;slider&quot;), plotOutput(&quot;distPlot&quot;) ) # Server logic server &lt;- function(input, output) { output$slider &lt;- renderUI({ req(input$go &gt; 0) sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ) }) output$distPlot &lt;- renderPlot({ req(input$obs) hist(rnorm(input$obs)) }) } # Complete app with UI and server components shinyApp(ui, server) Let’s look at renderUI: renderUI &lt;- function (expr, env = parent.frame(), quoted = FALSE, outputArgs = list()) { installExprFunction(expr, &quot;func&quot;, env, quoted) createRenderFunction(func, function(result, shinysession, name, ...) { if (is.null(result) || length(result) == 0) return(NULL) #processDeps(result, shinysession) result }, uiOutput, outputArgs) } The last line returned is processDeps(result, shinysession). This function is responsible to handle dependencies during run time. processDeps (R side) works with Shiny.renderContent (JS side), as already mentioned in part 14.3. The latter takes a tag element as well as an object containing its HTML code and dependencies, for instance: exports.renderContent($tag[0], { html: $tag.html(), deps: message.tag.deps }); In the following, we modify the insert_tabler_tab to include the dependencies processing step. insert_tabler_tab &lt;- function(inputId, tab, target, position = c(&quot;before&quot;, &quot;after&quot;), select = FALSE, session = getDefaultReactiveDomain()) { inputId &lt;- session$ns(inputId) position &lt;- match.arg(position) navbar_menu_item &lt;- tags$li( class = &quot;nav-item&quot;, a( class = &quot;nav-link&quot;, href = &quot;#&quot;, `data-target` = paste0(&quot;#&quot;, session$ns(tab$attribs$id)), `data-toggle` = &quot;pill&quot;, `data-value` = tab$attribs$id, role = &quot;tab&quot;, tab$attribs$id ) ) message &lt;- dropNulls( list( inputId = inputId, content = processDeps(tab, session), link = processDeps(navbar_menu_item, session), target = target, position = position, select = select ) ) session$sendCustomMessage(type = &quot;insert-tab&quot;, message) } We then apply the Shiny.renderContent method to the tab content and navigation item. $(function() { Shiny.addCustomMessageHandler(&#39;insert-tab&#39;, function(message) { // define div and li targets let $divTag = $(message.content.html); let $liTag = $(message.link.html); if (message.position === &#39;after&#39;) { $divTag.insertAfter($(&#39;#&#39; + message.target)); $liTag.insertAfter($(&#39;[data-target=&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } else if (message.position === &#39;before&#39;) { $divTag.insertBefore($(&#39;#&#39; + message.target)); $liTag.insertBefore($(&#39;[data-target=&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } // needed to render input/output in newly added tab. It takes the possible // deps and add them to the tag. Indeed, if we insert a tab, its deps are not // included in the page so it can&#39;t render properly Shiny.renderContent($liTag[0], {html: $liTag.html(), deps: message.link.deps}); Shiny.renderContent($divTag[0], {html: $divTag.html(), deps: message.content.deps}); if (message.select) { // trigger a click on corresponding the new tab button. let newTabId = $divTag.attr(&#39;id&#39;); $(&#39;#&#39; + message.inputId + &#39; a[data-target=&quot;#&#39; + newTabId +&#39;&quot;]&#39;).tab(&#39;show&#39;); } }); }); We check if our approach works as expected. insert_tabler_tab_example(2) FIGURE 20.6: processDeps and Shiny.renderContent in action. Et voila! As shown in Figure 20.6, everything is properly displayed. 20.5 Exercises Taking inspiration on the insert_tabler_tab function, write the remove_tabler_tab function. Based on the Tabler documentation, add the tabler_tooltip function. Hint: you may also check the corresponding Bootstrap 4 help. "],["workflow-charpente.html", "Chapter 21 Introduction to {charpente} 21.1 Motivations 21.2 General idea 21.3 A case study: {shinybulma} 21.4 Other tips", " Chapter 21 Introduction to {charpente} FIGURE 21.1: The {charpente} package 21.1 Motivations Translating an HTML template into an R API requires the creation of a package. As stated in Chapter 0.2, this is not a good practice to proceed as follows: ui &lt;- fluidPage( useShinydashboard(), tags$script( &quot;$(function() { let boxBinding = new Shiny.InputBinding(); $.extend(boxBinding, { initialize: function(el) { $(el).activateBox(); }, find: function(scope) { return $(scope).find(&#39;.box&#39;); }, getValue: function(el) { let isCollapsed = $(el).hasClass(&#39;collapsed-box&#39;); return {collapsed: isCollapsed}; // this will be a list in R }, setValue: function(el, value) { $(el).toggleBox(); }, receiveMessage: function(el, data) { this.setValue(el, data); $(el).trigger(&#39;change&#39;); }, subscribe: function(el, callback) { $(el).on(&#39;click&#39;, &#39;[data-widget=\\&quot;collapse\\&quot;]&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); $(el).on(&#39;change&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); }, unsubscribe: function(el) { $(el).off(&#39;.boxBinding&#39;); } }); Shiny.inputBindings.register(boxBinding, &#39;box-input&#39;); }); &quot; ), box2( title = textOutput(&quot;box_state&quot;), &quot;Box body&quot;, inputId = &quot;mybox&quot;, collapsible = TRUE, plotOutput(&quot;plot&quot;) ), actionButton(&quot;toggle_box&quot;, &quot;Toggle Box&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ req(!input$mybox$collapsed) plot(rnorm(200)) }) output$box_state &lt;- renderText({ state &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; paste(&quot;My box is&quot;, state) }) observeEvent(input$toggle_box, { updateBox2(&quot;mybox&quot;) }) } shinyApp(ui, server) Imagine if we had to repeat the process for more than twenty components. The package structure provides many advantages like: Develop a comprehensive documentation of the underlying API Design unit tests to guaranty code robustness and improve long term plan Relevant file organization 21.2 General idea {charpente} is a game changer for custom template creation. It is not yet on CRAN but has been widely used to help developing RinteRface packages. {charpente}, it drastically: Eases the import of external dependencies. Speeds up the HTML to R conversion, which is quite frankly a rather boring process, allowing to focus on the features rather than the syntax. This feature builds on top of the {html2R} shiny app by Alan Dipert, already mentioned in Chapter 3. Let’s try below with html_2_R: library(charpente) html_2_R(&#39;&lt;div class=&quot;divclass&quot; id = &quot;someid&quot;&gt;&lt;/div&gt;&#39;) ## ## ── Converting code ... ── ## ## ✓ Code converted with success. ## ℹ Copy and paste the following R code ## ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## tags$div( ## class = &quot;divclass&quot;, ## id = &quot;someid&quot; ## ) html_2_R has a prefix parameter which adds a tags$ prefix if TRUE. It is TRUE by default which prevents errors with unexported Shiny tags like nav. The second main benefice of {charpente} is the dependency management system. 21.3 A case study: {shinybulma} In the following, we’ll illustrate {charpente}’s workflow, through the R in Pharma workshop exercises focused on {shinybulma}. bulma is a more and more popular open source CSS framework for the web. Importantly, there isn’t any JavaScript helper in the bulma core. We’ll see later that the recent bulma JS provides such feature. For now, we only focus on HTML and CSS. To initialize a {charpente} package, we do: path &lt;- file.path(tempdir(), &quot;mypkg&quot;) create_charpente(path, license = &quot;mit&quot;) This sets up a minimal viable package with git and optionally github remote setup, Figure 21.2. FIGURE 21.2: Package structure for {charpente} By default, the package DESCRIPTION Imports field has shiny, htmltools and utils. {charpente} is never required to be a dependency of your package since it might be invasive. In the ./R folder, {charpente} creates a mypkg-utils.R script containing: Tools to facilitate HTML dependency management like add_dependencies (see corresponding section below), processDeps. Some validation functions mentioned in Chapter 18. 21.3.1 Build the HTML dependency The interested reader will have a look at the Getting started guide, so as to know more how to get bulma. To install bulma dependencies, there are several ways: The CDN method (content delivery network) which consists in getting dependencies from a dedicated server. Files are not stored locally which may be a problem if one does not have internet. The local method consists in downloading the production files (minified CSS). Using npm that installs bulma sources as well as production files. It means one can modify sources at anytime, which is not recommended since it would be hard to maintain. In our case, we show the two first methods, the third being out of the scope of this book. As shown in previous Chapter (custom-templates-dependencies), we could build the bulma dependency as follows: library(htmltools) bulma_deps &lt;- htmlDependency( name = ..., version = ..., src = c(href = ...), stylesheet = ... ) add_bulma_deps &lt;- function(tag) { tagList(..., ...) } but this already takes too much time. This is where {charpente} comes into play. Specifically, the create_dependency function automatically download/points to the specified dependency by just providing its name. It means you have to know what you are looking for. Best practice is to have a look at the jsdelivr website ({charpente} is built on top of jsdelivr) and find the good repository, as shown Figure 21.3. create_dependency also creates the add_&lt;DEP_NAME&gt;_deps function in a &lt;DEP_NAME&gt;--dependencies.R script and opens it. charpente_options(local = FALSE) allows to fine tune the behavior. If local is FALSE, {charpente} points to the CDN without downloading any file. It is substantially faster than the local option but requires an internet connection. Package developers will prefer the local = TRUE to ensure dependencies are always accessible. Extra parameters like tag control the downloaded version since HTML templates may have several flavors. It is always good to be able to test multiple versions and select the best option. FIGURE 21.3: jsdelivr result for bulma Once satisfied, we simply run the below code to get the latest version, or a specific version if tag is used: # CDN method create_dependency(&quot;bulma&quot;, options = charpente_options(local = FALSE)) create_dependency(&quot;bulma&quot;, tag = &quot;0.7.0&quot;, options = charpente_options(local = FALSE)) # local method (default) create_dependency(&quot;bulma&quot;) Moreover, create_dependency is able to filter all files, through the charpente_options: minified targets all files with .min, if TRUE. bundle targets all files containing .bundle, if TRUE. lite targets files with lite keyword, if TRUE. rtl target all files with .rtl, if TRUE. rtl design stands for right to left and is common in some countries for instance. You may imagine that charpente_options targets .min files by default. If you don’t find any script, you probably have to change options. For instance, some templates like Bootstrap and Framework7 have bundle.min files (charpente_options(bunlde = TRUE)), whereas bulma doesn’t. We can test our new dependency: devtools::load_all() findDependencies(add_bulma_deps(div())) which works like a charm. If you chose the local option, you also get an inst/bulma-&lt;BULMA-VERSION&gt; folder with all relevant files sorted by type. The bulma-dependencies.R script contains the newly created add_bulma_deps function, either pointing to the CDN or the local files, depending on the chosen strategy: # local dependency script output #&#39; bulma dependencies utils #&#39; #&#39; @description This function attaches bulma. dependencies to the given tag #&#39; #&#39; @param tag Element to attach the dependencies. #&#39; #&#39; @importFrom htmltools tagList htmlDependency #&#39; @export add_bulma_deps &lt;- function(tag) { bulma_deps &lt;- htmlDependency( name = &quot;bulma&quot;, version = &quot;0.9.1&quot;, src = c(file = &quot;bulma-0.9.1&quot;), stylesheet = &quot;css/bulma.min.css&quot;, package = &quot;mypkg&quot;, ) tagList(tag, bulma_deps) } # CDN dependencies #&#39; bulma dependencies utils #&#39; #&#39; @description This function attaches bulma. dependencies to the given tag #&#39; #&#39; @param tag Element to attach the dependencies. #&#39; #&#39; @importFrom htmltools tagList htmlDependency #&#39; @export add_bulma_deps &lt;- function(tag) { bulma_deps &lt;- htmlDependency( name = &quot;bulma&quot;, version = &quot;0.9.1&quot;, src = c(href = &quot;https://cdn.jsdelivr.net/npm/bulma@0.9.1/&quot;), stylesheet = &quot;css/bulma.min.css&quot; ) tagList(tag, bulma_deps) } {charpente} sets the roxygen skeleton so that you don’t have to worry about function imports. 21.3.2 Set up the minimal page template According to the bulma documentation, the starter page template is: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Hello Bulma!&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;title&quot;&gt; Hello World &lt;/h1&gt; &lt;p class=&quot;subtitle&quot;&gt; My first website with &lt;strong&gt;Bulma&lt;/strong&gt;! &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; Adding some {charpente} magic with html_2_R, we set the path parameter to /html to get the entire template. We, replace ... by the appropriate content (see above). Since the copied HTML contains double quotations marks like &lt;p class=\"subtitle\"&gt;&lt;/p&gt;, we put the string in single quotation marks. html_2_R( &#39;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Hello Bulma!&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;title&quot;&gt; Hello World &lt;/h1&gt; &lt;p class=&quot;subtitle&quot;&gt; My first website with &lt;strong&gt;Bulma&lt;/strong&gt;! &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; &#39;, path = &quot;/html&quot; ) ## ## ── Converting code ... ── ## ## ✓ Code converted with success. ## ℹ Copy and paste the following R code ## ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## tags$html( ## tags$head( ## tags$meta(charset = &quot;utf-8&quot;), ## tags$meta( ## name = &quot;viewport&quot;, ## content = &quot;width=device-width, initial-scale=1&quot; ## ), ## tags$title(&quot;Hello Bulma!&quot;), ## tags$link( ## rel = &quot;stylesheet&quot;, ## href = &quot;https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css&quot; ## ) ## ), ## tags$body(tags$section( ## class = &quot;section&quot;, ## tags$div( ## class = &quot;container&quot;, ## tags$h1( ## class = &quot;title&quot;, ## &quot;Hello World&quot; ## ), ## tags$p( ## class = &quot;subtitle&quot;, ## &quot;My first website with&quot;, ## tags$strong(&quot;Bulma&quot;), ## &quot;!&quot; ## ) ## ) ## )) ## ) Note: at run time, shiny adds html around the UI, thereby making it not necessary to include. We also don’t need the link(rel = \"stylesheet\", href = \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\") since add_bulma_deps does already attach the dependencies to the page. The prefix parameter is set to TRUE by default so that we don’t have to worry about whether tags functions are exported by shiny (see Chapter 3). The bulma_page function is defined below, that we save in the R package folder: bulma_page &lt;- function(..., title = NULL) { tagList( tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot;width=device-width, initial-scale=1&quot; ), tags$title(title) ), add_bulma_deps(tags$body(...)) ) } With some practice, going from step one to the bulma page templates literally takes three minutes, while it would have taken more than 30 minutes by hand. At any time, you may replace the dependency with another version. Be careful, since {charpente} does not make snapshots of old versions. 21.3.3 Exercise: add bulmaJS As stated in the above, bulma only contains CSS things! It means we need either to develop custom JS code to add interactivity or rely on any third party existing API. bulma JS is one of these! Using {charpente}, create a bulma js dependency. We point to vizuaalog/bulmajs since some bulmajs already exist and are not what we want. Run the following code in the R console. create_dependency(...) Notice how many files are added to the dependency. Below, we only work with notifications: Only keep notification.js and remove all the unnecessary files Only keep bulma.js that gather all plugins in 1 script. The best practice is usually to keep only what we need since some scripts may be heavy to load! Run devtools::load_all(). Modify the below code to test the newly created dependency. Hint: toggle the HTML inspector to check all appropriate dependencies are there! ui &lt;- bulma_page() server &lt;- function(input, output, session) {} shinyApp(ui, server) 21.3.4 Add custom JS Notifications are always useful to send user feedback. Shiny has a notification system through shiny::showNotification. Like Shiny, Bulma notifications are entirely built from JS (no need for any HTML code). The API works as follows: Bulma(target).notification(config) creates the notification based on a JSON option list (config). target expects a jQuery selector. show toggles the newly instantiated notification In other words the below code attaches the notification to the body: Bulma(&#39;body&#39;).notification({ body: &#39;Example notification&#39;, color: &#39;info&#39; }).show(); In the following we design the R interface and JavaScript handler (which is no more than an event listener). {charpente} has a function that creates both pieces, namely create_custom_handler: create_custom_handler(&quot;notification&quot;) We obtain the notification-handler.R script: send_notification_message &lt;- function(id = NULL, options = NULL, session = shiny::getDefaultReactiveDomain()) { message &lt;- list( # your logic ) session$sendCustomMessage(type = &quot;notification&quot;, message) } and the corresponding JavaScript piece in notification.js, derived from the {golem} add_js_handler function: $(function() { Shiny.addCustomMessageHandler(&#39;notification&#39;, function(message) { }); }); By default, the JS file is created in the srcjs directory. This is a special directory where we store all JavaScript files that depend on the package author. For instance, bulmaJS is an external dependency and is very unlikely to be edited by the package author. For that reason, it remains in the inst folder like all other external dependencies. 21.3.5 Add custom input/output bindings In part 11.2, we created better {shinydashboard} boxes that one may programmatically collapse, close and restore. Until know, there was no way to setup an input binding skeleton and one had to copy and paste each time the same code. {charpente} has a create_input_binding and create_output_binding (functions that you can also find in the development version of {golem}). Contrary to the custom handler case, create_input_binding only generate the JavaScript piece since the R part is highly variable from one input to another. To get a plug and play box input binding we call: create_input_binding(&quot;boxBinding&quot;) which gives the input-boxBinding.js script in the srcjs folder: var boxBinding = new Shiny.InputBinding(); $.extend(boxBinding, { find: function(scope) { // JS logic $(scope).find(&#39;whatever&#39;) }, getValue: function(el) { // JS code to get value }, setValue: function(el, value) { // JS code to set value }, receiveMessage: function(el, data) { // this.setValue(el, data); }, subscribe: function(el, callback) { $(el).on(&#39;click.boxBinding&#39;, function(e) { callback(); }); }, unsubscribe: function(el) { $(el).off(&#39;.boxBinding&#39;); } }); Shiny.inputBindings.register(boxBinding, &#39;shiny.whatever&#39;); This function has multiple options: initialized is FALSE by default. If TRUE, it adds an initialized method to the binding. dev adds some console.log elements whenever relevant to help in the debugging process. event is a list containing events related to the binding. By default, it generates a click event without any rate policy. To add extra events we do list(name = c(\"click\", \"whatever\"), rate_policy = c(FALSE, TRUE)). Similarly, the create_output_binding function creates a ready to use output binding JS script, in the srcjs folder (create_output_binding(\"menuOutput\")): var menuOutput = new Shiny.OutputBinding(); $.extend(menuOutput, { find: function(scope) { // JS logic $(scope).find(&#39;whatever&#39;) }, renderValue: function(el, data) { // JS logic } }); Shiny.outputBindings.register(menuOutput, &#39;shiny.whatever&#39;); 21.3.6 Organize your JS code This naturally leads us to this part which is about JS code organization. Shiny developers may have a lot of custom scripts, and it is generally a bad idea to put them all under inst. Instead, we put them in srcjs, concatenate and minify them to create one big file.min.js in the inst folder. This is better for performance since file size matter in JS. The dreamRs team developed a tool to seamlessly format, organize, validate CSS and JS code, that is {jstools}. Interestingly, it has 2 addins allowing to quickly format and validate a given JS file. remotes::install_github(&quot;dreamRs/jstools&quot;) We are going to create a second custom handler with {charpente} and reorganize the whole JS code: create_custom_handler(&quot;modal&quot;) Now there should be two JS scripts in the srcjs folder. Below, we use a compressor, namely terser, that optimizes and compresses our code for the web browser, at a price to be less human readable. It also provides source maps that are crucial to the debugging process, thereby making it possible to reconstruct the original JS code starting from a minified script: library(jstools) mypkgJS &lt;- list.files( path = &quot;srcjs&quot;, recursive = TRUE, full.names = TRUE ) # /inst is already created by create_charpente outputDir &lt;- &quot;inst/mypkg-0.0.0.9000&quot; dir.create(outputDir) # Concat + Compress + source maps ---------------------------------------------------------------- terser_file( input = mypkgJS, output = sprintf(&quot;%s/mypkg.min.js&quot;, outputDir), options = terser_options( sourceMap = list( root = &quot;../../mypkg-build&quot;, filename = &quot;mypkg.min.js&quot;, url = &quot;mypkg.min.js.map&quot;, includeSources = TRUE ) ) ) terser_file takes all raw JS files as input, generate a minified/optimized script as well as source maps available at mypkg.min.js.map. The root parameter indicates their location on the server once the shiny app running. To highlight source maps role, let’s run the below app: ui &lt;- bulma_page(title = &quot;test&quot;) server &lt;- function(input, output) {} shinyApp(ui, server) We open the developer tools and navigate to the Sources panel, as illustrated on Figure 21.4. The script mypkg.min.js is not human readable but the generated source map allows to reconstruct the original code, which location is under the mypkg-build folder. From there, we can access any mapped script and start the debugging process like setting break points. FIGURE 21.4: Source maps ease the debugging process The good new is that {charpente} can automate this task: build_js() devtools::load_all() By default build_js generates production ready JS files: Parses, compresses, mangles all JS files and concatenate them in 1 big minified file called mypkg.min.js. Creates associated source maps (default). If you don’t want to expose the code, pass source_maps = FALSE. Other options are possible. One can definitely decide to not mangle the files (easier debugging), in that case pass mangle = FALSE. The list of available options is here. If mode is dev, the files are simply aggregated and beautified. Additionally, this creates the mypkg-dependencies.R file containing the HTML dependency pointing to the newly generated JS file: #&#39; mypkg dependencies utils #&#39; #&#39; @description This function attaches mypkg dependencies to the given tag #&#39; #&#39; @param tag Element to attach the dependencies. #&#39; #&#39; @importFrom utils packageVersion #&#39; @importFrom htmltools tagList htmlDependency #&#39; @export add_mypkg_deps &lt;- function(tag) { mypkg_deps &lt;- htmlDependency( name = &quot;mypkg&quot;, version = packageVersion(&quot;mypkg&quot;), src = c(file = &quot;mypkg-0.0.0.9000&quot;), script = &quot;js/mypkg.min.js&quot;, package = &quot;mypkg&quot;, ) tagList(tag, mypkg_deps) } Switching between prod and dev automatically updates the mypkg-dependencies.R file. Note: the terser concatenates file by alphabetical order (default), which is often an issue since functions may be called in script a.js before having being defined in b.js. In practice, we don’t name our files a, b but rather init.js, component.js. The files parameters allow you to pass a customized order. See this section for an example 24.6.2. Disclaimer: there is not yet similar process for CSS. This is still work in progress. Other tools exist like {packer} by John Coene, which leverages webpack to handle JS code. 21.3.7 Combine multiple dependencies add_dependencies allows to select any dependency available in the ./R folder, provided that they follow the convention &lt;depName&gt;_dependencies.R (which is always the case if you use {charpente}): #&#39; Attach all created dependencies in the ./R directory to the provided tag #&#39; #&#39; This function only works if there are existing dependencies. Otherwise, #&#39; an error is raised. #&#39; #&#39; @param tag Tag to attach the dependencies. #&#39; @param deps Dependencies to add. Expect a vector of names. If NULL, all dependencies #&#39; are added. #&#39; @export #&#39; #&#39; @examples #&#39; \\dontrun{ #&#39; library(htmltools) #&#39; findDependencies(add_dependencies(div())) #&#39; findDependencies(add_dependencies(div(), deps = &quot;bulma&quot;)) #&#39; } add_dependencies &lt;- function(tag, deps = NULL) { if (is.null(deps)) { temp_names &lt;- list.files(&quot;./R&quot;, pattern = &quot;dependencies.R$&quot;) deps &lt;- unlist(lapply(temp_names, strsplit, split = &quot;-dependencies.R&quot;)) } if (length(deps) == 0) stop(&quot;No dependencies found.&quot;) deps &lt;- lapply(deps, function(x) { temp &lt;- eval( parse( text = sprintf(&quot;htmltools::findDependencies(add_%s_deps(htmltools::div()))&quot;, x) ) ) # this assumes all add_*_deps function only add 1 dependency temp[[1]] }) htmltools::tagList(tag, deps) } For instance add_dependencies(div(), deps = c(\"bulma\", \"bulmajs\")) adds bulma (first) and bulmajs dependencies to a div tag. You may change the order as you want since most of the time, the order matters. We update bulma_page to benefit from that feature: bulma_page &lt;- function(..., title = NULL) { tagList( tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot;width=device-width, initial-scale=1&quot; ), tags$title(title) ), add_dependencies( tags$body(...), deps = c(&quot;bulma&quot;, &quot;mypkg&quot;) ) ) } As mentioned above, add_dependencies belongs to the mypkg-utils.R script so that you don’t have to import charpente in the DESCRIPTION Imports field. 21.3.8 Other {charpente} helpers Let’s finish this section by listing other useful {charpente} tools. We know create_dependency to install an external dependency. As shown earlier, this code installs bulma dependencies: create_dependency(&quot;bulma&quot;) However, we don’t necessarily know all package versions and may need bulma 0.9.1 or bulma 0.7.0. get_dependency_versions allows to look for all existing versions: get_dependency_versions(&quot;bulma&quot;) ## ℹ Trying with https://data.jsdelivr.com/v1/package/npm/bulma ## ✓ Success! ## ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## [1] &quot;0.9.2&quot; &quot;0.9.1&quot; &quot;0.9.0&quot; &quot;0.8.2&quot; &quot;0.8.1&quot; &quot;0.8.0&quot; &quot;0.7.5&quot; &quot;0.7.4&quot; &quot;0.7.3&quot; &quot;0.7.2&quot; &quot;0.7.1&quot; &quot;0.7.0&quot; &quot;0.6.2&quot; &quot;0.6.1&quot; &quot;0.6.0&quot; ## [16] &quot;0.5.3&quot; &quot;0.5.2&quot; &quot;0.5.1&quot; &quot;0.5.0&quot; &quot;0.4.4&quot; &quot;0.4.3&quot; &quot;0.4.2&quot; &quot;0.4.1&quot; &quot;0.4.0&quot; &quot;0.3.2&quot; &quot;0.3.1&quot; &quot;0.3.0&quot; &quot;0.2.3&quot; &quot;0.2.1&quot; &quot;0.2.0&quot; ## [31] &quot;0.1.2&quot; &quot;0.1.1&quot; &quot;0.1.0&quot; &quot;0.0.28&quot; &quot;0.0.27&quot; &quot;0.0.26&quot; &quot;0.0.25&quot; &quot;0.0.24&quot; &quot;0.0.23&quot; &quot;0.0.22&quot; &quot;0.0.21&quot; &quot;0.0.20&quot; &quot;0.0.19&quot; &quot;0.0.18&quot; &quot;0.0.17&quot; ## [46] &quot;0.0.16&quot; &quot;0.0.15&quot; &quot;0.0.14&quot; &quot;0.0.13&quot; &quot;0.0.12&quot; &quot;0.0.11&quot; &quot;0.0.10&quot; &quot;0.0.9&quot; &quot;0.0.8&quot; &quot;0.0.7&quot; &quot;0.0.6&quot; &quot;0.0.5&quot; &quot;0.0.4&quot; get_dependency_versions(&quot;bulma&quot;, latest = TRUE) ## ℹ Trying with https://data.jsdelivr.com/v1/package/npm/bulma ## ✓ Success! ## ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## [1] &quot;0.9.2&quot; Specifying latest = TRUE ensures to recover the very last stable version (it excludes alpha/beta versions). You may explore also the dependency files with get_dependency_assets, even for a specific version with tag: get_dependency_assets(&quot;bulma&quot;) ## ℹ Trying with https://data.jsdelivr.com/v1/package/npm/bulma ## ✓ Success! ## ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## $url ## [1] &quot;https://cdn.jsdelivr.net/npm/bulma@0.9.2/&quot; ## ## $files ## name hash ## 1 bulma.css yImvCCH14bBb1CP+8UKH4Kq6Hd77ErtYaM4V+QSvPwc= ## 2 bulma.css.map i9ZST1s/+LQDGevUi1OlRnePnesjoYhW5PJvsUWDqok= ## 3 bulma.min.css O8SsQwDg1R10WnKJNyYgd9J3rlom+YSVcGbEF5RmfFk= ## 4 bulma-rtl.css xFqhlC3rz3OH0JlaGEBeiKIB2at5/ragR+ldLLYZzQU= ## 5 bulma-rtl.css.map Jd1QERJuvEGxAD1EPmyOdUOL7Omn2gaDx6KSgqTaIEI= ## 6 bulma-rtl.min.css OhJCKE0+noWSdE9YUEx+d+3/hdatRbf8nfFQGFCBVhU= ## ## $hasSubfolders ## [1] TRUE This is helpful to further fine tune charpente_options, as stated previously. It is indeed possible that you don’t want bundles, minified, lite or rtl versions of scripts. Internally, create_dependency relies on get_dependency_assets. get_installed_dependency allows to inspect which dependencies are installed. It only works if the dependencies were created locally, that is charpente_options(local = TRUE). Finally, one may ask how to update a given dependency. update_dependency does this, provided that the dependency is installed locally. By default, it installs the latest version of the targeted dependency. It gives a diagnosis comparing the current installed version with the latest available version. The are 3 possible cases: dependencies are up to date and update_dependency(\"bulma\") yields: ℹ Trying with https://data.jsdelivr.com/v1/package/npm/bulma ✓ Success! ────────────────────────────────────────────────────────────────────────────── Error in update_dependency(&quot;bulma&quot;) : Versions are identical The installed dependencies are outdated (we have 0.7.0 with create_dependency(\"bulma\", tag = \"0.7.0\", options = charpente_options(local = TRUE))), the function shows the targeted version as well as the last one: ℹ Trying with https://data.jsdelivr.com/v1/package/npm/bulma ✓ Success! ────────────────────────────────────────────────────────────────────────────── ℹ current version: 0.7.0 || target version: 0.9.1 || latest version: 0.9.1 ! Upgrading bulma to 0.9.1 ✓ Directory inst/bulma-0.9.1/css successfully created ! Remove existing file R/bulma-dependencies.R The last use case is a downgrade, which may be possible if the package maintainer realizes that the dependency version is too unstable. In the following, we have bulma-0.9.1 installed and downgrade to 0.7.0 with update_dependency(\"bulma\", version_target = \"0.7.0\"): ℹ Trying with https://data.jsdelivr.com/v1/package/npm/bulma ✓ Success! ────────────────────────────────────────────────────────────────────────────── ℹ current version: 0.9.1 || target version: 0.7.0 || latest version: 0.9.1 ! Downgrading bulma to 0.7.0 ✓ Directory inst/bulma-0.7.0/css successfully created ! Remove existing file R/bulma-dependencies.R 21.4 Other tips 21.4.1 Validate JavaScript We could not finish this chapter without mentioning tools to validate JavaScript code. JSHint, which comes with {jstools}. Below is an example of how to check all the shinyMobile JavaScript input bindings at once: shinyMobileJS &lt;- system.file(sprintf(&quot;shinyMobile-%s/js/shinyMobile.js&quot;, packageVersion(&quot;shinyMobile&quot;)), package = &quot;shinyMobile&quot;) jshint_file(input = shinyMobileJS, options = jshint_options(jquery = TRUE, globals = list(&quot;Shiny&quot;, &quot;app&quot;))) ## ── Checking shinyMobile.js ───────────────────────────────────────────────────── ## 51 errors found. ## - Line 34: &#39;template literal syntax&#39; is only available in ES6 (use &#39;esversion: 6&#39;). ## - Line 39: &#39;template literal syntax&#39; is only available in ES6 (use &#39;esversion: 6&#39;). ## - Line 43: &#39;template literal syntax&#39; is only available in ES6 (use &#39;esversion: 6&#39;). ## - Line 44: &#39;template literal syntax&#39; is only available in ES6 (use &#39;esversion: 6&#39;). ## - Line 123: &#39;const&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 124: &#39;const&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 137: &#39;const&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 138: &#39;const&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 139: &#39;const&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 179: &#39;template literal syntax&#39; is only available in ES6 (use &#39;esversion: 6&#39;). ## - Line 224: &#39;dialog&#39; is defined but never used. ## - Line 228: &#39;confirm&#39; is defined but never used. ## - Line 236: &#39;prompt&#39; is defined but never used. ## - Line 260: The Function constructor is a form of eval. ## - Line 385: Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function. ## - Line 388: Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function. ## - Line 419: &#39;const&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 466: Missing &#39;()&#39; invoking a constructor. ## - Line 478: Missing &#39;()&#39; invoking a constructor. ## - Line 558: Missing &#39;()&#39; invoking a constructor. ## - Line 654: Missing &#39;()&#39; invoking a constructor. ## - Line 679: Missing &#39;()&#39; invoking a constructor. ## - Line 733: Missing &#39;()&#39; invoking a constructor. ## - Line 776: Missing &#39;()&#39; invoking a constructor. ## - Line 809: Missing &#39;()&#39; invoking a constructor. ## - Line 817: Missing &#39;()&#39; invoking a constructor. ## - Line 866: Missing &#39;()&#39; invoking a constructor. ## - Line 891: Missing &#39;()&#39; invoking a constructor. ## - Line 938: Missing &#39;()&#39; invoking a constructor. ## - Line 965: Missing &#39;()&#39; invoking a constructor. ## - Line 1026: Missing &#39;()&#39; invoking a constructor. ## - Line 1095: Missing &#39;()&#39; invoking a constructor. ## - Line 1131: Missing &#39;()&#39; invoking a constructor. ## - Line 1217: Missing &#39;()&#39; invoking a constructor. ## - Line 1229: &#39;p&#39; is defined but never used. ## - Line 1257: &#39;let&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 1273: Missing &#39;()&#39; invoking a constructor. ## - Line 1345: Missing &#39;()&#39; invoking a constructor. ## - Line 1375: Missing &#39;()&#39; invoking a constructor. ## - Line 1396: &#39;s&#39; is defined but never used. ## - Line 1425: Missing &#39;()&#39; invoking a constructor. ## - Line 1445: &#39;r&#39; is defined but never used. ## - Line 1516: Missing &#39;()&#39; invoking a constructor. ## - Line 1582: Missing &#39;()&#39; invoking a constructor. ## - Line 1602: &#39;s&#39; is defined but never used. ## - Line 1724: Missing &#39;()&#39; invoking a constructor. ## - Line 1762: Missing &#39;()&#39; invoking a constructor. ## - Line 1803: Missing &#39;()&#39; invoking a constructor. ## - Line 1816: &#39;for of&#39; is available in ES6 (use &#39;esversion: 6&#39;) or Mozilla JS extensions (use moz). ## - Line 1856: &#39;template literal syntax&#39; is only available in ES6 (use &#39;esversion: 6&#39;). ## - Line 1856: Too many errors. (96% scanned). You may fine tune the jshint_file behavior with the jshint_options. One is often tempted to call eval in JS code, which will result in a JSHint error. An option called evil exists to disable the corresponding test. However, we recommend to play the game, accept those error and try to fix them instead of cheating with options! An important remark about validation is that it does not check whether your code does what it should do. It just focus on checking whether the code runs! To test the JavaScript behavior, please refer to Chapter 18.2.1.2. Be extremely careful: if we consider the example mentioned in section 9.6.2, the following code is valid JavaScript: const sendNotif = (message, type, duration) =&gt; { Shiny.notification.show({ html: `&lt;strong&gt;${message}&lt;/strong&gt;`, type: type, duration: duration }); }; sendNotif(&#39;Hello&#39;) and will pass the validation step without any error: jshint( &quot;const sendNotif = (message, type, duration) =&gt; { Shiny.notification.show({ html: `&lt;strong&gt;${message}&lt;/strong&gt;`, type: type, duration: duration }); }; sendNotif(&#39;Hello&#39;); &quot;, options = jshint_options( esversion = 6, jquery = TRUE, globals = list(&quot;Shiny&quot;, &quot;app&quot;) ) ) ## $functions ## name param line character last lastcharacter metrics.complexity metrics.parameters metrics.statements ## 1 (empty) message, type, duration 1 27 7 4 1 3 1 ## ## $options ## $options$unstable ## named list() ## ## $options$undef ## [1] TRUE ## ## $options$unused ## [1] &quot;vars&quot; ## ## $options$browser ## [1] TRUE ## ## $options$jquery ## [1] TRUE ## ## $options$devel ## [1] FALSE ## ## $options$esversion ## [1] 6 ## ## $options$globals ## [1] &quot;Shiny&quot; &quot;app&quot; ## ## $options$indent ## [1] 4 ## ## $options$maxerr ## [1] 50 ## ## ## $globals ## [1] &quot;Shiny&quot; ## ## $member ## $member$notification ## [1] 1 ## ## $member$show ## [1] 1 ## ## $member$html ## [1] 1 ## ## $member$type ## [1] 1 ## ## $member$duration ## [1] 1 ## ## ## attr(,&quot;class&quot;) ## [1] &quot;list&quot; &quot;jshint&quot; Yet the code won’t work since Shiny.notification does not exist. 21.4.2 Beautify JS code If you work with the RStudio IDE, your JS code maybe sometimes messy with bad indentation. {jstools} also provides a function and addin to fix the problem. prettier_js(code) and prettier_file(input = \"path/to/file.js\", output = \"path/to/reformated.js\") does this. I often use the Prettier addin which is way faster than typing the function call (Figure 21.5). FIGURE 21.5: Better JS formatting "],["workflow-rpg.html", "Chapter 22 A RPG game with Shiny", " Chapter 22 A RPG game with Shiny COMING SOON! "],["mobile-shiny-intro.html", "Chapter 23 Introduction 23.1 Case study objectives 23.2 About mobile development 23.3 Progressive web apps", " Chapter 23 Introduction 23.1 Case study objectives All previously mentioned templates, except framework7, are dedicated to be used on desktop. Even though most of them like {bs4Dash} work quite well on mobile platforms, you don’t get the native look and feel that you have with mobile apps like twitter, as shown on Figure 23.1. FIGURE 23.1: Twitter design on mobile devices The goal of this part is to introduce you to mobile development for Shiny. We are going to reconstruct the {shinyMobile} package with the help of {charpente} and all what we learn since the beginning of the book. 23.2 About mobile development Mobile app development consists in developing an application for mobile devices that is tablets, phones (Android, ipadOS). We call a native app when it is dedicated for the specified platform. For instance, iOS applications are developed using Objective-C or swift whereas android apps are mainly developed with Java. Those apps are faster than web apps since they exploit the full capabilities of the platform. The UI is also more consistent, they may be installed via a store (App store, google play) and work offline. The main issue is the need to know multiple languages and maintain multiple code bases. Is there something between pure web apps and native apps? 23.3 Progressive web apps 23.3.1 Introduction Progressive web apps or (PWA) improve classic web apps capabilities by being able to have a full screen display, being installable, provide a launch screen, like native apps with a consistent UI. They must obey to 3 rules: Being capable: media control, file system access, … Being reliable: fast and usable offline. Transparent failures. Being installable: Standalone use, launch from user’s home screen. 23.3.2 What does “installable” mean? There are several criteria to meet the installable state: The app must be served over HTTPS. Include a manifest: JSON file that specify app metadata like the name, short name (short_name), icons to use for user’s home screen and launch screen (displayed image before the first paint), the start url (start_url), the display mode (generally standalone), the splash screen background color (background_color)… Have a registered service worker, which can cache the app content, thereby making sure to provide offline features. Once all criteria are fulfilled, the web browser shows an installation toast to start the process. 23.3.3 How to develop a PWA? Nowadays, there exist tools to develop native looking apps with a common language, JavaScript. This is the case of Framework7. {shinyMobile} (Figure 23.2) was developed with this template. Other tools like the google PWA compatibility script significantly reduces the pain to make your app installable on multiple platforms. FIGURE 23.2: Twitter design on mobile devices "],["mobile-shinyMobile.html", "Chapter 24 Reconstruct {shinyMobile} 24.1 Introduction to Framework7 24.2 Initiate the package 24.3 Framework7 Layouts 24.4 App initialization 24.5 App configuration 24.6 Handle multiple scripts 24.7 Theming and colors", " Chapter 24 Reconstruct {shinyMobile} Disclaimer: This section has been written and tested with Framework7 5.7.14. Some feature may change in future releases. 24.1 Introduction to Framework7 Framework7 is the HTML/CSS/JavaScript engine that fuels {shinyMobile}. It is a flexible toolkit to build native looking web apps or progressive web apps (PWA). It has an incredibly rich ecosystem: Provides a core JavaScript API, React API, Vue API, Svelte API. A CLI to ease the creation of PWA, provide boilerplate and started templates. A full set of native icons. Hundreds of components with different look for iOS and material design, even desktop. A comprehensive set of documentation. A supportive community. 24.2 Initiate the package This is time to initialize the package structure and extract the Framework7 dependencies. To get an idea of the package file structure, we run: library(charpente) get_dependency_assets(&quot;framework7&quot;) ## ℹ Trying with https://data.jsdelivr.com/v1/package/npm/framework7 ## ✓ Success! ## ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## $url ## [1] &quot;https://cdn.jsdelivr.net/npm/framework7@6.0.7/&quot; ## ## $files ## [1] &quot;esm&quot; &quot;core&quot; &quot;components&quot; &quot;cjs&quot; ## [5] &quot;bundle&quot; &quot;less&quot; &quot;lite&quot; &quot;lite-bundle&quot; ## [9] &quot;modules&quot; &quot;types&quot; &quot;framework7.css&quot; &quot;framework7.d.ts&quot; ## [13] &quot;framework7.js&quot; &quot;framework7.js.map&quot; &quot;framework7.less&quot; &quot;framework7.min.css&quot; ## [17] &quot;framework7.min.js&quot; &quot;framework7.min.js.map&quot; &quot;framework7-bundle.css&quot; &quot;framework7-bundle.js&quot; ## [21] &quot;framework7-bundle.js.map&quot; &quot;framework7-bundle.less&quot; &quot;framework7-bundle.min.css&quot; &quot;framework7-bundle.min.js&quot; ## [25] &quot;framework7-bundle.min.js.map&quot; &quot;framework7-bundle-rtl.css&quot; &quot;framework7-bundle-rtl.min.css&quot; &quot;framework7-rtl.css&quot; ## [29] &quot;framework7-rtl.min.css&quot; &quot;LICENSE&quot; &quot;package.json&quot; &quot;postinstall.js&quot; ## [33] &quot;README.md&quot; ## ## $hasSubfolders ## [1] FALSE We browse to the package structure page, which provides details about necessary components. We are going to use the bundle version since the lite approach is missing several components. We therefore only need framework7.bundle.min.js and framework7.bundle.min.css, which is the default options of create_dependency: path &lt;- file.path(tempdir(), &quot;shinyMobile&quot;) create_charpente(path, license = &quot;mit&quot;) Once the package created and opened, we download Framework7 dependencies. We specify the latest stable version that is 5.7.14 and we target bundle.min files since minified files do not contain the code to make all components working: create_dependency(&quot;framework7&quot;, tag = &quot;5.7.14&quot;, options = charpente_options(bundle = TRUE)) which generates the framework7-dependencies.R script: add_framework7_deps &lt;- function(tag) { framework7_deps &lt;- htmltools::htmlDependency( name = &quot;framework7&quot;, version = &quot;5.7.14&quot;, src = c(file = &quot;framework7-5.7.14&quot;), script = &quot;js/framework7.bundle.min.js&quot;, stylesheet = &quot;css/framework7.bundle.min.css&quot;, package = &quot;shinyMobile&quot;, ) htmltools::tagList(tag, framework7_deps) } 24.3 Framework7 Layouts Framework7 has 3 predefined layouts (Figure 24.1): Single page layout. Multi tabs layout. Split layout: this template is focused for tablet/desktop use. It is composed of a sidebar and a main panel. FIGURE 24.1: Framework7 layouts Let’s start simple and select the single page layout, whose corresponding HTML is given by: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- Required meta tags--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;!-- Color theme for statusbar (Android only) --&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#2196f3&quot;&gt; &lt;!-- Your app title --&gt; &lt;title&gt;My App&lt;/title&gt; &lt;!-- Path to Framework7 Library Bundle CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.bundle.min.css&quot;&gt; &lt;!-- Path to your custom app styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/my-app.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- App root element --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- Your main view, should have &quot;view-main&quot; class --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Initial Page, &quot;data-name&quot; contains page name --&gt; &lt;div data-name=&quot;home&quot; class=&quot;page&quot;&gt; &lt;!-- Top Navbar --&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;title&quot;&gt;Awesome App&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Bottom Toolbar --&gt; &lt;div class=&quot;toolbar toolbar-bottom&quot;&gt; &lt;div class=&quot;toolbar-inner&quot;&gt; &lt;!-- Toolbar links --&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 1&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Scrollable page content --&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;p&gt;Page content goes here&lt;/p&gt; &lt;!-- Link to another page --&gt; &lt;a href=&quot;/about/&quot;&gt;About app&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Path to Framework7 Library Bundle JS--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/framework7.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Path to your app js--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/my-app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; The head tag contains meta tags, some of them required for the PWA features. The most important part is the dependencies that will be included there. Note that the order matters: Framework7 dependencies go first, other dependencies follow. The body tag is composed of several layers. The first one is the app root element, which is crucial to the template initialization. We’ll come back on that point in the next section. Then we find the view view-main component, inside which we find the page. The page contains the navbar, toolbar (bottom bar) and the page content. Framework7 inserts JavaScript code at the end of the body. Don’t worry, we can include them in the head as well. Using html_2_R we convert the above code to R and extract the f7_page function. We replace the title content by a title parameter, we remove all CSS and JS links since we add them with the add_dependencies function applied to body. The page content is contained in a ... parameter. We also move the navbar and toolbar content to create 2 other layout functions: f7_page &lt;- function(..., navbar, toolbar, title = NULL) { tagList( tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot; ), tags$meta( name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot; ), tags$meta( name = &quot;theme-color&quot;, content = &quot;#2196f3&quot; ), tags$title(title) ), add_dependencies( tags$body( tags$div( id = &quot;app&quot;, tags$div( class = &quot;view view-main&quot;, tags$div( class = &quot;page&quot;, navbar, toolbar, tags$div( class = &quot;page-content&quot;, ... ) ) ) ) ), deps = &quot;framework7&quot;, ) ) } Below are the navbar and toolbar components. The navbar has only a title parameter and the toolbar may contain items in a ... parameter. In practice they may contain more element but this is enough for now: f7_navbar &lt;- function(title) { tags$div( class = &quot;navbar&quot;, tags$div(class = &quot;navbar-bg&quot;), tags$div( class = &quot;navbar-inner&quot;, tags$div( class = &quot;title&quot;, title ) ) ) } f7_toolbar &lt;- function(...) { tags$div( class = &quot;toolbar toolbar-bottom&quot;, tags$div( class = &quot;toolbar-inner&quot;, ... ) ) } Don’t forget to regularly insert roxygen documentation with the insert roxygen skeleton RStudio feature. At that point, we can try to run a simple shiny app. Best practice is to save the app.R file in the inst/examples folder: devtools::load_all() library(shiny) ui &lt;- f7_page( &quot;Test&quot;, navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot; ) server &lt;- function(input, output, session) {} shinyApp(ui, server) which displays nothing, but returns no error. We are actually missing the app initialization step. 24.4 App initialization This step is mandatory to activate all template components (router, panels, …). We create a custom script with create_js: create_js(&quot;init&quot;) and add the following piece of JS inside: $( document ).ready(function() { app = new Framework7({ // App root element root: &#39;#app&#39;, // App Name name: &#39;My App&#39;, // other options }); }); Note: we don’t assign app to a variable to make it globally accessible by any script! It is relevant since app may be needed almost everywhere. This script creates the app instance so as to be able to use methods, get other information, interact with layout elements and listen to app events (offline, online, …). Since the root element is a direct child of the body, the root property is not mandatory. The full configuration list may be found here. The next step is to initialize the main view, we add this line right after the app creation: mainView = app.views.create(&#39;.view-main&#39;); Once done, we compress the corresponding JS file to create the shinyMobile.min.js code and update the f7_page to include the new dependency, after the Framework7 one: build_js() # updated f7_page f7_page &lt;- function(..., navbar, toolbar, title = NULL) { tagList( tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot; ), tags$meta( name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot; ), tags$meta( name = &quot;theme-color&quot;, content = &quot;#2196f3&quot; ), tags$title(title) ), add_dependencies( tags$body( tags$div( id = &quot;app&quot;, tags$div( class = &quot;view view-main&quot;, tags$div( class = &quot;page&quot;, navbar, toolbar, tags$div( class = &quot;page-content&quot;, ... ) ) ) ) ), deps = c(&quot;framework7&quot;, &quot;shinyMobile&quot;), ) ) } devtools::load_all() If you run the previous app again, it should work as shown on Figure 24.2. The right panel displays the developer tools inside which we can seamlessly debug the JS code, by leveraging source maps. FIGURE 24.2: First working {shinyMobile} app From now, we can add a welcome notification message leveraging the notification API. There are 2 steps: Create the notification instance with app.notification.create(parameters). Tell the app to open the notification at start with app.notification.open(). We add the following code to init.js and call build_js(): var notification = app.notification.create({ text: &#39;Welcome to shinyMobile!&#39;, on: { opened: function () { console.log(&#39;Notification opened&#39;) } } }).open(); It will open at start up and close on swipe gesture. The Framework7 API is quite easy to understand and extremely powerful. 24.5 App configuration The app object has a tremendous amount of methods and parameters. In this section, we briefly describe the most significant and how to set it up. Among all parameters, there are metadata parameters like name and version. Once the app initialized, all app parameters are accessible with the . notation. For instance, if you setup a version number it is accessible with app.version. 24.5.1 Global theme One of the most important parameter is the theme that controls the overall app design (Figure 24.3): ios corresponds the iOS design. md to material design. aurora to a desktop optimized design. The good new is that if this parameter is set to auto, Framework7 will detect the current device and accordingly adapt the design. Nothing prevents you from forcing the iOS layout on android devices, even though being irrelevant. Interestingly, one may recover the current device with app.device. There are many properties to review. FIGURE 24.3: Framework7 skins: iOS (left), md (right). 24.5.2 Events The app is able to emit events whenever relevant like init, resize, online, offline, which allows to add interactivity: app = new Framework7({ on: { init: function () { console.log(&#39;App initialized&#39;); }, // other events } }); 24.5.3 Components configuration All Framework7 components are highly customizable. Yet, if you know that some parameters are not going to change, it is a good idea to make them global and share across all instances. For instance, notifications have global options. Let’s add this code to the init.js script inside the var app = new Framework7({ ... }): notification: { title: &#39;My App&#39;, closeTimeout: 3000, } This means all notifications will close after 3 seconds and have the My App title. We add another notification to the init.js script with a delay of 1 second so as to test this global feature. Note the use of internal Framework7 utils app.utils.nextTick, which is nothing more than a setTimeout. At this point it should look like this: $( document ).ready(function() { // create app instance app = new Framework7({ // App root element root: &#39;#app&#39;, // App Name name: &#39;My App&#39;, // other options notification: { title: &#39;My App&#39;, closeTimeout: 3000, } }); // init main view mainView = app.views.create(&#39;.view-main&#39;); var notification = app.notification.create({ text: &#39;Hello, how are you?&#39;, on: { opened: function () { console.log(&#39;Notification opened&#39;); } } }).open(); var otherMessage = app.notification.create({ text: &#39;You look great!&#39; }); // equivalent to setTimeout ... app.utils.nextTick(function() { otherMessage.open(); }, 1000); }); 24.5.4 Other elements Framework7 provides mobile specific modules like touch, which is a long press event (here 750 ms). This is something you can usually do on many apps. To activate that feature, we pass the following configuration to the app parameters list, that is inside app = new Framework7({...});: touch: { tapHold: true, } To test that component, we create a button element and add it the taphold event in init.js: $(&#39;#mybutton&#39;).on(&#39;taphold&#39;, function () { app.dialog.alert(&#39;Tap hold fired!&#39;); }); The app.R script should look like: ui &lt;- f7_page( &quot;Test&quot;, tags$div( class = &quot;list inset&quot;, tags$ul( tags$li( tags$a( href = &quot;#&quot;, id = &quot;mybutton&quot;, class = &quot;list-button color-red&quot;, &quot;Large Red Button&quot; ) ) ) ), navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot; ) server &lt;- function(input, output, session) {} shinyApp(ui, server) Once the app is running don’t forget to open the developer tools and set the device on mobile mode (iPhone or android) since taphold does not fire on desktop (Figure 24.4). taphold also triggers events related to the click like text selection, which one may want to disable. If so, we have to add the following code to init.js, making sure to check that touch exists: // tapHold custom css if (config.hasOwnProperty(&quot;touch&quot;)) { if (app.params.tapHold) { $(&quot;&lt;style&gt;&quot;) .prop(&quot;type&quot;, &quot;text/css&quot;) .html( `-moz-user-select: none; -webkit-user-select: none; user-select: none;` ) .appendTo(&quot;head&quot;); } } which disables classic text selection after a long press in the window. FIGURE 24.4: Long press or taphold event An important remark is the click handling in Framework7. Framework7 has its own internal router that allows to pass data between pages and perform quite advanced actions. While extremely convenient for classic web apps, this feature is not completely suited for Shiny that does not natively support multi pages apps. The recent work in the field is promising and plays well with {shinyMobile} (see here) but this is out of the scope of this chapter. The internal router has strong implications, for instance clicking on &lt;a href=\"https://www.google.com/\"&gt;Click me&lt;/a&gt; will fail (while it works like a charm for a classic shiny app), as shown below: mylink &lt;- a(href = &quot;https://www.google.com/&quot;, &quot;Click me&quot;) # shinyMobile ui &lt;- f7_page( mylink, navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot; ) server &lt;- function(input, output, session) {} shinyApp(ui, server) # classic shiny ui &lt;- fluidPage(mylink) shinyApp(ui, server) To fix this issue, Framerwork7 has a clicks module options, that we may pass any valid CSS selector to the externalLinks property. Below is the default configuration: clicks: { externalLinks: &#39;.external&#39;, } Note: one might be tempted to target all a elements: this is a bad idea, as it also target tabs navigation, which eventually fails! Therefore, it is best practice to add the external class to all the necessary links like a(href = \"https://www.google.com/\", \"Click me\", class = \"external\") 24.5.5 Allow end-user configuration In the above sections, we described some parameters to configure the app. Yet, we did setup all values directly in JavaScript. How do we allow the end user to provide external values? The idea is the following: We create an options parameter in the f7_page function which accepts a list of parameters. We convert it to the JSON format and store it in a tag. Ideally next to the body element. We recover those data on the JS side and update the app initialization method. The f7_page may be adapted: f7_page &lt;- function(..., navbar, toolbar, title = NULL, options = NULL) { config_tag &lt;- tags$script( type = &quot;application/json&quot;, `data-for` = &quot;app&quot;, jsonlite::toJSON( x = options, auto_unbox = TRUE, json_verbatim = TRUE ) ) # create body_tag body_tag &lt;- tags$body( tags$div( id = &quot;app&quot;, tags$div( class = &quot;view view-main&quot;, tags$div( class = &quot;page&quot;, navbar, toolbar, tags$div( class = &quot;page-content&quot;, ... ) ) ) ), config_tag ) tagList( tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot; ), tags$meta( name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot; ), tags$meta( name = &quot;theme-color&quot;, content = &quot;#2196f3&quot; ), tags$title(title) ), add_dependencies( body_tag, deps = c(&quot;framework7&quot;, &quot;shinyMobile&quot;) ) ) } The above code deserves some explanations. We exploit a method already defined in section 11.2. We convert the options list to a JSON with jsonlite::toJSON and embed it in a script tag. The data-for attribute with the unique id guarantees the uniqueness of our configuration script. config_tag &lt;- shiny::tags$script( type = &quot;application/json&quot;, `data-for` = &quot;app&quot;, jsonlite::toJSON( x = options, auto_unbox = TRUE, json_verbatim = TRUE ) ) We then create an intermediate body_tag component where we insert the configuration tag. On the JS side, the data collection must occur before the app initialization and is quite easy with the jQuery find method: var config = $(document).find(&quot;script[data-for=&#39;app&#39;]&quot;); config = JSON.parse(config.html()); We can accordingly update the app initialization: app = new Framework7({ // App root element root: &#39;#app&#39;, // App Name name: &#39;My App&#39;, version: config.version, // other options theme: config.theme, notification: { title: &#39;My App&#39;, closeTimeout: 3000, }, touch: { tapHold: config.taphold, }, }); What happens if the user forgets to supply the version number? data.version is undefined and the app still works! The biggest advantage of this approach is the fact that all TRUE and FALSE (R) are converted to true and false (JS), which avoids unnecessary conversion steps. However, we are still missing many potential configuration options. For instance, with the above code, only root, name, version, theme, notifications, touch are considered. If the user provides any other option, it is ignored. In theory, we could do to make sure all elements are considered: app = new Framework7(config); It assumes that the user exactly knows what to provide in the list, especially mandatory elements. Knowing the crazy number of options, it might be slightly too complex for a new user. What we suggest is to extract the most important components as direct f7_page parameters and keep less important parameters in the options list. For example, if you think that theme is super important (and it truly is), you could do: f7_page &lt;- function(..., navbar, toolbar, theme = c(&quot;ios&quot;, &quot;md&quot;, &quot;aurora&quot;), title = NULL, options = NULL) { theme &lt;- match.arg(theme) options$theme &lt;- theme config_tag &lt;- shiny::tags$script( type = &quot;application/json&quot;, `data-for` = &quot;app&quot;, jsonlite::toJSON( x = options, auto_unbox = TRUE, json_verbatim = TRUE ) ) # ... } which makes the API a bit more accessible (event though more complex to maintain) and you only need to add one line of documentation in the roxygen part. It would be disheartening to redirect them to the Framework7 API documentation and have to look for the relevant option! Alternatively, you could also put all parameters in options but provide a default value for f7Page like: \\itemize{ #&#39; \\item \\code{theme}: App skin: &quot;ios&quot;, &quot;md&quot;, &quot;auto&quot; or &quot;aurora&quot;. #&#39; \\item \\code{dark}: Dark layout. TRUE or FALSE. #&#39; \\item \\code{filled}: Whether to fill the \\link{f7Navbar} and \\link{f7Toolbar} with #&#39; the current selected color. FALSE by default. #&#39; \\item \\code{color}: Color theme: See \\url{http://framework7.io/docs/color-themes.html}. #&#39; Expect a name like blue or red. If NULL, use the default color. #&#39; \\item \\code{pullToRefresh}: Whether to active the pull to refresh feature. Default to FALSE. #&#39; See \\url{https://v5.framework7.io/docs/pull-to-refresh.html#examples}. #&#39; \\item \\code{iosTranslucentBars}: Enable translucent effect (blur background) on navigation bars for iOS theme (on iOS devices). #&#39; FALSE by default. #&#39; } #&#39; Touch module options \\url{https://v5.framework7.io/docs/app.html#app-parameters}: #&#39; \\itemize { #&#39; \\item \\code{tapHold}: It triggers (if enabled) after a sustained, complete touch event. #&#39; By default it is disabled. Note, that Tap Hold is a part of built-in Fast Clicks library, #&#39; so Fast Clicks should be also enabled. #&#39; \\item \\code{tapHoldDelay}: Determines how long (in ms) the user must hold their tap before the taphold event is fired on the target element. #&#39; Default to 750 ms. #&#39; \\item \\code{iosTouchRipple}: Default to FALSE. Enables touch ripple effect for iOS theme. #&#39; } #&#39; Navbar options \\url{https://v5.framework7.io/docs/navbar.html#navbar-app-parameters}: #&#39; \\itemize { #&#39; \\item \\code{iosCenterTitle}: Default to TRUE. When enabled then it will try to position #&#39; title at the center in iOS theme. Sometime (with some custom design) it may not needed. #&#39; \\item \\code{hideOnPageScroll}: Default to FALSE. Will hide Navbars on page scroll. #&#39; } #&#39; Toolbar options \\url{https://v5.framework7.io/docs/toolbar-tabbar.html#toolbar-app-parameters}: #&#39; \\itemize { #&#39; \\item \\code{hideOnPageScroll}: Default to FALSE. Will hide tabs on page scroll. #&#39; } #&#39; #&#39; In any case, you must follow the same structure as provided in the function arguments. f7Page &lt;- function( # other parameters are not mentionned options = list( theme = c(&quot;ios&quot;, &quot;md&quot;, &quot;auto&quot;, &quot;aurora&quot;), dark = TRUE, filled = FALSE, color = &quot;#007aff&quot;, touch = list( tapHold = TRUE, tapHoldDelay = 750, iosTouchRipple = FALSE ), iosTranslucentBars = FALSE, navbar = list( iosCenterTitle = TRUE, hideNavOnPageScroll = TRUE ), toolbar = list( hideNavOnPageScroll = FALSE ), # whatever option ... ) ) { # function body ... } and do app = new Framework7(config); on the JS side. This is a good compromise since it avoids to create too many parameters, without sacrificing the documentation. Don’t forget that since config is an object, you may add any other properties, methods, on the fly with the . notation or app.utils.extend. You finally may ask why we put dark, color and filled in the options list given they are not part of the app API parameters. As any unknown parameter is not considered by the Framework7 class, we can safely keep them here, which is easier to treat on the JS side. 24.5.6 Modify configuration As previously stated, the app configuration is passed during the initialization process, through new Framework7(config). What if the user wants to programmatically change these options when the app is running? Since app parameters are located in app.params, the idea would be to extend that list: var newParams = { dialog: { buttonOk: &quot;Yeaaaah!&quot;, buttonCancel: &quot;Ouuups!&quot; } } app.utils.extend(app.params, newParams); The above example changes the default buttons text for all modal dialog. Note: As far as I have tested, some options won’t work like the global theme, which would require to re-initialize the app and is obviously not possible. 24.6 Handle multiple scripts 24.6.1 Scoping rules We only have only one JS file, namely init.js. How do we handle multiple files, especially scoping rules? The code inside init.js is wrapped in a main function that waits the document to be ready before interacting with the DOM. This is necessary since the configuration is retrieved from a script DOM element inserted when the application starts, thus not immediately available. If you try to remove the $( document ).ready(function(...)});, an error is raised since the config cannot be properly retrieved (timing issue). As already mentioned above, if you think an object is to be reused in multiple scripts with different scopes, you can omit the var so that the element is global and accessible from anywhere. 24.6.2 Order matters Assume we want to move the init.js notifications to another script, say notifications.js. When we call build_js, the terser treats them by alphabetical order meaning notifications code appears after the init code in the final JS code. This is fine because app is created within init.js and called later in notifications.js. Now, we create a third script with another component, component.js: app.component.create(parameters); build_js aggregates component.js and init.js in that order, which raises an error since app is used before being defined. Remember that build_js has a files parameter to specify a custom order and we could do as below to properly concatenate files: js_files &lt;- list.files(&quot;srcjs&quot;) init_js &lt;- which(js_files == &quot;init.js&quot;) component_js &lt;- which(js_files == &quot;component.js&quot;) js_files &lt;- js_files[-c(init_js, component_js)] build_js(files = paste0(&quot;srcjs/&quot;, c(&quot;init.js&quot;, &quot;component.js&quot;, jsFiles))) 24.6.3 Global data and methods The Framework7 data parameters allows to share global elements between multiple scripts. To illustrate this feature, we consider the tooltip example. A tooltip is a help text generally displayed on hover (or click) over a specific element. They are commonly used to improve user experience in all websites. Framework7 provides two tooltips systems: A purely UI side API where the tooltip is attached to a tag. A server side API where the tooltip is dynamically injected in the page content. The first approach is obviously not interesting for us since it does not involve any single line of JS. The second approach heavily relies on the app.data object which we describe. On the R side, there are two functions: addF7Tooltip that sends a custom message to JS called add_tooltip. This message is composed of the tooltip options (content, …), as well as the selector on which to apply the tooltip (id or selector for custom CSS selector). updateF7Tooltip that sends a custom message to JS, update_tooltip to change the tooltip state (active/inactive) and its content. Their code is defined below: validateSelector &lt;- function(id, selector) { if (!is.null(id) &amp;&amp; !is.null(selector)) { stop(&quot;Please choose either target or selector!&quot;) } } sendCustomMessage &lt;- function(type, message, session) { session$sendCustomMessage( type, jsonlite::toJSON( message, auto_unbox = TRUE, json_verbatim = TRUE ) ) } &quot;%OR%&quot; &lt;- function(a, b) if (!is.null(a)) a else b addF7Tooltip &lt;- function(id = NULL, selector = NULL, options, session = shiny::getDefaultReactiveDomain()) { # We use already defined popover functions validateSelector(id, selector) if (!is.null(id)) id &lt;- paste0(&quot;#&quot;, session$ns(id)) options$targetEl &lt;- id %OR% selector sendCustomMessage(&quot;add_tooltip&quot;, options, session) } updateF7Tooltip &lt;- function(id = NULL, selector = NULL, action = c(&quot;toggle&quot;, &quot;update&quot;), text = NULL, session = shiny::getDefaultReactiveDomain()) { validateSelector(id, selector) if (!is.null(id)) id &lt;- paste0(&quot;#&quot;, session$ns(id)) targetEl &lt;- id %OR% selector message &lt;- dropNulls(list(targetEl = targetEl, action = action, text = text)) sendCustomMessage(&quot;update_tooltip&quot;, message, session) } Framework7 does not provide any native enable/disable method, which means that once the tooltip is activated on a given element, it is visible forever, unless destroyed. One of the goal of updateF7Tooltip is to avoid this by temporarily disabling any tooltip and reactivating it later. The JS part to activate the tooltip is tooltips.js: Shiny.addCustomMessageHandler(&#39;add_tooltip&#39;, function(message) { app.tooltip.create(message).show(); }); As mentioned early this is fine since message is a JSON element. We can also chain methods like app.tooltip.create(message).show();. There is however a problem: add_tooltip is fired each time the user triggers a specific element on the R side. It means the tooltip instance is created each time, which is not optimal. To fix this issue, we create a tooltips cache in the app.data object and accordingly modify init.js: config.data = function() { return { tooltips: [] }; }; Importantly, app.data must be a function returning one or multiple elements. Let’s first return an empty tooltips array. We update the tooltips.js file so that we: Check if the tooltip instance is already in the app.data cached before creating an instance. If is is already there, nothing has to be done. Each time we create a new instance, we save it in the app.data cache to retrieve it later. Shiny.addCustomMessageHandler(&#39;add_tooltip&#39;, function(message) { // We store all created instances in app data so that we don&#39;t // recreate them later if they exist ... if (app.data.tooltips[message.targetEl] === undefined) { // create instance var t = app.tooltip.create(message); // Open tooltip t.show(); // Storage in app data (tooltips array) app.data.tooltips[message.targetEl] = t; } }); Notice how we store the current instance: app.data.tooltips[message.targetEl] = t;. The reference is given by message.targetEl that is the target to apply the tooltip on. When multiple tooltips are created, we may search for them by target name, which is a reasonable choice. For instance app.data.tooltips[\"#mybutton\"] points to the tooltip associated to the element having #mybutton as id. So far so good! How do we enable/disable tooltip then? This is the mission of the updateF7Tooltip R function. The corresponding JS handler: Checks if the specified tooltip instance exists and only update if it is the case. Handles two situations: update the tooltip content or toggle the tooltip visibility ( It is actually more than just showing/hiding the tooltip. Remember that each tooltip is shown on hover so applying hide on a visible tooltip will only have effect until the user hover again over the same tooltip, which is useless). The updateF7Tooltip sends two elements to JS: the tooltip target element message.targetEl, the optional new text, that is message.text and the action to perform message.action (either update or toggle state). Let’s first update the tooltip element. In tooltip.js, we add: Shiny.addCustomMessageHandler(&#39;update_tooltip&#39;, function(message) { // Don&#39;t do anything if the instance is not there in app data if (app.data.tooltips[message.targetEl] !== undefined) { var t = app.data.tooltips[message.targetEl]; if (message.action === &quot;update&quot;) { t.setText(message.text); } } }); The corresponding tooltip instance is accessed in app.data with app.data.tooltips[message.targetEl] and stored in a local variable, t. We apply setText only if the user action corresponds to update. We handle the toggle case. The first thing to check is whether the current instance is active. We do it with the app.tooltip.get method targeted on message.targetEl. If the instance is alive, we get an object while we obtain undefined it does not exist. We then call the app.tooltip.destroy method on the current instance: Shiny.addCustomMessageHandler(&#39;update_tooltip&#39;, function(message) { // Don&#39;t do anything if the instance is not there in app data if (app.data.tooltips[message.targetEl] !== undefined) { var t = app.tooltip.get(message.targetEl); if (message.action === &quot;update&quot;) { t.setText(message.text); } else if (message.action === &quot;toggle&quot;) { // destroy if (t) { t.destroy(); } } } }); Wait a moment! There are 2 issues with this code. The first is that t is a variable pointing to the current instance. If we destroy that instance, t will point to a destoyed element the next time it is called, and any action like setText will raise an error. The trick is to create a deep clone with Object.assign that won’t be affected by the destroy method, save the deep clone in the app.data cache and destroy the old instance. Therefore we update the tooltips.js script: Shiny.addCustomMessageHandler(&#39;update_tooltip&#39;, function(message) { if (app.data.tooltips[message.targetEl] !== undefined) { // Try to get the instance var t = app.tooltip.get(message.targetEl); if (message.action === &quot;update&quot;) { if (t) { t.setText(message.text); } } else if (message.action === &quot;toggle&quot;) { if (t) { // create copy that won&#39;t be modified if t is destroyed! var cachedTooltip = Object.assign({}, t); // save copy to replace the deleted one in the app data app.data.tooltips[message.targetEl] = cachedTooltip; // destroy current instance t.destroy(); } } } }); We also check whether the instance is alive before updating it. We are still missing the re-activation step that consists in rebuilding the tooltip instance based on the cached data app.data.tooltips[message.targetEl] previously saved. All parameters are contained in the params object (instance element): // Capture parameters var pars = app.data.tooltips[message.targetEl].params; // Recreate the tooltip based on the copy configuration t = app.tooltip.create(pars); // Replace the app data instance app.data.tooltips[message.targetEl] = t; The final JS code is: Shiny.addCustomMessageHandler(&#39;update_tooltip&#39;, function(message) { if (app.data.tooltips[message.targetEl] !== undefined) { // Try to get the instance var t = app.tooltip.get(message.targetEl); if (message.action === &quot;update&quot;) { if (t) { t.setText(message.text); } } else if (message.action === &quot;toggle&quot;) { if (t) { // create copy that won&#39;t be modified if t is destroyed! var cachedTooltip = Object.assign({}, t); // save copy to replace the deleted one in the app data app.data.tooltips[message.targetEl] = cachedTooltip; // destroy current instance t.destroy(); } else { // Parameters var pars = app.data.tooltips[message.targetEl].params; // recreate the tooltip based on the copy configuration t = app.tooltip.create(pars); app.data.tooltips[message.targetEl] = t; } } } }); Similarly methods hosts all global app methods. These are function you may re-use in different parts. Like for app.data, we access them with app.methods. Important note: app.data has been removed since Framework7 6.0.0! 24.7 Theming and colors Framework7 has 15 color themes with a dark/light global appearance. To apply them, we add color-theme-COLOR to the parent element. Best practice is to target the body since its the parent of all the page content. This ensures global consistency. The dark theme is triggered by adding the theme-dark class to html. Since body belongs to f7_page but not html (added by Shiny at startup), we can apply the color in R but the dark mode has to be activated from JS: f7_page &lt;- function(..., navbar, toolbar, theme = c(&quot;ios&quot;, &quot;md&quot;, &quot;aurora&quot;), color = NULL, title = NULL, options = NULL) { body_cl &lt;- NULL if (!is.null(color)) body_cl &lt;- sprintf(&quot;color-theme-color&quot;) # Modify the body tag to add a class tags$body( class = body_cl, tags$div( id = &quot;app&quot;, tags$div( class = &quot;view view-main&quot;, tags$div( class = &quot;page&quot;, navbar, toolbar, tags$div( class = &quot;page-content&quot;, ... ) ) ) ), config_tag ) # ... } This approach assumes the user to pass the color name as parameter like pink, yellow. What if we want to allow more flexibility and add any existing HEX color? Framework7 has tools, namely app.utils.colorThemeCSSProperties, that is a JS method creating the required CSS on the fly depending on the provided HEX color. For instance, if we select a cyberpunk green color: app.utils.colorThemeCSSProperties(&#39;#42f5a1&#39;); // /* Custom color theme */ // { // &quot;--f7-theme-color&quot;: &quot;#42f5a1&quot;; // &quot;--f7-theme-color-rgb&quot;: &quot;66, 245, 161&quot;; // &quot;--f7-theme-color-shade&quot;: &quot;#1bf38e&quot;; // &quot;--f7-theme-color-tint&quot;: &quot;#69f7b4&quot;; // } The commented code has to be injected in the app CSS. I personally don’t think its a problem to look for a specific HEX code, knowing that many tools can help. Therefore, I prefer the second approach. We edit the init.js code by adding the following JS snippet: if (config.hasOwnProperty(&#39;color&#39;)) { var colorCSS = app.utils.colorThemeCSSProperties(config.color); $(&#39;&lt;style&gt;&#39;) .prop(&#39;type&#39;, &#39;text/css&#39;) .html(`:root { --f7-theme-color: ${colorCSS[&quot;--f7-theme-color&quot;]}; --f7-theme-color-rgb: ${colorCSS[&quot;--f7-theme-color-rgb&quot;]}; --f7-theme-color-shade: ${colorCSS[&quot;--f7-theme-color-shade&quot;]}; --f7-theme-color-tint: ${colorCSS[&quot;--f7-theme-color-tint&quot;]}; }`) .appendTo(&quot;head&quot;); } config.hasOwnProperty('color') ensures that this code does not run if color is missing from the provided config. Then, we generate an object containing the theme color properties with app.utils.colorThemeCSSProperties(config.color). Importantly, as this is an object, we can’t insert it in a string. However, we can extract its properties 1 by 1 to generate the relevant piece of CSS. Then we add a style tag to the head containing the following CSS rule: /* Custom color theme */ :root { --f7-theme-color: #42f5a1; --f7-theme-color-rgb: 66, 245, 161; --f7-theme-color-shade: #1bf38e; --f7-theme-color-tint: #69f7b4; } For each property like --f7-theme-color, we recover the corresponding value in the colorCSS object, that is colorCSS[\"--f7-theme-color\"]. Once done, recompile the JS with build_js and try with the following app: devtools::load_all() ui &lt;- f7_page( tags$div( class = &quot;list inset&quot;, tags$ul( tags$li( tags$a( href = &quot;#&quot;, id = &quot;mybutton&quot;, class = &quot;list-button&quot;, &quot;Large Green Button&quot; ) ) ) ), navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot;, options = list(theme = &quot;ios&quot;, version = &quot;1.0.0&quot;, taphold = TRUE, color = &quot;#42f5a1&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) We can go further and apply the filled theme, which is a reverted design where all navbar, toolbar, … are filled with the theme color. For this, we need to add the following CSS: /* Invert navigation bars to fill style */ :root, :root.theme-dark, :root .theme-dark { --f7-bars-bg-color: var(--f7-theme-color); --f7-bars-bg-color-rgb: var(--f7-theme-color-rgb); --f7-bars-translucent-opacity: 0.9; --f7-bars-text-color: #fff; --f7-bars-link-color: #fff; --f7-navbar-subtitle-text-color: rgba(255,255,255,0.85); --f7-bars-border-color: transparent; --f7-tabbar-link-active-color: #fff; --f7-tabbar-link-inactive-color: rgba(255,255,255,0.54); --f7-sheet-border-color: transparent; --f7-tabbar-link-active-border-color: #fff; } .appbar, .navbar, .toolbar, .subnavbar, .calendar-header, .calendar-footer { --f7-touch-ripple-color: var(--f7-touch-ripple-white); --f7-link-highlight-color: var(--f7-link-highlight-white); --f7-button-text-color: #fff; --f7-button-pressed-bg-color: rgba(255,255,255,0.1); } .navbar-large-transparent, .navbar-large.navbar-transparent { --f7-navbar-large-title-text-color: #000; --r: 0; --g: 122; --b: 255; --progress: var(--f7-navbar-large-collapse-progress); --f7-bars-link-color: rgb( calc(var(--r) + (255 - var(--r)) * var(--progress)), calc(var(--g) + (255 - var(--g)) * var(--progress)), calc(var(--b) + (255 - var(--b)) * var(--progress)) ); } .theme-dark .navbar-large-transparent, .theme-dark .navbar-large.navbar-transparent { --f7-navbar-large-title-text-color: #fff; } Like above, we do this on the JS side in init.js: if (!config.hasOwnProperty(&#39;filled&#39;)) config.filled = false; if (config.filled) { var filledCSS = ` :root, :root.theme-dark, :root .theme-dark { --f7-bars-bg-color: var(--f7-theme-color); --f7-bars-bg-color-rgb: var(--f7-theme-color-rgb); --f7-bars-translucent-opacity: 0.9; --f7-bars-text-color: #fff; --f7-bars-link-color: #fff; --f7-navbar-subtitle-text-color: rgba(255,255,255,0.85); --f7-bars-border-color: transparent; --f7-tabbar-link-active-color: #fff; --f7-tabbar-link-inactive-color: rgba(255,255,255,0.54); --f7-sheet-border-color: transparent; --f7-tabbar-link-active-border-color: #fff; } .appbar, .navbar, .toolbar, .subnavbar, .calendar-header, .calendar-footer { --f7-touch-ripple-color: var(--f7-touch-ripple-white); --f7-link-highlight-color: var(--f7-link-highlight-white); --f7-button-text-color: #fff; --f7-button-pressed-bg-color: rgba(255,255,255,0.1); } .navbar-large-transparent, .navbar-large.navbar-transparent { --f7-navbar-large-title-text-color: #000; --r: 0; --g: 122; --b: 255; --progress: var(--f7-navbar-large-collapse-progress); --f7-bars-link-color: rgb( calc(var(--r) + (255 - var(--r)) * var(--progress)), calc(var(--g) + (255 - var(--g)) * var(--progress)), calc(var(--b) + (255 - var(--b)) * var(--progress)) ); } .theme-dark .navbar-large-transparent, .theme-dark .navbar-large.navbar-transparent { --f7-navbar-large-title-text-color: #fff; }`; $(&#39;&lt;style&gt;&#39;) .prop(&#39;type&#39;, &#39;text/css&#39;) .html(`${filledCSS}`) .appendTo(&quot;head&quot;); } The result is displayed on Figure 24.5. Don’t forget to pass the filled property to the config list. FIGURE 24.5: Filled green color theme Let’s finish this section with the dark mode. We leverage the Framework7 app method element since we could also toggle the dark mode under other circumstances. We add a toggleDarkTheme function to the methods object then trigger it depending on the value of the config. If the user don’t provide any value, we set config.dark to false: config.methods = { toggleDarkTheme: function () { var self = this; var $html = self.$(&#39;html&#39;); $html.toggleClass(&#39;theme-dark&#39;); } } if (!config.hasOwnProperty(&#39;dark&#39;)) config.dark = false; if (config.dark) { app.methods.toggleDarkTheme(); } At this point init.js should be: $( document ).ready(function() { // collect all data elements stored in body var config = $(document).find(&quot;script[data-for=&#39;app&#39;]&quot;); config = JSON.parse(config.html()); // always erase existing root value just in case the user changes the root. // This may be harmful config.root = &quot;#app&quot;; // store app methods config.methods = { toggleDarkTheme: function() { var self = this; var $html = self.$(&quot;html&quot;); $html.toggleClass(&quot;theme-dark&quot;); } }; // create app instance app = new Framework7(config); // init main view mainView = app.views.create(&#39;.view-main&#39;); // tapHold custom css if (config.hasOwnProperty(&quot;touch&quot;)) { if (config.touch.tapHold) { $(&quot;&lt;style&gt;&quot;) .prop(&quot;type&quot;, &quot;text/css&quot;) .html( ` -moz-user-select: none; -webkit-user-select: none; user-select: none;` ) .appendTo(&quot;head&quot;); } } var notification = app.notification.create({ text: &#39;Hello, how are you?&#39;, on: { opened: function () { console.log(&#39;Notification opened&#39;); } } }).open(); var otherMessage = app.notification.create({ text: &#39;You look great!&#39; }); // equivalent to setTimeout ... app.utils.nextTick(function() { otherMessage.open(); }, 1000); // taphold test $(&#39;#mybutton&#39;).on(&#39;taphold&#39;, function () { app.dialog.alert(&#39;Tap hold fired!&#39;); }); // Set color theme if (config.hasOwnProperty(&#39;color&#39;)) { var colorCSS = app.utils.colorThemeCSSProperties(config.color); $(&#39;&lt;style&gt;&#39;) .prop(&#39;type&#39;, &#39;text/css&#39;) .html(`:root { --f7-theme-color: ${colorCSS[&quot;--f7-theme-color&quot;]}; --f7-theme-color-rgb: ${colorCSS[&quot;--f7-theme-color-rgb&quot;]}; --f7-theme-color-shade: ${colorCSS[&quot;--f7-theme-color-shade&quot;]}; --f7-theme-color-tint: ${colorCSS[&quot;--f7-theme-color-tint&quot;]}; }`) .appendTo(&quot;head&quot;); } // Filled theme if (!config.hasOwnProperty(&#39;filled&#39;)) config.filled = false; if (config.filled) { var filledCSS = ` :root, :root.theme-dark, :root .theme-dark { --f7-bars-bg-color: var(--f7-theme-color); --f7-bars-bg-color-rgb: var(--f7-theme-color-rgb); --f7-bars-translucent-opacity: 0.9; --f7-bars-text-color: #fff; --f7-bars-link-color: #fff; --f7-navbar-subtitle-text-color: rgba(255,255,255,0.85); --f7-bars-border-color: transparent; --f7-tabbar-link-active-color: #fff; --f7-tabbar-link-inactive-color: rgba(255,255,255,0.54); --f7-sheet-border-color: transparent; --f7-tabbar-link-active-border-color: #fff; } .appbar, .navbar, .toolbar, .subnavbar, .calendar-header, .calendar-footer { --f7-touch-ripple-color: var(--f7-touch-ripple-white); --f7-link-highlight-color: var(--f7-link-highlight-white); --f7-button-text-color: #fff; --f7-button-pressed-bg-color: rgba(255,255,255,0.1); } .navbar-large-transparent, .navbar-large.navbar-transparent { --f7-navbar-large-title-text-color: #000; --r: 0; --g: 122; --b: 255; --progress: var(--f7-navbar-large-collapse-progress); --f7-bars-link-color: rgb( calc(var(--r) + (255 - var(--r)) * var(--progress)), calc(var(--g) + (255 - var(--g)) * var(--progress)), calc(var(--b) + (255 - var(--b)) * var(--progress)) ); } .theme-dark .navbar-large-transparent, .theme-dark .navbar-large.navbar-transparent { --f7-navbar-large-title-text-color: #fff; }`; $(&#39;&lt;style&gt;&#39;) .prop(&#39;type&#39;, &#39;text/css&#39;) .html(`${filledCSS}`) .appendTo(&quot;head&quot;); } // dark mode if (!config.hasOwnProperty(&#39;dark&#39;)) config.dark = false; if (config.dark) { app.methods.toggleDarkTheme(); } }); and the dark mode app example: ui &lt;- f7_page( tags$div( class = &quot;list inset&quot;, tags$ul( tags$li( tags$a( href = &quot;#&quot;, id = &quot;mybutton&quot;, class = &quot;list-button&quot;, &quot;Large Green Button&quot; ) ) ) ), navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot;, options = list( theme = &quot;ios&quot;, version = &quot;1.0.0&quot;, taphold = TRUE, color = &quot;#42f5a1&quot;, filled = TRUE, dark = TRUE ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) The overall expected result is shown Figure 24.6. FIGURE 24.6: Dark mode in {shinyMobile} We have now set all base pieces. In the next chapter, we see how to make {shinyMobile} apps as progressive web apps. "],["mobile-pwa.html", "Chapter 25 {shinyMobile} and PWA 25.1 Disclaimers 25.2 Introduction 25.3 {charpente} and PWA tools 25.4 Handle the installation 25.5 Workbox 25.6 Other resources", " Chapter 25 {shinyMobile} and PWA Transforming a classic Shiny app into a PWA is a game changer for end users. The first step is to setup a valid web manifest with icons and favicon. 25.1 Disclaimers Some of the PWA features won’t work with iOS, like the install prompt. 25.2 Introduction Below, we review one by one the steps necessary to convert a shiny app to a PWA. To get a goo idea of what we exactly miss, we leverage the Application tab of the developer tools. The overall expected result is shown Figure 25.1. Alternatively, one may use the Google Lighthouse utility to provide a general diagnosis to the app. There are many categories like performance, accessibility. In our case, let’s just select the PWA category, select the mobile device radio and click on generate a report. FIGURE 25.1: Application tab of the developers tools According to the diagnostic result displayed on Figure 25.2, we miss many elements: No manifest. No service worker. No icons. FIGURE 25.2: Lighthouse audit result 25.3 {charpente} and PWA tools {charpente} has tools to help designing a PWA. The set_pwa function is a wrapper that does all the previously mentioned step in only one line of code. There are however few prerequisites: The app must belong to a package. The function must target the app directory. As a reminder, the demonstration apps are located within the inst/examples folder. We create the pwa-app sub-folder and the app.R file: library(shiny) library(shinyMobile) ui &lt;- f7_page( &quot;Test&quot;, navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot; ) server &lt;- function(input, output, session) {} shinyApp(ui, server) Then we set the PWA configuration: set_pwa(&quot;inst/examples/pwa-app&quot;) This function generates a manifest.webmanifest file, downloads the Google PWA compatibility script, adds a custom dependency pointing to the manifest.webmanifest file and a 144x144 icon file, copies a boilerplate service-worker.js with its offline.html page and optionally registers the service worker (code borrowed from web.dev: window.addEventListener(&#39;load&#39;, () =&gt; { if (&#39;serviceWorker&#39; in navigator) { var pathname = window.location.pathname; navigator.serviceWorker .register(pathname + &#39;service-worker.js&#39;, { scope: pathname}) .then(function() { console.log(&#39;Service Worker Registered&#39;); }); }; }); In the {shinyMobile} case, as Framework7 already registers any linked service worker, we don’t need that initialization script. Therefore, we actually call: set_pwa(&quot;inst/examples/pwa-app&quot;, register_service_worker = FALSE) Importantly, this functions does not handle icon creation. There are tools such as appsco and app-manifest, to create those custom icons and splash screens, if you need to. Below we give more detail 25.3.1 Create the manifest We want to create a JSON configuration file like this: { &quot;short_name&quot;: &quot;My App&quot;, &quot;name&quot;: &quot;Super amazing app&quot;, &quot;description&quot;: &quot;This app is just mind blowing&quot;, &quot;icons&quot;: [ { &quot;src&quot;: &quot;icons/icon.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;192x192&quot; } // ... ], &quot;start_url&quot;: &quot;https://whatever-url.com/&quot;, &quot;background_color&quot;: &quot;#3367D6&quot;, &quot;display&quot;: &quot;standalone&quot;, &quot;scope&quot;: &quot;/&quot;, &quot;theme_color&quot;: &quot;#3367D6&quot; } This file has to be accessible by the app so best practice is to put it in the /www folder. and images are hosted in a sub-directory /www/icons. The create_manifest function is basically writing a JSON file at the provided location: create_manifest &lt;- function(path, name = &quot;My Progressive Web App&quot;, shortName = &quot;My App&quot;, description = &quot;What it does!&quot;, lang = &quot;en-US&quot;, startUrl = &quot;/&quot;, display = c(&quot;minimal-ui&quot;, &quot;standalone&quot;, &quot;fullscreen&quot;, &quot;browser&quot;), background_color = &quot;#ffffff&quot;, theme_color = &quot;#ffffff&quot;) { display &lt;- match.arg(display) manifest &lt;- list( name = name, short_name = shortName, description = description, lang = lang, start_url = startUrl, display = display, background_color = background_color, theme_color = theme_color, icons = data.frame( src = &quot;icons/icon-144.png&quot;, sizes = &quot;144x144&quot; ) ) # create /www folder if does not exist yet if (!dir.exists(paste0(path, &quot;/www&quot;))) { dir.create(paste0(path, &quot;/www/icons&quot;), recursive = TRUE) } jsonlite::write_json( manifest, path = paste0(path, &quot;/www/manifest.webmanifest&quot;), pretty = TRUE, auto_unbox = TRUE ) ui_done(&quot;Web manifest successfully created!&quot;) } The web manifest and icons have to be included in the head before the Google PWA compatibility script: &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot; /&gt; &lt;!-- include icon also from manifest --&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;icons/logo-144.png&quot; sizes=&quot;144x144&quot; /&gt; set_pwa includes a create_pwa_dependency function that creates an HTML dependency containing all necessary resources: #&#39; PWA dependencies utils #&#39; #&#39; @description This function attaches PWA manifest and icons to the given tag #&#39; #&#39; @param tag Element to attach the dependencies. #&#39; #&#39; @importFrom utils packageVersion #&#39; @importFrom htmltools tagList htmlDependency #&#39; @export add_pwa_deps &lt;- function(tag) { pwa_deps &lt;- htmlDependency( name = &quot;pwa-utils&quot;, version = packageVersion(&quot;shinyMobile&quot;), src = c(file = &quot;shinyMobile-0.0.0.9000&quot;), head = &quot;&lt;link rel=\\&quot;manifest\\&quot; href=\\&quot;manifest.webmanifest\\&quot; /&gt; &lt;link rel=\\&quot;icon\\&quot; type=\\&quot;image/png\\&quot; href=\\&quot;icons/icon-144.png\\&quot; sizes=\\&quot;144x144\\&quot; /&gt;&quot;, package = &quot;mypkg2&quot;, ) tagList(tag, pwa_deps) } Importantly, all provided icons must follow the convention icon-&lt;size_in_px&gt;.png like icon-144.png, which is the default. 25.3.2 Google PWA compatibility As we use the google PWA compatibility script, we have to include at least one icon like &lt;link rel=\"icon\" type=\"image/png\" href=\"res/icon-128.png\" sizes=\"128x128\" /&gt;. However, we found some discrepancies between the developer tools recommendations and the PWA compatibility script. We recommend to follow the developer tools prescriptions, that is to include at least one icon of size 144x144. All other elements are generated by the script itself, which is extremely convenient. Indeed, having to handle all possible screen sizes and different OS is particularly tricky, repetitive and not interesting. The HTML dependency is downloaded with create_dependency(\"pwacompat\", options = charpente_options(bundle = FALSE)). Don’t forget to update the add_dependencies list by including the two new dependencies: f7_page &lt;- function(..., navbar, toolbar, title = NULL, options = NULL) { config_tag &lt;- tags$script( type = &quot;application/json&quot;, `data-for` = &quot;app&quot;, jsonlite::toJSON( x = options, auto_unbox = TRUE, json_verbatim = TRUE ) ) # create body_tag body_tag &lt;- tags$body( tags$div( id = &quot;app&quot;, tags$div( class = &quot;view view-main&quot;, tags$div( class = &quot;page&quot;, navbar, toolbar, tags$div( class = &quot;page-content&quot;, ... ) ) ) ), config_tag ) tagList( tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot; ), tags$meta( name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot; ), tags$meta( name = &quot;theme-color&quot;, content = &quot;#2196f3&quot; ), tags$title(title) ), add_dependencies( body_tag, deps = c(&quot;framework7&quot;, &quot;shinyMobile&quot;, &quot;pwa&quot;, &quot;pwacompat&quot;) ) ) } If you do devtools::load_all() and run the app again, you should see the new dependencies in the head (Figure 25.3). FIGURE 25.3: New PWA dependencies in the head tag. Yet, according to Figure 25.4, we still miss the service worker, as shown in the manifest diagnostic. This shows how powerful are the developer tools and the end user is always guided step by step. FIGURE 25.4: Missing service worker registration. 25.3.3 Service worker and offline page The second mandatory step to make our app installable is the service worker. We borrowed the code from web.dev. set_pwa copies this code in the www folder of the provided app: /* Copyright 2015, 2019, 2020 Google LLC. All Rights Reserved. Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ // Incrementing OFFLINE_VERSION will kick off the install event and force // previously cached resources to be updated from the network. const OFFLINE_VERSION = 1; const CACHE_NAME = &quot;offline&quot;; // Customize this with a different URL if needed. const OFFLINE_URL = &quot;offline.html&quot;; self.addEventListener(&quot;install&quot;, (event) =&gt; { event.waitUntil( (async () =&gt; { const cache = await caches.open(CACHE_NAME); // Setting {cache: &#39;reload&#39;} in the new request will ensure that the // response isn&#39;t fulfilled from the HTTP cache; i.e., it will be from // the network. await cache.add(new Request(OFFLINE_URL, { cache: &quot;reload&quot; })); })() ); // Force the waiting service worker to become the active service worker. self.skipWaiting(); }); self.addEventListener(&quot;activate&quot;, (event) =&gt; { event.waitUntil( (async () =&gt; { // Enable navigation preload if it&#39;s supported. // See https://developers.google.com/web/updates/2017/02/navigation-preload if (&quot;navigationPreload&quot; in self.registration) { await self.registration.navigationPreload.enable(); } })() ); // Tell the active service worker to take control of the page immediately. self.clients.claim(); }); self.addEventListener(&quot;fetch&quot;, (event) =&gt; { // We only want to call event.respondWith() if this is a navigation request // for an HTML page. if (event.request.mode === &quot;navigate&quot;) { event.respondWith( (async () =&gt; { try { // First, try to use the navigation preload response if it&#39;s supported. const preloadResponse = await event.preloadResponse; if (preloadResponse) { return preloadResponse; } // Always try the network first. const networkResponse = await fetch(event.request); return networkResponse; } catch (error) { // catch is only triggered if an exception is thrown, which is likely // due to a network error. // If fetch() returns a valid HTTP response with a response code in // the 4xx or 5xx range, the catch() will NOT be called. console.log(&quot;Fetch failed; returning offline page instead.&quot;, error); const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match(OFFLINE_URL); return cachedResponse; } })() ); } // If our if() condition is false, then this fetch handler won&#39;t intercept the // request. If there are any other fetch handlers registered, they will get a // chance to call event.respondWith(). If no fetch handlers call // event.respondWith(), the request will be handled by the browser as if there // were no service worker involvement. }); This service worker redirects the end user to the offline cached page whenever the app is offline, thereby offering a better user experience. It explicitly targets an offline.html page. Therefore, we strongly advise to keep the same file names. The next step is to mention and register the service worker. Framework7 has a dedicated module in the app configuration. We modify init.js and run build_js() to update the minified file: serviceWorker: { path: window.location.pathname + &#39;service-worker.js&#39;, scope: window.location.pathname } If the process is successful, you get the result shown in Figure 25.5. FIGURE 25.5: Registered service worker. The new standard imposes to return a valid response when the app is offline. The offline page is also copied from {charpente}: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;You are offline&lt;/title&gt; &lt;!-- inline the webpage&#39;s stylesheet --&gt; &lt;style&gt; body { font-family: helvetica, arial, sans-serif; margin: 2em; } h1 { font-style: italic; color: #373fff; } p { margin-block: 1rem; } button { display: block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;You are offline&lt;/h1&gt; &lt;p&gt;Click the button below to try reloading.&lt;/p&gt; &lt;button type=&quot;button&quot;&gt;⤾ Reload&lt;/button&gt; &lt;!-- inline the webpage&#39;s javascript file --&gt; &lt;script&gt; document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, () =&gt; { window.location.reload(); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Now, let’s audit our app again: congrats! Our app is installable, reliable, although further PWA optimization may be provided. FIGURE 25.6: Installable shinyMobile app. 25.3.4 Disable PWA for the end user With the above approach, {shinyMobile} will always look for a service worker to register. Particularly, this raises an error in case no service worker is found on the server. What if the user don’t want to always create a PWA, let’s say for less important applications? We may add a parameter to the f7Page, for instance allowPWA that is either TRUE or FALSE, store its value in the body data-pwa attribute and recover it on the JS side in init.js: // check if the app is intended to be a PWA var isPWA = $(&#39;body&#39;).attr(&#39;data-pwa&#39;) === &quot;true&quot;; if (isPWA) { config.serviceWorker = { path: window.location.pathname + &quot;service-worker.js&quot;, scope: window.location.pathname }; } We then only create config.serviceWorker if the user specified allowPWA = TRUE. 25.4 Handle the installation It is a great opportunity to propose a custom installation experience. Note: To be able to install the app, make sure to replace start_url by the url where the app is deployed like https://dgranjon.shinyapps.io/installable-pwa-app/ for instance. Missing that step would cause an issue during the service worker registration. Once the installation criteria are met, the web browser raises the beforeinstallprompt event, except on iOS platform, that is not yet compatible. To check it, we edit the init.js script and add: let deferredPrompt; window.addEventListener(&#39;beforeinstallprompt&#39;, (e) =&gt; { // Prevent the mini-infobar from appearing on mobile e.preventDefault(); // Stash the event so it can be triggered later. deferredPrompt = e; }); This code adds an event listener to the window, prevents it from showing at start with e.preventDefault and captures it in an external variable called deferredPrompt. After, we create our custom piece of UI that will trigger the prompt install. We can benefit from the rich Framework7 interface and display a toast containing an install button. The instantiation is fairly simple and follows the pattern app.&lt;COMPONENT&gt;.create(parameters): // Create custom install UI var installToast = app.toast.create({ position: &#39;center&#39;, text: &#39;&lt;button id=&quot;install-button&quot; class=&quot;toast-button button color-green&quot;&gt;Install&lt;/button&gt;&#39;, }); We give it an id so as to call it later. We edit the beforeinstallprompt event listener to show the toast: let deferredPrompt; window.addEventListener(&#39;beforeinstallprompt&#39;, (e) =&gt; { // Prevent the mini-infobar from appearing on mobile e.preventDefault(); // Stash the event so it can be triggered later. deferredPrompt = e; // Show install trigger installToast.open(); }); Note: with jQuery like $(window).on('beforeinstallprompt', ...), we would capture the event with e.originalEvent! Then we register a second event listener, which fires on the toast button click. We should wait a bit of time so that the toast exists with app.utils.nextTick, which is, as a reminder, an internal equivalent to setTimeout. We first close the toast, call the prompt method on the deferred event and log the result: app.utils.nextTick(function() { $(&#39;#install-button&#39;).on(&#39;click&#39;, function() { // close install toast installToast.close(); if (!deferredPrompt) { // The deferred prompt isn&#39;t available. return; } // Show the install prompt. deferredPrompt.prompt(); // Log the result deferredPrompt.userChoice.then((result) =&gt; { console.log(&#39;👍&#39;, &#39;userChoice&#39;, result); // Reset the deferred prompt variable, since // prompt() can only be called once. deferredPrompt = null; }); }); }, 500); We run build_js() and deploy the app to shinyapps.io. Figure 25.7 illustrates the install prompt window that appears to install the app. Once installed, the beforeinstallprompt event does not fire anymore and the app may be launched as a standalone app, for instance on macOSX (Figure 25.8) FIGURE 25.7: Install prompt window. FIGURE 25.8: Installed PWA on macOSX. On Figure 25.8, the blue window color corresponds to the tags$meta(name = \"theme-color\", content = \"#2196f3\"), of the f7_page layout element. Whenever the connection is lost, the redirection occurs to the offline.html page, as shown on Figure 25.9. FIGURE 25.9: Offline HTML template. The installable-pwa-test repository contains the final code to reproduce the previous steps. 25.5 Workbox Workbox is a more robust alternative to the approach described above. Interestingly, Framework7 uses Workbox as a service worker generator by default. It does: pre-caching of dependencies like CSS and JS but also images and Google fonts to improve performances. Improve offline experience. … 25.6 Other resources The process described above works perfectly for any Shiny template. Other packages like {shiny.pwa} create a PWA compatible structure on the fly. "],["mobile-widgets.html", "Chapter 26 Design widgets 26.1 Build the UI 26.2 Widgets without preexisting UI 26.3 Initialize the widget 26.4 Update widgets", " Chapter 26 Design widgets Framework7 brings dozen of different widgets like a photo browser, virtual lists (high performance lists), messages, notifications, toasts, … Looking at the documentation, the API is most of the time always the same that is, we create the widget: app.widget.create(parameters); and we update, open or close it later: app.widget.update(newParameters); app.widget.open(); app.widget.close(); I must admit, there are few deviations like the navbar (app.navbar.show()) or the dialog but we have enough common points to design a main wrapper that creates any widget and update/open/close it. What we do below significantly simplify the R/JS API at a price to slightly reduce the customization. 26.1 Build the UI We know that JavaScript must receive a configuration object to create the widget instance. As shown earlier in this book, there is a simple way to achieve this. Let’s consider the gauge example. On the UI side, we expect to have: &lt;div class=&quot;gauge&quot;&gt;&lt;/div&gt; Upon instantiating, Framework7 populates this container with the relevant tags. The f7_gauge function creates a div tag with the gauge class as well as a configuration tag: f7_gauge &lt;- function(id, value, options = NULL) { if (is.null(options[[&quot;valueText&quot;]])) options[[&quot;valueText&quot;]] &lt;- paste(value * 100, &quot;%&quot;) gaugeProps &lt;- c(list(value = value), options) gaugeConfig &lt;- shiny::tags$script( type = &quot;application/json&quot;, `data-for` = id, jsonlite::toJSON( x = gaugeProps, auto_unbox = TRUE, json_verbatim = TRUE ) ) shiny::tags$div( class = &quot;gauge&quot;, id = id, gaugeConfig ) } We provide a default for the valueText option that should display the current value followed by a % symbol. Note that the class is crucial to target the relevant tag on the JS side. All other widgets will moreless follow the same scheme. Be careful about partial matching with the $ operator. This is the reason why we used [[ instead: with $, valueText would be matched with valueTextColor, leading to misleading behavior. 26.2 Widgets without preexisting UI There are few widgets like toasts, notifications that don’t have any predefined UI element when the app starts. In this case, we simply send the configuration to JS, through the session: f7_notif &lt;- function(id = NULL, text, options = NULL, session = shiny::getDefaultReactiveDomain()) { if (!is.null(options$icon)) options$icon &lt;- as.character(options$icon) message &lt;- c(dropNulls(list(id = id, text = text)), options) # see my-app.js function sendCustomMessage(&quot;notification&quot;, message, session) } Pay attention to the icon element: we can’t convert shiny tags to JSON, so they must be converted to character first. If multiple parameters should contain tags, you must treat them accordingly! 26.3 Initialize the widget On the JS side, we create a new script, widgets.js library(charpente) create_js(&quot;widgets&quot;) We set an array containing all compatible widget names in two categories and concatenate in a widgets element: const uiWidgets = [&quot;gauge&quot;, &quot;swiper&quot;, &quot;searchbar&quot;]; const serverWidgets = [&quot;toast&quot;, &quot;photoBrowser&quot;, &quot;notification&quot;]; const widgets = uiWidgets.concat(serverWidgets); We then define the activateWidget function, only considering UI widgets. Since we have two widgets categories, this function first checks whether the widget is part of the uiWidgets array: if (uiWidgets.indexOf(widget) &gt; -1) { // Do things } As there may be multiple widgets of the same time to initialize, we must loop through all possible elements. This is where the class is important and must match the widget name. For instance, the gauge has the gauge class and the methods are always app.gauge.. How do we loop through multiple widgets? We use the jQuery each method: if (uiWidgets.indexOf(widget) &gt; -1) { $(&quot;.&quot; + widget).each(function() { // Do things } } We see that $(\".\" + widget) gives $(\".gauge) when the widget is a gauge, which will target all gauges one by one. Then for each gauge, we extract the configuration containing all options passed by the end user. Remember that each element has a unique id. We extract the current element $(this) in the $el variable and search for a script tag pointing to the unique tag having $el.attr(\"id\") as id. The configuration is parsed to convert it to an object. Note that most of the time, Framework7 expects to have a el attributes which simply contains the CSS selector of the current element, in other words its unique id '#' + $el.attr(\"id\"): if (uiWidgets.indexOf(widget) &gt; -1) { $(&quot;.&quot; + widget).each(function() { var $el = $(this); var config = $(document).find( &quot;script[data-for=&#39;&quot; + $el.attr(&quot;id&quot;) + &quot;&#39;]&quot; ); config = JSON.parse(config.html()); // add the id config.el = &#39;#&#39; + $el.attr(&quot;id&quot;); } } The final step is to initialize the widget, which is quite straightforward if we notice that app.gauge is the same as app[\"gauge\"]. We obtain the general code: app[widget].create(config); For the server widgets, it is even simpler. We recover the message with a Shiny.addCustomMessageHandler(\"type\", callback) and initialize it. The only possible source of problem is the custom message type that must be the same as the one specified in the R function with session$sendCustomMessage(\"type\", message). We create an else statement following the if condition and put that code inside: Shiny.addCustomMessageHandler(widget, function(message) { if (message.id !== undefined) { message.on = { opened: function() { Shiny.setInputValue(message.id, true); }, closed: function() { Shiny.setInputValue(message.id, false); app.data[widget][message.id].destroy(); } }; } app[widget].create(message).open(); }); As shown in the above code, we can also immediately open the widget by chaining methods. Moreover, it is always good practice to let Shiny know about the widget state, that is whether it is currently opened. This is the reason why we added a on property to the message. All widgets trigger events, for instance notifications have the notification:opened and notification:closed. For each event, we set an input value on the fly, with Shiny.setInputValue. This way, the template users are able to know exactly when the widget is closed or opened and trigger any subsequent action. This obviously requires the widget to pass an optional id attribute to ensure the uniqueness! The full JavaScript code may be found below. // Instantiate a widget activateWidget = function(widget) { // Handle ui side widgets if (uiWidgets.indexOf(widget) &gt; -1) { $(&quot;.&quot; + widget).each(function() { var $el = $(this); var config = $(document).find( &quot;script[data-for=&#39;&quot; + $el.attr(&quot;id&quot;) + &quot;&#39;]&quot; ); config = JSON.parse(config.html()); // add the id config.el = &#39;#&#39; + $el.attr(&quot;id&quot;); // feed the create method app[widget].create(config); }); } else { // This concerns toasts, notifications, photoBrowser, ... // that don&#39;t have any UI element in the DOM before creating // the widget instance. Shiny.addCustomMessageHandler(widget, function(message) { if (message.id !== undefined) { message.on = { opened: function() { Shiny.setInputValue(message.id, true); }, closed: function() { Shiny.setInputValue(message.id, false); app.data[widget][message.id].destroy(); } }; } app[widget].create(message).open(); }); } }; The final step is to activate all widgets. We proceed with a loop: // Loop over all widgets to activate them widgets.forEach(function(w) { activateWidget(w); }); Let’s try below with a notification example, where we capture the state of the notification in an input element: library(shiny) ui &lt;- f7_page( navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot;, options = list( theme = &quot;ios&quot;, version = &quot;1.0.0&quot;, taphold = TRUE, color = &quot;#42f5a1&quot;, filled = TRUE, dark = TRUE ) ) server &lt;- function(input, output, session) { observe({ f7_notif(id = &quot;welcome&quot;, &quot;Helloooooo&quot;, options = list(closeTimeout = 2000)) }) observeEvent(input$welcome, { shiny::showNotification(sprintf(&quot;Notification is %s&quot;, input$welcome)) }) } shinyApp(ui, server) 26.4 Update widgets We would like to develop a similar generalized interface to update any element in the DOM. Instead of having update_f7_gauge, update_f7_swiper, … we want an update_f7_instance function. We leverage the app.data element that stores all instances by widget type. In the previous part, we already created a cache for tooltips, so let’s do it for gauges: config.data = function() { return { // any other widget type to cache ... gauge: [] }; }; At that step, the array name must be the same as the app method. For instance, we have app.gauge, which means that we should create config.data.gauge and not config.data.gauges, as it would lead to errors later. Once the cache is available, we have to modify the JavaScript that creates the widget instance, to store the new instance in the cache. We add the following code, where w refers to the widget instance: // ui widgets app.data[widget][$el.attr(&quot;id&quot;)] = w; This manipulation does not make sense for server widgets! The activateWidget function should be: // Instantiate a widget activateWidget = function(widget) { // Handle ui side widgets if (uiWidgets.indexOf(widget) &gt; -1) { $(&quot;.&quot; + widget).each(function() { var $el = $(this); var config = $(document).find( &quot;script[data-for=&#39;&quot; + $el.attr(&quot;id&quot;) + &quot;&#39;]&quot; ); config = JSON.parse(config.html()); // add the id config.el = &#39;#&#39; + $el.attr(&quot;id&quot;); // feed the create method var w = app[widget].create(config); // Store the widget instance in the app data cache app.data[widget][$el.attr(&quot;id&quot;)] = w; }); } else { // This concerns toasts, notifications, photoBrowser, ... // that don&#39;t have any UI element in the DOM before creating // the widget instance. Shiny.addCustomMessageHandler(widget, function(message) { if (message.id !== undefined) { message.on = { opened: function() { Shiny.setInputValue(message.id, true); }, closed: function() { Shiny.setInputValue(message.id, false); app.data[widget][message.id].destroy(); } }; } var w = app[widget].create(message); w.open(); }); } }; Once done, this is time to design update_f7_instance. The R code sends a message to the current session containing: The id of the element to update. The new configuration. Since we send a JSON, the hardest part is to correctly process shiny tags. How do we track shiny tags. As a reminder, let’s run the code below: class(shiny::div()) ## [1] &quot;shiny.tag&quot; class(shiny::tagList(shiny::div(), shiny::h1())) ## [1] &quot;shiny.tag.list&quot; &quot;list&quot; For each configuration element, we must check whether its class contains shiny.tag or shiny.tag.list and convert it to a character. Moreover, it may contain a nested list like this: options = list( buttons = list( list( text = &quot;Some text&quot;, icon = f7Icon(&quot;info&quot;), color = &quot;pink&quot; ) ) ) In that case, our function must be recursive and call itself whenever an item having the list class is found. If the element is simple text, numeric, we return it as is. We finally get: update_f7_instance &lt;- function(id, options, session = shiny::getDefaultReactiveDomain()) { # Convert any shiny tag into character so that toJSON does not cry listRenderTags &lt;- function(l) { lapply( X = l, function(x) { if (inherits(x, c(&quot;shiny.tag&quot;, &quot;shiny.tag.list&quot;))) { as.character(x) } else if (inherits(x, &quot;list&quot;)) { # Recursive part listRenderTags(x) } else { x } } ) } options &lt;- listRenderTags(options) message &lt;- list(id = id, options = options) sendCustomMessage(&quot;update-instance&quot;, message, session) } On the JS side, we receive the message (still in the widget.js script): Shiny.addCustomMessageHandler(&#39;update-instance&#39;, function(message) { // Treat message ... }); All widgets are stored by type in the app data, for instance, the element having for unique id mygauge is located in app.data[\"gauge\"][\"mygauge\"]. As there is no easy way to recover the widget type given its id, the first step of the message handler is to find where our instance is located. We design a nested for loop. The outer loop scans all app.data properties (ie widget categories) and the inner loop scans all existing instances for each category. Whenever, the message.id matches the instance name, we store the corresponding widget category in a variable: var instanceFamily; for (const property in app.data) { for (const e in app.data[property]) { if (e === message.id) { instanceFamily = property; } } } We then access the old instance using the newly defined variable and the message.id. We capture its parameters located in oldInstance.params. From there, multiple options are available: We extend the old configuration by the new one. We entirely overwrite the existing options. Below, we decided to merge the old and new configurations using app.utils.extend: var oldInstance = app.data[instanceFamily][message.id]; var oldConfig = oldInstance.params; var newConfig = app.utils.extend(oldConfig, message.options); The next step is to destroy the old instance, initialize the new instance and refresh the app.data cache: // Destroy old instance oldInstance.destroy(); // Create new config var newInstance = app[instanceFamily].create(newConfig); // Update app data app.data[instanceFamily][message.id] = newInstance; The whole code is located below: Shiny.addCustomMessageHandler(&#39;update-instance&#39;, function(message) { // Recover in which array is stored the given instance. // Uniqueness is ensured since HTML id are supposed to be unique. var instanceFamily; for (const property in app.data) { for (const e in app.data[property]) { if (e === message.id) { instanceFamily = property; } } } var oldInstance = app.data[instanceFamily][message.id]; var oldConfig = oldInstance.params; var newConfig = app.utils.extend(oldConfig, message.options); // Destroy old instance oldInstance.destroy(); // Create new config var newInstance = app[instanceFamily].create(newConfig); // Update app data app.data[instanceFamily][message.id] = newInstance; }); Below is an example showing how to update a gauge from the server. As you may notice, this approach is not perfect as the user has to explicitly update the valueText field so that it reflects the new value. Similarly, you may ask why the gauge value has to be between 0 and 1, instead of 0 and 100. The reason comes from the Framework7 API. One might be tempted to convert the value inside f7_gauge (so that the user only provides number between 0 and 100), but this would also mean to manually convert the value in the update_f7_instance function later. As stated in previous chapters, there is always a compromise to do between a simple API easy to maintain (for the developer) and user experience. This issue may/should be solved by a comprehensive documentation. ui &lt;- f7_page( f7_gauge( &quot;mygauge&quot;, value = 0.1, options = list( type = &quot;semicircle&quot;, borderColor = &quot;#2196f3&quot;, borderWidth = 10, valueFontSize = 41, valueTextColor = &quot;#2196f3&quot;, labelText = &quot;amount of something&quot; ) ), navbar = f7_navbar(&quot;Title&quot;), toolbar = f7_toolbar(), title = &quot;shinyMobile&quot;, options = list( theme = &quot;ios&quot;, version = &quot;1.0.0&quot;, taphold = TRUE, color = &quot;#42f5a1&quot;, filled = TRUE, dark = TRUE ) ) server &lt;- function(input, output, session) { observe({ Sys.sleep(2) update_f7_instance( &quot;mygauge&quot;, options = list( value = 0.75, valueText = &quot;75 %&quot;, labelText = &quot;New label!&quot; ) ) }) } shinyApp(ui, server) "],["mobile-going-further.html", "Chapter 27 Going further 27.1 Improved disconnect screen", " Chapter 27 Going further 27.1 Improved disconnect screen As depicted on Figure 27.1, having the classic Shiny disconnect screen in a mobile device is not that beautiful, especially knowing about all the Framework7 capabilities. FIGURE 27.1: Vanilla Shiny disconnect screen. Let’s do better. Upon disconnection, we want to display a toast with 2 buttons: - A reload button that reloads the window and re-initialize the app. This button calls location.reload() upon click. - A reconnect button, that tries to reconnect with the server websocket, so that we don’t lose any input, output elements. This button calls Shiny.shinyapp.reconnect() upon click. First thing first, how do we know when shiny is disconnected? As described in Chapter 10, whenever the client socket connection is closed, for any reason, the shiny:disconnected event is triggered: socket.onclose = function() { // These things are needed only if we&#39;ve successfully opened the // websocket. if (hasOpened) { $(document).trigger({ type: &#39;shiny:disconnected&#39;, socket: socket }); self.$notifyDisconnected(); } self.onDisconnected(); // Must be run before self.$removeSocket() self.$removeSocket(); } This allows us to listen to that event on the JS side: $(document).on(&quot;shiny:disconnected&quot;, function(event) { // Do things }); The next step is to remove the default shiny reconnect elements. They are added by the onDisconnected method, that adds a disconnect overlay (gray-out screen) and optionally a reconnect notification: this.onDisconnected = function() { // Add gray-out overlay, if not already present var $overlay = $(&#39;#shiny-disconnected-overlay&#39;); if ($overlay.length === 0) { $(document.body).append(&#39;&lt;div id=&quot;shiny-disconnected-overlay&quot;&gt;&lt;/div&gt;&#39;); } // To try a reconnect, both the app (this.$allowReconnect) and the // server (this.$socket.allowReconnect) must allow reconnections, or // session$allowReconnect(&quot;force&quot;) was called. The &quot;force&quot; option should // only be used for testing. if ((this.$allowReconnect === true &amp;&amp; this.$socket.allowReconnect === true) || this.$allowReconnect === &quot;force&quot;) { var delay = reconnectDelay.next(); exports.showReconnectDialog(delay); this.$scheduleReconnect(delay); } } To remove them, there are multiple alternatives. The easiest way is to wait for the client to be connected, that is listening to shiny:connected, and set the Shiny.shinyapp.onDisconnected method to only add the gray overlay. Note: before modifying any vanilla shiny elements, make sure to check all the possible side effects! // remove shiny reconnect stuff; $(document).on(&quot;shiny:connected&quot;, function(event) { Shiny.shinyapp.onDisconnected = function() { // Add gray-out overlay, if not already present var $overlay = $(&#39;#shiny-disconnected-overlay&#39;); if ($overlay.length === 0) { $(document.body).append(&#39;&lt;div id=&quot;shiny-disconnected-overlay&quot;&gt;&lt;/div&gt;&#39;); } }; }); We edit the previous disconnected event listener to add a custom Framework7 toast, which closes upon click: $(document).on(&quot;shiny:disconnected&quot;, function(event) { var reconnectToast = app.toast .create({ icon: &#39;&lt;i class=&quot;icon f7-icons&quot;&gt;bolt_fill&lt;/i&gt;&#39;, position: &quot;center&quot;, text: &#39;Oups... disconnected &lt;/br&gt; &lt;/br&gt; &lt;div class=&quot;row&quot;&gt;&lt;button onclick=&quot;Shiny.shinyapp.reconnect();&quot; class=&quot;toast-button button color-green col&quot;&gt;Reconnect&lt;/button&gt;&lt;button onclick=&quot;location.reload();&quot; class=&quot;toast-button button color-red col&quot;&gt;Reload&lt;/button&gt;&lt;/div&gt;&#39; }) .open(); // close toast whenever a choice is made ... $(&quot;.toast-button&quot;).on(&quot;click&quot;, function() { reconnectToast.close(); }); }); Result is shown Figure 27.2. FIGURE 27.2: Vanilla Shiny disconnect screen. The above JS code ignores the user reconnect setup and proposes to reconnect regardless of the session$allowReconnect configuration. If you want to keep the original behavior, you may add the following condition before showing the toast: if ((Shiny.shinyapp.$allowReconnect === true &amp;&amp; Shiny.shinyapp.$socket.allowReconnect === true) || Shiny.shinyapp.$allowReconnect === &quot;force&quot;) { // Toast logic } "],["going-further-reactR.html", "Chapter 28 R + Shiny + React: welcome {reactR} 28.1 Quick introduction to React 28.2 Introduction to {reactR}", " Chapter 28 R + Shiny + React: welcome {reactR} React is an open source library designed to quickly develop user interfaces or UI components, on the front end. It has been developed by Facebook and the community (more than 1500 contributors) and made public in May 29 2013. It is currently used worldwide and has around 163k stars on the Github ranking and widely impacts the mobile market, through the React Native library. React is also really convenient to develop attractive documentations with docusaurus. If you ever have built user interfaces with pure JS, you might like React! Below, we give a short introduction to the React ecosystem and see how we can benefit from it from the R Shiny side. 28.1 Quick introduction to React To understand React there are few prerequisites notably basic HTML/CSS/JS knowledge, especially JS modules (see section 9.4.6.1). However, if you managed to reach this chapter, you should not worry too much. 28.1.1 Setup Node and npm are required. If you are not sure, run: node -v npm -v At that stage it is also good to have yarn as we’ll need it for {reactR}. If nothing is returned, please refer to section 9.3.1. To initiate a React project, we leverage the npx command: npx create-react-app &lt;PROJECT_NAME&gt; Replace &lt;PROJECT_NAME&gt; by the real name of your project. If this seems intimidating, keep in mind this is the same concept has using the {golem} package to initiate the creation of robust shiny projects, except that we work from the terminal. Once done (the package initialization takes some time), move to the project folder and launch the demo app: cd &lt;PROJECT_NAME&gt; &amp;&amp; npm start If you have yarn, yarn start also works. You should see something similar to Figure 28.1. FIGURE 28.1: npm start opens the react app 28.1.2 Basics We are now all set up to start learning the basics of React. Among all created files, notice the /src/app.js file. Inside the App function, we remove all the content inside the return statement to put a simple &lt;h1&gt;Hello, world!&lt;/h1&gt; HTML title. We also clean the imports as we don’t need any CSS and logo anymore. We obtain: function App() { return ( &lt;h1&gt;Hello, world!&lt;/h1&gt; ); } export default App; // don&#39;t remove, this is needed by index.js Once done, we run npm build (or yarn build), to rebuild the JS code and npm start to restart the server and preview the app. In practice, once the server is launched, there is no need to restart it whenever the code is updated. A simple save will refresh the interface! The code you see above is a React component. The definition is rather simple: it is a function that returns a moreless complex piece of UI. How are components rendered by React? So far, we didn’t have a look at the /src/index.js script. Inside we find: ReactDOM.render( App, document.getElementById(&#39;root&#39;) ); Note: recent version of npx create-react-app have &lt;React.StrictMode&gt;&lt;App /&gt;&lt;/React.StrictMode&gt; instead of App, which does the same thing. You may also find &lt;App /&gt;. In practice, we rarely modify this part. In short, this inserts the App component inside the element having root as id in the main HTML page. This HTML skeleton may be found in the public/index.html folder. You may guess that at the end of the day, our app will be composed of multiple bricks and called ReactDOM.render on the top level component. 28.1.2.1 About JSX We just wrote our first React component. Didn’t you notice something weird in that code? JS and HTML are mixed, in what we called JSX, that is a syntax extension to JS. JSX makes the code less verbose, for instance: React.createElement( &#39;h1&#39;, &#39;Hello, world!&#39; ); does exactly the same thing as above but when the code becomes more complex, it is nearly impossible to read. Let’s see how to pass variables into JSX. We want to show Hello, &lt;Your Name&gt;, we store the name in a variable and modify the app.js code accordingly: function App() { const name = &quot;David&quot;; return ( &lt;h1&gt;Hello, {name}&lt;/h1&gt; ); } Expressions are passed within curly brackets {expression} and you may even call functions inside. Tag attributes also require curly brackets. Let’s modify the title tag to give it a color and a size. function App() { const name = &quot;David&quot;; return ( &lt;h1 style={color: &quot;red&quot;, fontSize: 40}&gt;Hello, {name}&lt;/h1&gt; ); } Try to save. Why does this fail? We can’t pass multiple object properties inside a single {}. We need either double brackets like {{object properties: values, ...}} or to store the object in a variable before: function App() { const name = &quot;David&quot;; return ( &lt;h1 style={{color: &quot;red&quot;, fontSize: 40}}&gt;Hello, {name}&lt;/h1&gt; ); } // OR function App() { const name = &quot;David&quot;; const myStyle = { color: &quot;red&quot;, fontSize: 40 } return ( &lt;h1 style={myStyle}&gt;Hello, {name}&lt;/h1&gt; ); } Notice that we write CSS properties following the camelCase syntax, font-size being equivalent to fontSize. 28.1.2.2 Combining components The whole interest is to combine multiple components to create reusable pieces. We edit the above code to create a SayHello component. Notice the props parameter. It is a way to pass configuration from the parent component. In that case, we want to display the person name, that is props.name. In the meantime, we edit the App parent component and call SayHello three times, passing a different name like &lt;SayHello name=\"David\" /&gt; (this is the reason why we recover props.name in the lower level component): function SayHello(props) { return ( &lt;h1&gt;Hello, {props.name}&lt;/h1&gt; ); } function App() { return( &lt;&gt; &lt;SayHello name=&quot;David&quot; /&gt; &lt;SayHello name=&quot;Lisa&quot; /&gt; &lt;SayHello name=&quot;Simon&quot; /&gt; &lt;/&gt; ); } Notice the enclosing &lt;&gt;...&lt;/&gt;. This is called a React fragment and useful if we don’t want to insert any extra &lt;div&gt; in the DOM. We could be even more efficient by leveraging the lists capabilities. We create an array of names and apply the map method to return the corresponding &lt;SayHello /&gt; sub-component: const names = [&quot;David&quot;, &quot;Lisa&quot;, &quot;Simon&quot;]; function App() { const sayHelloToAll = names.map((name) =&gt; &lt;SayHello key={name} name={name} /&gt;); return(sayHelloToAll); } By convention, all elements inside a map require keys. Props are read-only and must not be modified withing their own component. How do we update components? 28.1.2.3 Component state A component state is private and controlled by this same component. Since React 16.8 and the introduction of hooks, this is not necessary to convert the component function to a class. The easiest example to illustrate hooks capabilities is the button. Each time, we click on a button, we want to keep the current number of clicks in a state, like the shiny::actionButton. We start by importing the useState function from react and create a new ActionButton component. Inside, we set the state with useState that create the state variable count as well as the function to update it, namely setCount. This way to create 2 variables at once is called array destructuring. We set the initial number of counts to 0: import {useState} from &#39;react&#39;; function ActionButton() { const [count, setCount] = useState(0); } Next step is to create the button skeleton. We provide an onClick property that updates the button state.Inside, we write an anonymous function which calls setCount and increment the count value by 1. At this point, you may replace the app.js content by: import {useState} from &#39;react&#39;; function ActionButton() { const [count, setCount] = useState(0); return( &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Number of clicks: {count} &lt;/button &gt; ); } function App() { return ( &lt;ActionButton /&gt; ); } export default App; We may improve the previous app and add a reset button within the ActionButton component that sets the count back to 0: function ActionButton() { const [count, setCount] = useState(0); return( &lt;&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Number of clicks: {count} &lt;/button &gt; &lt;button onClick={() =&gt; setCount(0)}&gt; Reset &lt;/button &gt; &lt;/&gt; ); } It would make more sense to only show the reset button once the button has been clicked, at least once. We define the isResetVisible variable which is true whenever the count is higher than 0 and false if the count is 0. We store the reset button in a variable and only return something if isResetVisible is true: function ActionButton() { const [count, setCount] = useState(0); const isResetVisible = count &gt; 0 ? true : false; let resetButton; if (isResetVisible) { resetButton = &lt;button onClick={() =&gt; setCount(0)}&gt; Reset &lt;/button &gt; } return ( &lt;&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Number of clicks: {count} &lt;/button &gt; {resetButton} &lt;/&gt; ); } Now that you get a better understanding of how React works, let’s see how to use it with Shiny. 28.2 Introduction to {reactR} The React ecosystem is rich and provides many plug and play boilerplate. For instance, {reactable} is an HTML widget developed on top of the react-table library. What about the modern React Argon design system, shown Figure 28.2. FIGURE 28.2: Argon design template with React In this part, we see how to leverage {reactR} to bring Argon design React to Shiny. To install {reactR}: install.packages(&quot;reactR&quot;) remotes::install_github(&quot;react-R/reactR&quot;) 28.2.1 Scaffold inputs 28.2.1.1 Setup {reactR} exposes the scaffoldReactShinyInput that creates the necessary pieces of code to get started with the input development (see Figure 28.3): An &lt;input_name&gt;.R file containing the input skeleton as well as its related update function. It also creates a custom HTML dependency pointing to the input JS logic. A jsx file with a boilerplate to start developing the input JS logic. A package.json file containing dependencies. Besides, providing an optional dependency with a name and version taken from npm installs all necessary dependencies in the package.json file. In our case, we want to build on top of Argon from here: path &lt;- file.path(tempdir(), &quot;mypkg&quot;) usethis::create_package(path, rstudio = TRUE) reactR::scaffoldReactShinyInput(&quot;argon_action_button&quot;, list(name = &quot;argon-design-system-react&quot;, version = &quot;1.1.0&quot;)) FIGURE 28.3: Package initialization with {reactR} Note that {reactR} provides webpack as JS manager. To build the JS code we go to the RStudio terminal tab (or any terminal) and run at the package root: yarn install yarn run webpack This installs all dependencies listed in the package.json file and create a package-lock.json file. If you ever used {renv}, this is very similar and guarantees isolation of your package. All dependencies are stored in the node_modules folder. Note: I encountered few cases where the yarn install failed. In that case, you may try npm i argon-design-system-react and also check your VPN settings. The run webpack command triggers compiles the JS in production ready code. Should you need to customize the build pipeline, the webpack configuration is located in webpack.config.js. On the R side, the generated JS file is referenced in an HTML dependencies, located in the &lt;input_name&gt;.R file. 28.2.1.2 Implement the input JS logic It’s time to develop the logic. The Argon documentation provides a boilerplate, which we slightly simplified, as show below: import { reactShinyInput } from &#39;reactR&#39;; // reactstrap components import { Button } from &quot;reactstrap&quot;; function ArgonButton() { return ( &lt;Button color=&quot;primary&quot; type=&quot;button&quot;&gt; Button &lt;/Button&gt; ); } reactShinyInput(&#39;.argon_action_button&#39;, &#39;mypkg.argon_action_button&#39;, ArgonButton); Notice the first two lines where we import the reactShinyInput function from the {reactR} JS core and reactstrap, a React powered Bootstrap 4 library. reactShinyInput provides a wrapper to automatically bind the input element. This is extremely convenient as it allows to solely focus on the component logic rather than binding it to the shiny system. It takes three parameters: The element class which is obtained from the R side by createReactShinyInput. The input binding name which is useful to store a reference in the Shiny.InputBindings registry. The React component function. There is an optional fourth parameter allowing to pass custom options like rate policies. Overall, reactShinyInput extends the Shiny.InputBinding class by providing extra methods like: getInputConfiguration(el) { return $(el).data(&#39;configuration&#39;); } setInputConfiguration(el, configuration) { $(el).data(&#39;configuration&#39;, configuration); } getInputConfiguration and setInputConfiguration, respectively get and set the user provided configuration, passed in the createReactShinyInput R side function. Under the hood, in addition to ship the {reactR}, React, ReactTools HTML dependencies (and any user defined custom dependency), createReactShinyInput does generate three tag elements: The first tag is the element placeholder containing the unique id. React will insert the component inside this target with ReactDOM.render. The second tag is a script containing the value passed as JSON. The second tag is a script containing the configuration, also passed as JSON. reactR::createReactShinyInput( inputId = &quot;plop&quot;, class = &quot;myinput&quot;, dependencies = htmltools::findDependencies(icon(&quot;bicycle&quot;)), default = 0, configuration = list(a = 1, b = &quot;test&quot;), container = div ) The configuration and values are processed in the initialize method, which is a great place since it is called before the input is bound: $(el).data(&#39;value&#39;, JSON.parse($(el).next().text())); $(el).data(&#39;configuration&#39;, JSON.parse($(el).next().next().text())); They are stored in the corresponding data attributes. The most important part is the render method that creates the React element , based upon its configuration, value and renders it in the DOM: render(el) { const element = React.createElement(component, { configuration: this.getInputConfiguration(el), value: this.getValue(el), setValue: this.setValue.bind(this, el), el: el }); ReactDOM.render(element, el); } The render method is called once inside subscribe and also each time the element is updated with receiveMessage. Interestingly, setValue is made available to the React component. For the action button case, it is called each time the onClick event is triggered, that is each time the user clicks on the button. This is the only way to update its value since it is not accessible to the user through update_argon_action_button. Other inputs like textInput have the onChange event, triggered each time the text field is updated. The value may also be updated by the user with updateTextInput. Consequently, there is no general rule and the situation may vary from an input to another! For now, let’s just erase the {creatR} boilerplate (argon_action_button.jsx) with the above code an recompile with yarn run webpack. We also have to tell Shiny we want to use Bootstrap 4 instead of Bootstrap 3, through the bslib::bs_theme function: devtools::document() devtools::load_all() library(shiny) library(mypkg) ui &lt;- fluidPage( theme = bslib::bs_theme(version = &quot;4&quot;), argon_action_button(&quot;plop&quot;) ) server &lt;- function(input, output, session) { } shinyApp(ui, server) The button is looking good but not really like in the Argon design system. Indeed, we forgot to import the argon CSS assets. Add this code to the argon_action_button.jsx: import &quot;argon-design-system-react/src/assets/css/argon-design-system-react.min.css&quot;; We have to tell webpack how to load the CSS by adding a missing rule to the provided webpack.config.js: rules: [ { test: /\\.jsx?$/, loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;] } }, // For CSS so that import &quot;path/style.css&quot;; works { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] } ] It is possible that you don’t have the corresponding node modules. In that case, you can install them with: npm install style-loader css-loader --save-dev which will also update the package.json file. Once updated, we recompile the code. The next part of this tutorial consists in making the button interactive. We edit the argon_action_button.jsx code to add three input parameters in the ArgonButton component: value is the button count. The initial value is provided by the default slot on the R side (see below). configuration contains various user provided properties like the color status, outline style, … setValue is a way to increment the button value. Letting setValue(value + 1), ensures to increment the button value by 1 unit each click. import { reactShinyInput } from &#39;reactR&#39;; // reactstrap components import { Button } from &quot;reactstrap&quot;; // Import argon CSS import &quot;argon-design-system-react/src/assets/css/argon-design-system-react.min.css&quot;; function ArgonButton({configuration, value, setValue}) { return ( &lt;Button color={configuration.status} type=&quot;button&quot; onClick={() =&gt; setValue(value + 1)}&gt; {configuration.label} &lt;/Button&gt; ); } reactShinyInput(&#39;.argon_action_button&#39;, &#39;mypkg.argon_action_button&#39;, ArgonButton); On the R side, we remove the default parameter from the external API but keep it internally to set the initial value to 0, like for shiny::actionButton. Status and label are stored in the configuration named list. Be careful! Names matter since they are recovered on the JS side with configuration.prop_name: argon_action_button &lt;- function(inputId, label, status = &quot;primary&quot;) { reactR::createReactShinyInput( inputId, &quot;argon_action_button&quot;, htmltools::htmlDependency( name = &quot;argon_action_button-input&quot;, version = &quot;1.0.0&quot;, src = &quot;www/mypkg/argon_action_button&quot;, package = &quot;mypkg&quot;, script = &quot;argon_action_button.js&quot; ), default = 0, configuration = list( label = label, status = status ), htmltools::tags$div ) } Once everything is up to date, we rebuild the JS, reload/document the package and run the app demo: ui &lt;- fluidPage( theme = bslib::bs_theme(version = &quot;4&quot;), argon_action_button(&quot;plop&quot;, &quot;Click me!&quot;) ) server &lt;- function(input, output, session) { observe(print(input$plop)) } shinyApp(ui, server) We may also modify the update input boilerplate since we don’t change the button value: update_argon_action_button &lt;- function(session, inputId, configuration = NULL) { message &lt;- list() if (!is.null(configuration)) message$configuration &lt;- configuration session$sendInputMessage(inputId, message); } devtools::document() devtools::load_all() ui &lt;- fluidPage( theme = bslib::bs_theme(version = &quot;4&quot;), fluidRow( argon_action_button(&quot;plop&quot;, &quot;Click me!&quot;), argon_action_button(&quot;update&quot;, &quot;Update button 1&quot;) ) ) server &lt;- function(input, output, session) { observe(print(input$plop)) observeEvent(input$update, { update_argon_action_button( session, &quot;plop&quot;, configuration = list( label = &quot;New text&quot;, status = &quot;success&quot; ) ) }, ignoreInit = TRUE) } shinyApp(ui, server) 28.2.1.3 Exercise Add a size, outline and icon (from fontawesome) parameters to the ArgonButton component in the corresponding R script. Hint: the icon parameter is the trickiest one. You might find helpful to capture its HTML dependency with htmltools::htmlDependencies(iconTag) so as to properly render it. In HTML icon(\"bicycle\") produces &lt;i class=\"fa fa-bicycle\" role=\"presentation\" aria-label=\"bicycle icon\"&gt;&lt;/i&gt;. However, in React we want &lt;i className=\"fa fa-bicycle /&gt;. Therefore, you will have to extract the icon class and send it to JS in the configuration list. Implement the logic on the JS side. Hint: you may use the below code: import { reactShinyInput } from &#39;reactR&#39;; // reactstrap components import { Button } from &quot;reactstrap&quot;; // import argon CSS import &quot;argon-design-system-react/src/assets/css/argon-design-system-react.min.css&quot;; function ArgonButton({configuration, value, setValue}) { let iconTag, btnCl, innerTag; if (...) { btnCl = &quot;btn-icon&quot;; innerTag = &lt;&gt; &lt;span className=&quot;btn-inner--icon&quot;&gt; &lt;i className=... /&gt; &lt;/span&gt; &lt;span className=&quot;btn-inner--text&quot;&gt;...&lt;/span&gt; &lt;/&gt;; } else { innerTag = configuration.label; } let outlined; if (...) { outlined = true; } return ( &lt;Button color={configuration.status} type=&quot;button&quot; className=... outline=... size=... onClick={() =&gt; setValue(value + 1)}&gt; {innerTag} &lt;/Button&gt; ); } reactShinyInput(&#39;.argon_action_button&#39;, &#39;mypkg.argon_action_button&#39;, ArgonButton); Try your code with: library(shiny) library(mypkg) ui &lt;- fluidPage( theme = bslib::bs_theme(version = &quot;4&quot;), fluidRow( argon_action_button(&quot;plop&quot;, &quot;Click me!&quot;, size = &quot;lg&quot;, outline = TRUE), argon_action_button(&quot;update&quot;, &quot;Update button 1&quot;, icon = icon(&quot;bicycle&quot;)) ) ) server &lt;- function(input, output, session) { observe(print(input$plop)) observeEvent(input$update, { update_argon_action_button( session, &quot;plop&quot;, configuration = list( label = &quot;New text&quot;, status = &quot;success&quot; ) ) }, ignoreInit = TRUE) } shinyApp(ui, server) You should get the result shown Figure 28.4. FIGURE 28.4: Argon Action button with React 28.2.1.4 Example 2: a slider input Below we propose a preliminary implementation of the Argon slider input. The documentation provides a JSX skeleton: {/* Simple slider */} &lt;div className=&quot;input-slider-container&quot;&gt; &lt;div className=&quot;slider&quot; ref=&quot;slider1&quot; /&gt; &lt;Row className=&quot;mt-3 d-none&quot;&gt; &lt;Col xs=&quot;6&quot;&gt; &lt;span className=&quot;range-slider-value&quot;&gt; {this.state.simpleValue} &lt;/span&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; The slider JS API is actually taken from the well known noUiSlider library and is already available in the package node modules. Still in the same package as the action button input, we can call: reactR::scaffoldReactShinyInput(&quot;argon_slider&quot;, edit = FALSE) It creates a new srcjs/argon_slider.jsx script. As Argon uses the pure JS API for noUIslider, this would be too much work for us mainly because the provided reactShinyInput JS helper does not have a proper initialization method to create the slider instance. We would have to change it as per below: initialize(el) { // Unchanged compared to reactR $(el).data(&#39;value&#39;, JSON.parse($(el).next().text())); $(el).data(&#39;configuration&#39;, JSON.parse($(el).next().next().text())); // Create the slider instance self = this; Slider.create($(el).attr(id), { start: self.getInputValue(el), connect: [true, false], step: self.getInputConfiguration(el).step, range: { min: self.getInputConfiguration(el).min, max: self.getInputConfiguration(el).max } }); } as well as updating methods like setInputValue, setInputConfiguration. Fortunately, there is already a nouislider-react API, which will makes our job much easier than shown above. To add the new dependency we run: yarn add nouislider-react and replace the import statement inside our JSX file to rely on nouislider-react. The Nouislider component markup is fairly intuitive. We set the min and max as well as the current value: import { reactShinyInput } from &#39;reactR&#39;; import Nouislider from &quot;nouislider-react&quot;; function ArgonSlider({configuration, value, setValue}) { const rangeOpts = { min: configuration.min, max: configuration.max }; return( &lt;Nouislider range={rangeOpts} start={value} connect={[true, false]} /&gt; ); } reactShinyInput(&#39;.argon_slider&#39;, &#39;mypkg.argon_slider&#39;, ArgonSlider); The connect property makes the slider bar background filled with the theme color. Figure 28.5 shows what happens when this parameter is disabled. At that stage, we modified the webpack.config.js file so that there are multiple entry points (to compile the action button and the slider) and combined the output in a more generic name: entry: [ path.join(__dirname, &#39;srcjs&#39;, &#39;argon_action_button.jsx&#39;), path.join(__dirname, &#39;srcjs&#39;, &#39;argon_slider.jsx&#39;) ], output: { path: path.join(__dirname, &#39;inst/www/mypkg/argon&#39;), filename: &#39;argon.js&#39; } This means we have to update the HTML dependency on the R side, for instance for the argon_slider_input.R: argon_slider_input &lt;- function(inputId, value, default = value, min, max) { reactR::createReactShinyInput( inputId, &quot;argon_slider&quot;, htmltools::htmlDependency( name = &quot;argon&quot;, version = &quot;1.0.0&quot;, src = &quot;www/mypkg/argon&quot;, package = &quot;mypkg&quot;, script = &quot;argon.js&quot; ), default, list( min = min, max = max ), htmltools::tags$div ) } We can run the app below: ui &lt;- fluidPage( theme = bslib::bs_theme(version = &quot;4&quot;), argon_slider_input(&quot;plop&quot;, 10, min = 0, max = 100) ) server &lt;- function(input, output, session) { observe(print(input$plop)) } shinyApp(ui, server) As shown on Figure 28.5, the slider is properly displayed and the value is recovered from the server. However, nothing happens when the range is dragged. The reason is quite simple: we did not set the setValue inside our JSX code yet. FIGURE 28.5: Slider input with Argon React The slider API provides many events but not all are suitable for us. Ideally, we would like an update: Each time the range is released after dragging. Each time the range is moved by arrow key (keyboard). This seems like a perfect shot for the onChange prop. Let’s add it to the ArgonSlider component: function ArgonSlider({configuration, value, setValue, el}) { const rangeOpts = { min: configuration.min, max: configuration.max }; return( &lt;Nouislider range={rangeOpts} start={[value]} connect={[true, false]} onChange={() =&gt; setValue()} /&gt; ); } What value should we pass to setValue? This is quite easy to recover the slider value directly within the React component. We pass a parameter to the function, which will recover the latest value: value =&gt; setValue(parseFloat(value)) The trick is to convert the value to a number since we recover a string by default. You may use parseInt or parseFloat, depending whether you want a integer or the exact value. Right now, the slider cannot be moved with the keyboard. Adding the keyboardSupport prop make it possible. This may correspond to a parameter provided in the argon_slider_input configuration. The tooltips parameter enhances the user experience by showing the current value, on top of the slider, while pips add a simple grid. Not mentioned in the documentation, we add some CSS properties (top and bottom margins) to improve the display. Importantly, as the update slider function passes a named list to JS, any missing property is dropped, which can lead to undefined values on the JS side and unexpected behavior. Therefore, it is good to put default values whenever necessary to avoid this kind of issue. For instance, assume you passed orientation = \"horizontal\" upon slider creation and forgot to put that parameter in the update list, you can do the following in the JSX code: if (configuration.orientation === undefined) { configuration.orientation = &quot;horizontal&quot;; } The whole component code may be found below: function ArgonSlider({configuration, value, setValue, el}) { const rangeOpts = { min: configuration.min, max: configuration.max }; // Better margins const sliderStyle = {marginTop: &quot;50px&quot;, marginBottom: &quot;50px&quot;}; // Grid const pipOpts = { mode: &#39;range&#39;, density: 3 }; return( &lt;Nouislider style={sliderStyle} range={rangeOpts} start={[value]} connect={[true, false]} onChange={value =&gt; setValue(parseFloat(value))} keyboardSupport={configuration.keyboard} tooltips={configuration.tooltips} pips={pipOpts} /&gt; ); } The argon_slider_input is given by: argon_slider_input &lt;- function(inputId, value, default = value, min, max, keyboard = TRUE, tooltips = TRUE) { reactR::createReactShinyInput( inputId, &quot;argon_slider&quot;, htmltools::htmlDependency( name = &quot;argon&quot;, version = &quot;1.0.0&quot;, src = &quot;www/mypkg/argon&quot;, package = &quot;mypkg&quot;, script = &quot;argon.js&quot; ), default, list( min = min, max = max, keyboardSupport = keyboard, tooltips = tooltips ), htmltools::tags$div ) } There are many more parameters that can be added to the following API. We leave it as an exercise for the reader. Finally, let’s see how update_argon_slider_input works: ui &lt;- fluidPage( theme = bslib::bs_theme(version = &quot;4&quot;), argon_slider_input(&quot;plop&quot;, 10, min = 0, max = 100), br(), argon_action_button(&quot;update&quot;, &quot;Update button 1&quot;) ) server &lt;- function(input, output, session) { observe(print(input$plop)) observeEvent(input$update, { update_argon_slider_input( session, &quot;plop&quot;, value = 100, configuration = list( min = 0, max = 200, tooltips = FALSE, keyboardSupport = FALSE ) ) }, ignoreInit = TRUE) } shinyApp(ui, server) The keyboardSupport option does not seem changed, neither is the tooltips option. Actually, only that list may be modified. Let’s address this below. The nouiSlider React API provides internal access to the slider instance from within the component. To make it work, we have to leverage the React Hook feature: Create a Hook hosting the component reference and a method to update it with React.useState. Update the instance option each time the component is re-rendered by Shiny. const [ref, setRef] = React.useState(null); const setConfiguration = () =&gt; { if (ref &amp;&amp; ref.noUiSlider) { ref.noUiSlider.updateOptions(configuration); } }; setConfiguration(); We must specify the instanceRef property which will capture the slider reference when available and update the local ref: &lt;Nouislider style={sliderStyle} keyboardSupport={configuration.keyboard} connect={[true, false]} range={rangeOpts} start={[value]} onChange={value =&gt; setValue(parseFloat(value))} tooltips={configuration.tooltips} pips={pipOpts} instanceRef={ instance =&gt; { if (instance &amp;&amp; !ref) { setRef(instance); } } } /&gt; We recompile the code and run the previous example. While the tooltip is gone, the keyboard interaction is still there. This is not surprising as updateOptions does not handle all settings. The final result is displayed Figure 28.6. FIGURE 28.6: Slider input with Argon React with more options 28.2.1.5 Exercise 2: a range slider Based on the above example, improve the previous slider widget to handle the range slider case, that is enable the user to pass a vector of initial values. 28.2.2 Toward custom components Creating custom components in Shiny is not that easy. If we assume we want to create a custom text container which color, size and many CSS properties can change dynamically. This is a bit different from the approach shown in Chapter 8 since the {bslib} gives access to Bootstrap variables but not basic CSS properties like the color of a span element. "],["references.html", "References", " References "]]
