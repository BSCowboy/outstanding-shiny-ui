[
["custom-templates-skeleton.html", "Chapter 10 Template skeleton 10.1 Identify template elements 10.2 Design the page layout", " Chapter 10 Template skeleton The list of all available layouts is quite impressive (horizontal, vertical, compressed, right to left, dark, …). In the next steps, we will focus on the dark-compressed template. We leave the reader to try other templates as an exercise. 10.1 Identify template elements We are quite lucky since there is nothing fancy about the tabler layout. As usual, let’s inspect the layout-condensed-dark.html (in the tabler /demo folder) in Figure 10.1 Figure 10.1: Tabler condensed layout There are 2 main components: - the header containing the brand logo, the navigation and dropdown - the content containing the dashboard body as well as the footer Something important: the dashboard body does not mean &lt;body&gt; tag! This is all! 10.2 Design the page layout 10.2.1 The page wrapper Do you remember the structure of a basic html page seen in Chapter 2? Well, if not, here is a reminder. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; We actually don’t need to take care of the &lt;html&gt; tag. Below we construct a list of tags with tagList, including the head and the body. In the head we have meta tag that briefly describe the encoding, how to display the app on different devices (For instance apple-mobile-web-app-status-bar-style is for mobile support), set the favicon (website icon, the icon you see on the right side of the searchbar. Try twitter for instance). The page title may change, so is the favicon, so we include them as parameters of the function. If you remember, there also should be CSS in the head but nothing here! Actually, the insertion of dependencies will be achieved by our addDeps function defined in Chapter 9. This is what we do to the &lt;body&gt; tag that is wrapped by this function. Let’s talk about the dark parameter. In short, the only difference between the dark and the light theme is the class applied to the &lt;body&gt; tag (respectively “antialiased theme-dark” and “antialiased”). The … parameter contain other template elements like the header and the dashboard body, that remain to be created. tabler_page &lt;- function(..., dark = TRUE, title = NULL, favicon = NULL){ tagList( # Head tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot; width=device-width, initial-scale=1, viewport-fit=cover&quot; ), tags$meta(`http-equiv` = &quot;X-UA-Compatible&quot;, content = &quot;ie=edge&quot;), tags$title(title), tags$link( rel = &quot;preconnect&quot;, href = &quot;https://fonts.gstatic.com/&quot;, crossorigin = NA ), tags$meta(name = &quot;msapplication-TileColor&quot;, content = &quot;#206bc4&quot;), tags$meta(name = &quot;theme-color&quot;, content = &quot;#206bc4&quot;), tags$meta(name = &quot;apple-mobile-web-app-status-bar-style&quot;, content = &quot;black-translucent&quot;), tags$meta(name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot;), tags$meta(name = &quot;mobile-web-app-capable&quot;, content = &quot;yes&quot;), tags$meta(name = &quot;HandheldFriendly&quot;, content = &quot;True&quot;), tags$meta(name = &quot;MobileOptimized&quot;, content = &quot;320&quot;), tags$meta(name = &quot;robots&quot;, content = &quot;noindex,nofollow,noarchive&quot;), tags$link(rel = &quot;icon&quot;, href = favicon, type = &quot;image/x-icon&quot;), tags$link(rel = &quot;shortcut icon&quot;, href = favicon, type=&quot;image/x-icon&quot;) ), # Body addDeps( tags$body( tags$div( class = paste0(&quot;antialiased &quot;, if(dark) &quot;theme-dark&quot;), style = &quot;display: block;&quot;, tags$div(class = &quot;page&quot;, ...) ) ) ) ) } Below we quickly test if a tabler element renders well to see whether our dependency system is adequately setup. To that end, we include a random tabler element taken from the demo html page and include it as raw html, using HTML. We also ensure that basic Shiny input/output system works as expected with a sliderInput linked to a plot output. ui &lt;- tabler_page( &quot;test&quot;, sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;), br(), HTML( &#39;&lt;div class=&quot;col-sm-6 col-lg-3&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;d-flex align-items-center&quot;&gt; &lt;div class=&quot;subheader&quot;&gt;Sales&lt;/div&gt; &lt;div class=&quot;ml-auto lh-1&quot;&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;a class=&quot;dropdown-toggle text-muted&quot; href=&quot;#&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Last 7 days &lt;/a&gt; &lt;div class=&quot;dropdown-menu dropdown-menu-right&quot;&gt; &lt;a class=&quot;dropdown-item active&quot; href=&quot;#&quot;&gt;Last 7 days&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Last 30 days&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Last 3 months&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;h1 mb-3&quot;&gt;75%&lt;/div&gt; &lt;div class=&quot;d-flex mb-2&quot;&gt; &lt;div&gt;Conversion rate&lt;/div&gt; &lt;div class=&quot;ml-auto&quot;&gt; &lt;span class=&quot;text-green d-inline-flex align-items-center lh-1&quot;&gt; 7% &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;icon ml-1&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; stroke-width=&quot;2&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;&gt; &lt;path stroke=&quot;none&quot; d=&quot;M0 0h24v24H0z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;3 17 9 11 13 15 21 7&quot;&gt;&lt;/polyline&gt; &lt;polyline points=&quot;14 7 21 7 21 14&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;progress progress-sm&quot;&gt; &lt;div class=&quot;progress-bar bg-blue&quot; style=&quot;width: 75%&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;75&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;75% Complete&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#39; ), title = &quot;Tabler test&quot; ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Ok… The layout is ugly, margins are not correct, the plot background does not match with the overall theme, … but our info card and the shiny element work like a charm, which is a good start. 10.2.2 The body content In this part, we translate the dashboard body HTML code to R. We create a function called tabler_body. The … parameter holds all the dashboard body elements and the footer is dedicated for the future tabler_footer function. tabler_body &lt;- function(..., footer = NULL) { div( class = &quot;content&quot;, div(class = &quot;container-xl&quot;, ...), tags$footer(class = &quot;footer footer-transparent&quot;, footer) ) } Let’s test it with the previous example. ui &lt;- tabler_page(tabler_body(p(&quot;Hello World&quot;))) server &lt;- function(input, output, session) {} shinyApp(ui, server) Way better! 10.2.3 The footer The footer is composed of a left and right containers. We decide to create parameters left and right in which the user will be able to pass any elements. tabler_footer &lt;- function(left = NULL, right = NULL) { div( class = &quot;container&quot;, div( class = &quot;row text-center align-items-center flex-row-reverse&quot;, div(class = &quot;col-lg-auto ml-lg-auto&quot;, right), div(class = &quot;col-12 col-lg-auto mt-3 mt-lg-0&quot;, left) ) ) } As above, let’s check our brand new element. ui &lt;- tabler_page( tabler_body( p(&quot;Hello World&quot;), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 10.2.4 The navbar (or header) This function is called tabler_header. In the tabler template, the header has the classes “navbar navbar-expand-md navbar-light”. We don’t need the navbar-light classe since we are interested in the dark theme. As shown in Figure 10.2, the navbar is composed of 4 elements: the navbar toggler is only visible when we reduce the screen width (like on mobile devices) the brand image the navigation the dropdown menu (this is not mandatory) You may have a look at the Bootstrap 4 documentation for the navbar configuration and layout. Each of these element will be considered as an input parameter to the tabler_navbar function, except the first element which is a default element and should not be removed. Morever, we will only show the brand element when it is provided. The … parameter is a slot for extra elements (between the menu and dropdowns). Figure 10.2: Tabler header structure tabler_navbar &lt;- function(..., brand_url = NULL, brand_image = NULL, nav_menu, nav_right = NULL) { navbar_cl &lt;- &quot;navbar navbar-expand-md&quot; tags$header( class = navbar_cl, tags$div( class = &quot;container-xl&quot;, # toggler for small devices (must not be removed) tags$button( class = &quot;navbar-toggler&quot;, type = &quot;button&quot;, `data-toggle` = &quot;collapse&quot;, `data-target` = &quot;#navbar-menu&quot;, span(class = &quot;navbar-toggler-icon&quot;) ), # brand stuff if (!is.null(brand_url) || !is.null(brand_image)) { a( href = if (!is.null(brand_url)) { brand_url } else { &quot;#&quot; }, class = &quot;navbar-brand navbar-brand-autodark d-none-navbar-horizontal pr-0 pr-md-3&quot;, if(!is.null(brand_image)) { img( src = brand_image, alt = &quot;brand Image&quot;, class = &quot;navbar-brand-image&quot; ) } ) }, # slot for dropdown element if (!is.null(nav_right)) { div(class = &quot;navbar-nav flex-row order-md-last&quot;, nav_right) }, # div( class = &quot;collapse navbar-collapse&quot;, id = &quot;navbar-menu&quot;, div( class = &quot;d-flex flex-column flex-md-row flex-fill align-items-stretch align-items-md-center&quot;, nav_menu ), if (length(list(...)) &gt; 0) { div( class = &quot;ml-md-auto pl-md-4 py-2 py-md-0 mr-md-4 order-first order-md-last flex-grow-1 flex-md-grow-0&quot;, ... ) } ) ) ) } Let’s create the navbar menu. The … parameter is a slot for the menu items. Compared to the original tabler dashboard template where there is only the class navbar-nav, we have to add, at least, the nav class to make sure items are correctly activated/inactivated. The nav-pills class is to select pills instead of basic tabs (see here). tabler_navbar_menu &lt;- function(...) { tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } Each navbar menu item could be either a simple button or contain multiple menu sub-items. For now, we only focus on simple items. 10.2.4.1 Navbar navigation This part is extremely important since it will drives the navigation of the template. What do we want? We would like to associate each item to a separate page in the body content, so that each time we change item, we go on another page. In brief, it is very similar to the Shiny tabsetPanel function. In HTML, menu items are &lt;a&gt; tags (links) with a given href attribute pointing to a specific page located in the server files. The point with a Shiny app is that we can’t decide how to split our content into several pages. We only have app.R generating a simple HTML page. The strategy here is to create a tabbed navigation, to mimic multiple pages. Let’s see how tabset navigation works. In the menu list, all items must have a data-toggle attribute set to tab, an href attribute holding a unique id. This unique id is mandatory since it will point the menu item to the corresponding body content. On the body side, tab panels are contained in a tabset panel (simple div container), have a role attribute set to tabpanel and an id corresponding the tabName passed in the menu item. Below, we propose a possible implementation of a menu item, as well as the corresponding body tab panel. tabler_navbar_menu_item &lt;- function(text, tabName, icon = NULL, selected = FALSE) { item_cl &lt;- paste0(&quot;nav-link&quot;, if(selected) &quot; active&quot;) tags$li( class = &quot;nav-item&quot;, a( class = item_cl, href = paste0(&quot;#&quot;, tabName), `data-toggle` = &quot;pill&quot;, # see https://getbootstrap.com/docs/4.0/components/navs/ `data-value` = tabName, role = &quot;tab&quot;, span(class = &quot;nav-link-icon d-md-none d-lg-inline-block&quot;, icon), span(class = &quot;nav-link-title&quot;, text) ) ) } tabler_tab_items &lt;- function(...) { div(class = &quot;tab-content&quot;, ...) } tabler_tab_item &lt;- function(tabName = NULL, ...) { div( role = &quot;tabpanel&quot;, class = &quot;tab-pane fade container-fluid&quot;, id = tabName, ... ) } What about testing this in a shiny app? ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot; ) ) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, p(&quot;Hello World&quot;) ), tabler_tab_item( tabName = &quot;tab2&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 10.2.4.2 Fine tune tabs behavior Quite good isn’t it? However, you will notice that pills are colored in blue, it would be better to respect the shades of grey. Moreover, even if the first tab was selected by default, it’s content is not shown! To fix this, we will apply our jQuery skills. According to the Bootstrap documentation, we must trigger the show event of the active tab at start. We therefore target the nav item that has the active class and if no item is found, we select the first item by default and activate its tab. $(function() { // this makes sure to trigger the show event on the active tab at start const activeTab = $(&#39;#navbar-menu .nav-link.active&#39;); // if multiple items are found if (activeTab.length &gt; 0) { $(activeTab).tab(&#39;show&#39;); } else { $(&#39;#navbar-menu .nav-link&#39;) .first() .tab(&#39;show&#39;); } }); The script is included in a tag but best practice it to put it in a separate js file (I do it this way because it is more convenient for the demonstration). ui &lt;- tabler_page( tags$head( tags$style( &quot;.nav-pills .nav-link.active, .nav-pills .show&gt;.nav-link { background-color: #a8aeb7; } &quot; ), tags$script( HTML( &quot;$(function() { // this makes sure to trigger the show event on the active tab at start const activeTab = $(&#39;#navbar-menu .nav-link.active&#39;); if (activeTab.length &gt; 0) { $(activeTab).tab(&#39;show&#39;); } else { $(&#39;#navbar-menu .nav-link&#39;) .first() .tab(&#39;show&#39;); } }); &quot; ) ) ), tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot; ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot; ) ) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, p(&quot;Hello World&quot;) ), tabler_tab_item( tabName = &quot;tab2&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) The result is shown in Figure 10.3. I’d also suggest to include at least 1 input/output per tab, to test whether everything works properly. Figure 10.3: Tabler template with navbar Looks like we are done for the main template elements. Actually, wouldn’t it be better to include, at least, card containers? 10.2.5 Card containers Card are a central piece of template as they may contain visualizations, metrics and much more. Tabler has a large range of card containers. 10.2.5.1 Classic card What I call a classic card is like the box container of shinydashboard. The card structure has key elements: a width to control the space taken by the card in the Bootstrap grid a title, in general in the header (tabler does always not follow this rule and header is optional) a body where is the main content style elements like color statuses a footer (optional, tabler does not include this) A comprehensive list of all tabler card features may be found here. To be faster, I will copy the following HTML code in the html2R shiny app to convert it to Shiny tags &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-status-top bg-danger&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h3 class=&quot;card-title&quot;&gt;Card with top status&lt;/h3&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aperiam deleniti fugit incidunt, iste, itaque minima neque pariatur perferendis sed suscipit velit vitae voluptatem.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Below is the result. The next step consist in replacing all content by parameters to the tabler_card function, whenever necessary. For instance, the first &lt;div&gt; sets the width of the card. The Bootstrap grid ranges from 0 to 12, so why not creating a width parameter to control the card size. We proceed similarly for the title, status, body content. A last comment on parameters default values. It seems reasonable to allow title to be NULL (if so, the title won’t be shown), same thing for the status. Regarding the card default width, 6 also makes sense. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } # test the card my_card &lt;- tabler_card( p(&quot;Hello&quot;), title = &quot;My card&quot;, status = &quot;danger&quot; ) In the meantime, I’d be also nice to be able to display cards in the same row. Let’s create the tabler_row: tabler_row &lt;- function(...) { div(class = &quot;row row-deck&quot;, ...) } ui &lt;- tabler_page( tabler_body( tabler_row( my_card, tabler_card( p(&quot;Hello&quot;), title = &quot;My card&quot;, status = &quot;success&quot; ) ) ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 10.2.5.2 Ribbons: card components Let’s finish this part by including a card component, namely the ribbon. tabler_ribbon &lt;- function(..., position = NULL, color = NULL, bookmark = FALSE) { ribbon_cl &lt;- paste0( &quot;ribbon&quot;, if (!is.null(position)) sprintf(&quot; bg-%s&quot;, position), if (!is.null(color)) sprintf(&quot; bg-%s&quot;, color), if (bookmark) &quot; ribbon-bookmark&quot; ) div(class = ribbon_cl, ...) } Integrating the freshly created ribbon component requires to modify the card structure since the ribbon is added after the body tag, and not parameter is associated with this slot. We could also modify the tabler_card function but htmltools contains tools to help us. Since the ribbon should be put after the card body (but in the card container), we may think about the tagAppendChild function, introduced in Chapter 5: # add the ribbon to a card my_card &lt;- tabler_card(title = &quot;Ribbon&quot;) my_card$children[[1]] &lt;- my_card$children[[1]] %&gt;% tagAppendChild(tabler_ribbon(1, bookmark = TRUE)) As shown above, the ribbon has been successfuly included in the card tag. Now, we check how it looks in a shiny app. ui &lt;- tabler_page( tabler_body( my_card ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) "]
]
