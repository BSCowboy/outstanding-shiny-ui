# R + Shiny + React: welcome `{reactR}` {#going-further-reactR}
[React](https://reactjs.org/) is an open source library designed to quickly develop user interfaces or UI components, on the front end. 
It has been developed by [Facebook](https://github.com/facebook/react) and the community (more than 1500 contributors) 
and made public in May 29 2013. It is currently used worldwide and has around 163k stars on the
Github ranking and widely impacts the mobile market, through the [React Native](https://reactnative.dev/) library.  
React is also really convenient to develop attractive documentations with [docusaurus](https://v2.docusaurus.io/).
If you ever have built user interfaces with pure JS, you might like React! 

Below, we give a short introduction to the React ecosystem and see how we can benefit from it from the
R Shiny side. 

## Quick introduction to React
To understand React there are few prerequisites notably basic HTML/CSS/JS knowledge, especially JS modules (see 
section \@ref(about-js-modules)). However, if you managed to reach this chapter, you should not worry too much. 

### Setup
`Node` and `npm` are required. If you are not sure, run:

```shell
node -v
npm -v
```

At that stage it is also good to have [`yarn`](https://classic.yarnpkg.com/en/docs/install#mac-stable) as we'll need it for `{reactR}`.

If nothing is returned, please refer to section \@ref(install-node). To initiate a React [project](https://create-react-app.dev/),
we leverage the `npx` command:

```
npx create-react-app <PROJECT_NAME>
```

Replace `<PROJECT_NAME>` by the real name of your project. If this seems intimidating, 
keep in mind this is the same concept has using the `{golem}` [package](https://github.com/ThinkR-open/golem) 
to initiate the creation of robust shiny projects, except that we work from the terminal.

Once done (the package initialization takes some time), 
move to the project folder and launch the demo app:

```
cd <PROJECT_NAME> && npm start
```

If you have yarn, `yarn start` also works.

You should see something similar to Figure \@ref(fig:basic-react-app).

```{r basic-react-app, echo=FALSE, fig.cap='npm start opens the react app', out.width='100%'}
knitr::include_graphics("images/going-further/basic-react-app.png")
```

### Basics
We are now all set up to start learning the basics of React. Among all created files,
notice the `/src/app.js` file. Inside the `App` function, we remove all the content inside
the `return` statement to put a simple `<h1>Hello, world!</h1>` HTML title. We also clean the imports
as we don't need any CSS and logo anymore. We obtain:

```jsx
function App() {
  return (
    <h1>Hello, world!</h1>
  );
}

export default App; // don't remove, this is needed by index.js
```

Once done, we run `npm build` (or `yarn build`), to rebuild the JS code and `npm start` to
restart the server and preview the app. In practice, once the server is launched, there is 
no need to restart it whenever the code is updated. A simple save will refresh the interface!

The code you see above is a React component. The definition is rather simple: it is a function that returns
a moreless complex piece of UI. How are components rendered by React?

So far, we didn't have a look at the `/src/index.js` script. Inside we find:

```jsx
ReactDOM.render(
  App,
  document.getElementById('root')
);
```

__Note__: recent version of `npx create-react-app` have `<React.StrictMode><App /></React.StrictMode>` instead
 of `App`, which does the same thing. You may also find `<App />`. In practice, we rarely modify this part.

In short, this inserts the `App` component inside the element having `root` as id in the main
HTML page. This HTML skeleton may be found in the `public/index.html` folder. You may guess that at the end
of the day, our app will be composed of multiple bricks and called `ReactDOM.render` on the top level component.

#### About JSX
We just wrote our first React component. Didn't you notice something weird in that code? 
JS and HTML are mixed, in what we called JSX, that is a syntax extension to JS. JSX makes the code
less verbose, for instance:

```js
React.createElement(
  'h1',
  'Hello, world!'
);
```

does exactly the same thing as above but when the code becomes more complex, it is nearly
impossible to read. 

Let's see how to pass variables into JSX. We want to show `Hello, <Your Name>`, we store
the name in a variable and modify the `app.js` code accordingly:

```jsx
function App() {
  const name = "David";
  return (
    <h1>Hello, {name}</h1>
  );
}
```

Expressions are passed within curly brackets `{expression}` and you may even call functions inside.

Tag attributes also require curly brackets. Let's modify the title tag to give it a color and 
a size.

```jsx
function App() {
  const name = "David";
  return (
    <h1 style={color: "red", fontSize: 40}>Hello, {name}</h1>
  );
}
```

Try to save. Why does this fail? We can't pass multiple object properties inside a single `{}`.
We need either double brackets like `{{object properties: values, ...}}` or to store the object in 
a variable before:

```jsx
function App() {
  const name = "David";
  return (
    <h1 style={{color: "red", fontSize: 40}}>Hello, {name}</h1>
  );
}

// OR

function App() {
  const name = "David";
  const myStyle = {
    color: "red", 
    fontSize: 40
  }
  return (
    <h1 style={myStyle}>Hello, {name}</h1>
  );
}
```

Notice that we write CSS properties following the camelCase syntax, `font-size` being equivalent to `fontSize`.

#### Combining components
The whole interest is to combine multiple components to create reusable pieces. We edit the above code 
to create a `SayHello` component. Notice the `props` parameter. It is a way to pass configuration from the 
parent component. In that case, we want to display the person name, that is `props.name`. In the meantime,
we edit the `App` parent component and call `SayHello` three times, passing a different name like `<SayHello name="David" />` (this is the reason why we recover `props.name` in the lower level component):

```jsx
function SayHello(props) {
  return (
    <h1>Hello, {props.name}</h1>
  );
}


function App() {
  return(
  <>
    <SayHello name="David" />
    <SayHello name="Lisa" />
    <SayHello name="Simon" />
  </>
  );
}
```

Notice the enclosing `<>...</>`. This is called a React fragment and useful if we don't want to
insert any extra `<div>` in the DOM. 

We could be even more efficient by leveraging the lists capabilities. We create an array
of names and apply the `map` method to return the corresponding `<SayHello />` sub-component:

```jsx
const names = ["David", "Lisa", "Simon"];
function App() {
  const sayHelloToAll = names.map((name) => <SayHello key={name} name={name} />); 
  return(sayHelloToAll);
}
```

By convention, all elements inside a `map` require keys. 

Props are __read-only__ and must not be modified withing their own component. 
How do we update components?

#### Component state
A component state is private and controlled by this same component. Since React 16.8 and the introduction of __hooks__, this is not necessary to convert the component function to a [class](https://reactjs.org/docs/components-and-props.html#function-and-class-components). 
The easiest example to illustrate hooks capabilities is the button. Each time, we click on a button,
we want to keep the current number of clicks in a state, like the `shiny::actionButton`. We start by
importing the `useState` function from `react` and create a new `ActionButton` component. 
Inside, we set the state with `useState` that create the state variable `count` as well as the function to
update it, namely `setCount`. This way to create 2 variables at once is called array destructuring. 
We set the initial number of counts to 0: 

```jsx
import {useState} from 'react';

function ActionButton() {
  const [count, setCount] = useState(0);
}
```

Next step is to create the button skeleton. We provide an `onClick` property that updates
the button state.Inside, we write an anonymous function which calls `setCount` and increment
the count value by 1. At this point, you may replace the `app.js` content by:

```jsx
import {useState} from 'react';

function ActionButton() {
  const [count, setCount] = useState(0);
  return(
    <button onClick={() => setCount(count + 1)}>
      Number of clicks: {count}
    </button >
  );
}

function App() {
  return (
    <ActionButton />
  );
}

export default App;
```

We may improve the previous app and add a reset button within the `ActionButton` component that
sets the count back to 0:

```jsx
function ActionButton() {
  const [count, setCount] = useState(0);
  return(
    <>
    <button onClick={() => setCount(count + 1)}>
      Number of clicks: {count}
    </button >
    <button onClick={() => setCount(0)}>
      Reset
    </button >
    </>
  );
}
```

It would make more sense to only show the reset button once the button has been clicked,
at least once. We define the `isResetVisible` variable which is `true` whenever the
count is higher than 0 and `false` if the count is 0. We store the reset button in a variable
and only return something if `isResetVisible` is `true`:

```jsx
function ActionButton() {
  const [count, setCount] = useState(0);
  const isResetVisible = count > 0 ? true : false;
  let resetButton;
  if (isResetVisible) {
    resetButton = <button onClick={() => setCount(0)}>
      Reset
    </button >
  }
  return (
    <>
      <button onClick={() => setCount(count + 1)}>
        Number of clicks: {count}
      </button >
      {resetButton}
    </>
  );
}
```

Now that you get a better understanding of how React works, let's see how to use it with
Shiny. 

## Introduction to `{reactR}`
The React ecosystem is rich and provides many plug and play boilerplate. For instance,
`{reactable}` is an HTML widget developed on top of the [`react-table`](https://github.com/tannerlinsley/react-table) library. What about the modern React Argon design [system](https://demos.creative-tim.com/argon-design-system-react/?_ga=2.179634850.760978196.1612189904-282783983.1612189904#/), shown Figure \@ref(fig:argon-design-react).

```{r argon-design-react, echo=FALSE, fig.cap='Argon design template with React', out.width='100%'}
knitr::include_graphics("images/going-further/argon-design-react.png")
```

In this part, we see how to leverage `{reactR}` to bring Argon design React to Shiny.

To install `{reactR}`:

```{r, eval=FALSE}
install.packages("reactR")
remotes::install_github("react-R/reactR")
```

### Scaffold inputs

#### Setup
`{reactR}` exposes the `scaffoldReactShinyInput` that creates the necessary pieces of code
to get started with the input development (see Figure \@ref(fig:reactR-init-input)):

  - An `<input_name>.R` file containing the input skeleton as well as its related update function.
  It also creates a custom HTML dependency pointing to the input JS logic.
  - A `jsx` file with a boilerplate to start developing the input JS logic.
  - A `package.json` file containing dependencies.

Besides, providing an optional dependency with a name and version taken from npm installs
all necessary dependencies in the `package.json` file. 
  
In our case, we want to build on top of Argon from [here](https://www.npmjs.com/package/argon-design-system-react):

```{r, eval=FALSE}
path <- file.path(tempdir(), "mypkg")
usethis::create_package(path, rstudio = TRUE)
reactR::scaffoldReactShinyInput("argon_action_button", list(name = "argon-design-system-react", version = "1.1.0"))
```

```{r reactR-init-input, echo=FALSE, fig.cap='Package initialization with {reactR}', out.width='100%'}
knitr::include_graphics("images/going-further/reactR-init-input.png")
```

Note that `{reactR}` provides `webpack` as JS manager. To build the JS code we go to the RStudio
terminal tab (or any terminal) and run at the package root:

```
yarn install
yarn run webpack
```

This installs all dependencies listed in the `package.json` file and create a `package-lock.json` file. If you ever used `{renv}`, this is very similar and guarantees isolation of your package. All dependencies are stored in the `node_modules` folder.

__Note__: I encountered few cases where the `yarn install` failed. In that case, you may 
try `npm i argon-design-system-react` and also check your VPN settings.

The `run webpack` command triggers compiles the JS in production ready code. Should you need to customize the build pipeline, the webpack configuration is located in `webpack.config.js`. On the R side, the generated JS file is referenced in an HTML dependencies, located in the `<input_name>.R` file. 


#### Implement the input JS logic
It's time to develop the logic. The Argon documentation provides a [boilerplate](https://demos.creative-tim.com/argon-design-system-react/?_ga=2.179634850.760978196.1612189904-282783983.1612189904#/documentation/buttons), which we slightly simplified, as show below:

```jsx
import { reactShinyInput } from 'reactR';
// reactstrap components
import { Button } from "reactstrap";

function ArgonButton() {
  return (
    <Button color="primary" type="button">
      Button
    </Button>
  );
}

reactShinyInput('.argon_action_button', 'mypkg.argon_action_button', ArgonButton);
```

Notice the first two lines where we import the `reactShinyInput` function from the `{reactR}` JS core and [`reactstrap`](https://reactstrap.github.io/), a React powered Bootstrap 4 library. `reactShinyInput` provides
a wrapper to automatically bind the input element. This is extremely convenient as it allows to solely focus on the component logic rather than binding it to the shiny system. It takes three parameters:

  - The element class which is obtained from the R side by `createReactShinyInput`.
  - The input binding name which is useful to store a reference in the `Shiny.InputBindings` registry.
  - The React component function. 
  - There is an optional fourth parameter allowing to pass custom options like
  rate [policies](https://github.com/react-R/reactR/blob/master/srcjs/input.js#L137). 
  
Overall, [`reactShinyInput`](https://github.com/react-R/reactR/blob/master/srcjs/input.js#L72) extends the `Shiny.InputBinding` class by providing extra methods like:
  
```js
getInputConfiguration(el) {
  return $(el).data('configuration');
}
setInputConfiguration(el, configuration) {
  $(el).data('configuration', configuration);
}
```

`getInputConfiguration` and `setInputConfiguration`, respectively get and set the user provided configuration,
passed in the `createReactShinyInput` R side function. Under the hood, in addition to ship the `{reactR}`, React, ReactTools HTML dependencies (and any user defined custom dependency), `createReactShinyInput` does generate
three tag elements:

  - The first tag is the element placeholder containing the unique id. React will insert 
  the component inside this target with `ReactDOM.render`. 
  - The second tag is a script containing the value passed as JSON. 
  - The second tag is a script containing the configuration, also passed as JSON.
  
```{r}
reactR::createReactShinyInput(
  inputId = "plop", 
  class = "myinput", 
  dependencies = htmltools::findDependencies(icon("bicycle")), 
  default = 0, 
  configuration = list(a = 1, b = "test"), 
  container = div
)
```
  
The configuration and values are processed in the `initialize` method, which is a great place since it is 
called before the input is bound:

```js
$(el).data('value', JSON.parse($(el).next().text()));
$(el).data('configuration', JSON.parse($(el).next().next().text()));
```

They are stored in the corresponding data attributes. The most important part is the `render` method that
creates the React element , based upon its configuration, value and renders it in the DOM:

```js
render(el) {
  const element = React.createElement(component, {
    configuration: this.getInputConfiguration(el),
    value: this.getValue(el),
    setValue: this.setValue.bind(this, el),
    el: el
  });
  ReactDOM.render(element, el);
}
```

The `render` method is called once inside `subscribe` and also each time the element is updated
with `receiveMessage`. 

Interestingly, `setValue` is made available to the React component. You'll see below, this is 
particularly handy to seamlessly update the input value directly inside the component. 

For now, let's just erase the `{creatR}` boilerplate (`argon_action_button.jsx`) with the above code an recompile with `yarn run webpack`.

which we converted to function instead of class. We also have to tell Shiny we want to
use Bootstrap 4 instead of Bootstrap 3, through the `bslib::bs_theme` function:

```{r, eval=FALSE}
devtools::document()
devtools::load_all()
library(shiny)
library(mypkg)

ui <- fluidPage(
  theme = bslib::bs_theme(version = "4"),
  argon_action_button("plop")
)

server <- function(input, output, session) {
  
}

shinyApp(ui, server)
```

The button is looking good, even though not doing anything special yet. The next part
consists in making it interactive. On the JS side, we edit the code to add three input parameters to the
ArgonButton component:

  - __value__ is the button count. The initial value is provided by the `default` slot on the R side (see below). 
  - __configuration__ contains various user provided properties like the color status, outline style, ...
  - __setValue__ is a way to increment the button value. Letting `setValue(value + 1)`,
  ensures to increment the button value by 1 unit each click. 

```jsx
import { reactShinyInput } from 'reactR';
// reactstrap components
import { Button } from "reactstrap";

function ArgonButton({configuration, value, setValue}) {
  return (
    <Button color={configuration.status} type="button" onClick={() => setValue(value + 1)}>
      {configuration.label}
    </Button>
  );
}

reactShinyInput('.argon_action_button', 'mypkg.argon_action_button', ArgonButton);
```


On the R side, we remove the `default` parameter from the external API but keep it to
set the initial value to 0, like for `shiny::actionButton`. Status and label are stored
in the configuration name list. Be careful! names matter since they are recovered on the JS side
with `configuration.prop_name`:

```{r, eval=FALSE}
argon_action_button <- function(inputId, label, status = "primary") {
  reactR::createReactShinyInput(
    inputId,
    "argon_action_button",
    htmltools::htmlDependency(
      name = "argon_action_button-input",
      version = "1.0.0",
      src = "www/mypkg/argon_action_button",
      package = "mypkg",
      script = "argon_action_button.js"
    ),
    default = 0,
    configuration = list(
      label = label,
      status = status
    ),
    htmltools::tags$div
  )
}
```

Once everything is up to date, we rebuild the JS, reload/document the package and run the app demo:

```{r, eval=FALSE}
ui <- fluidPage(
  theme = bslib::bs_theme(version = "4"),
  argon_action_button("plop", "Click me!")
)

server <- function(input, output, session) {
  observe(print(input$plop))
}

shinyApp(ui, server)
```

We may also modify the update input boilerplate since we don't change the button value:

```{r, eval=FALSE}
update_argon_action_button <- function(session, inputId, configuration = NULL) {
  message <- list()
  if (!is.null(configuration)) message$configuration <- configuration
  session$sendInputMessage(inputId, message);
}

devtools::document()
devtools::load_all()
ui <- fluidPage(
  theme = bslib::bs_theme(version = "4"),
  fluidRow(
    argon_action_button("plop", "Click me!"),
    argon_action_button("update", "Update button 1")
  )
)

server <- function(input, output, session) {
  observe(print(input$plop))
  observeEvent(input$update, {
    update_argon_action_button(
      session, "plop", 
      configuration = list(
        label = "New text", 
        status = "success"
      )
    )
  }, ignoreInit = TRUE)
}

shinyApp(ui, server)
```


#### Exercise
1. Add a `size`, `outline` and `icon` (from fontawesome) parameters to the `ArgonButton` component in the corresponding R script.
Hint: the `icon` parameter is the trickiest one. You might find helpful to capture its HTML dependency with `htmltools::htmlDependencies(iconTag)` so as to properly render it. In HTML `icon("bicycle")` produces `<i class="fa fa-bicycle" role="presentation" aria-label="bicycle icon"></i>`. However, in React we want `<i className="fa fa-bicycle />`. Therefore, you will have to extract the icon class and send it to JS in the configuration list.
2. Implement the logic on the JS side. Hint: you may use the below code:

```jsx
import { reactShinyInput } from 'reactR';
// reactstrap components
import { Button } from "reactstrap";

function ArgonButton({configuration, value, setValue}) {
  let iconTag, btnCl, innerTag;
  if (...) {
    btnCl = "btn-icon";
    innerTag = <>
      <span className="btn-inner--icon">
        <i className=... />
      </span>
      <span className="btn-inner--text">...</span>
    </>;
  } else {
    innerTag = configuration.label;
  }

  let outlined;
  if (...) {
    outlined = true;
  }

  return (
    <Button
      color={configuration.status}
      type="button"
      className=...
      outline=...
      size=...
      onClick={() => setValue(value + 1)}>
      {innerTag}
    </Button>
  );
}

reactShinyInput('.argon_action_button', 'mypkg.argon_action_button', ArgonButton);
```



### Toward custom components
Creating custom components in Shiny is not that easy. If we assume we want to create
a custom text container which color, size and many CSS properties can change dynamically. 
This is a bit different from the approach shown in Chapter \@ref(beautify-with-bootstraplib) since
the `{bslib}` gives access to Bootstrap [variables](https://rstudio.github.io/bslib/articles/bs4-variables.html) but not basic CSS properties like the color of a `span` element.