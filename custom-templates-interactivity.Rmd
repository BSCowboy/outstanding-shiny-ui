# Adding more interactivity {#custom-templates-interactivity}
In this part, we are going to add more life to the template element. We first see how
to enhance an existing static HTML component. Then we will explore complex feedback mechanisms to provide more interactivity to your app.

## Custom progress bars
Progress bars are a good way to display metric related to a progress, for instance tracking the number of remaining tasks for a project. In general, those 
elements are static HTML. Hence, it would be interesting to be able to update the current
value from the server side. Since it is not an proper input element, implementing an input binding is inapropriate and we decide to proceed with the `sendCustomMessage`/`addCustomMessageHandler` pair. We first create the `tabler_progress`
tag which is mainly composed of:

- `style` gives the current progress value. This is the main element
- `min` and `max` are bounds, in general between 0 and 100
- `id` ensures the progress bar uniqueness, thereby avoiding conflicts

```{r}
tabler_progress <- function(id = NULL, value) {
  div(
    class = "progress",
    div(
      id = id, 
      class = "progress-bar",
      style = paste0("width: ", value, "%"),
      role = "progressbar",
      `aria-valuenow` = as.character(value),
      `aria-valuemin` = "0",
      `aria-valuemax` = "100",
      span(class = "sr-only", "38% Complete")
    )
  )
}

update_tabler_progress <- function(id, value, session = shiny::getDefaultReactiveDomain()) {
  message <- list(id = session$ns(id), value = value)
  session$sendCustomMessage(type = "update-progress", message)
}
```

The next element is the `update_tabler_progress` function which send 2 elements from R to JS:

- The progress `id`
- The new value

On the JS side, we have a basic `addCustomMessageHandler`. As mentionned in Chapter \@ref(survival-kit-javascript), `sendCustomMessage` and `addCustomMessageHandler` are connected by the `type` parameter. This is crucial! Moreover, as the sent message is a R list, it becomes an JSON, meaning that elements must be accessed with a `.` in JS:

```javascript
$(function () {
  Shiny.addCustomMessageHandler('update-progress', function(message) {
    $('#' + message.id).css('width', message.value +'%');
  });
});
```

We finally test these components in a simple app:

```{r, eval=FALSE}
ui <- tabler_page(
  tags$head(
    tags$script(
      "$(function() {
        Shiny.addCustomMessageHandler('update-progress', function(message) {
          $('#' + message.id).css('width', message.value +'%');
        });
      });
      "
    )
  ),
  tabler_body(
    sliderInput(
      "progress_value", 
      "Progress value:",
      min = 0, 
      max = 100, 
      value = 50
    ),
    tabler_progress(id = "progress1", 12)
  )
)

server <- function(input, output, session) {
  observeEvent(input$progress_value, {
    update_tabler_progress(
      id = "progress1", 
      input$progress_value
    )
  })
}
shinyApp(ui, server)
```


<br>
<div class="callout callout-info">
NOTE: How to handle custom messages in shiny modules? Well, it is pretty straightforward: we wrap any id with the module namespace given by `session$ns()` before sending it to JS. You may even do it by default (without modules) like in the previous example since `session$ns()` will be `""`.
</div>
<br>


## User feedback: toasts
Toasts are components to send discrete user feedback, contrary to modals which open in the middle of the page. Toasts may open on all sides of the window and are similar to the Shiny notifications (see [here](https://shiny.rstudio.com/reference/shiny/0.14/showNotification.html)). The tabler toast component is built on top of [Bootstrap 4](https://getbootstrap.com/docs/4.3/components/toasts/). Therefore, we will rely on this documentation.

### Toast skeleton
The skeleton is the HTML structure of the toast:

```html
<div class="toast show" role="alert" aria-live="assertive" aria-atomic="true" data-autohide="false" data-toggle="toast">
  <div class="toast-header">
    <span class="avatar mr-2" style="background-image: url(...)"></span>
    <strong class="mr-auto">Mallory Hulme</strong>
    <small>11 mins ago</small>
    <button type="button" class="ml-2 close" data-dismiss="toast" aria-label="Close">
      <span aria-hidden="true">&times;</span>
    </button>
  </div>
  <div class="toast-body">
    Hello, world! This is a toast message.
  </div>
</div>
```

Toasts are mainly composed of a header and a body. There might be a close button in case the toast does not hide itself. If multiple toasts appear one after each others, they are stacked, the latest being at the bottom of the stack. The position is controled with the style attribute like `style="position: absolute; top: 0; right: 0;"` for a top-right placement. Accessibility parameters like `aria-live` are detailed [here](https://getbootstrap.com/docs/4.3/components/toasts/#accessibility).

### The toast API
Toasts have a JS API to control their behaviour, `$('<toast_selector>').toast(option)`, where option stend for:

- animation applies a CSS fade transition to the toast and is TRUE by default 
- autohide automatically hides the toast (TRUE by default)
- delay is the delay to hide the toast (500 ms)

There are 3 methods: hide, show and dispose (dispose ensures the toast does not appear anymore). Finally, we may fine tune the toast behavior with 4 events: show.bs.toast, shown.bs.toast, hide.bs.toast, hide.bs.toast, hidden.bs.toast (like for tabs).


### R implementation
We first create the toast skeleton. We assume our toast will hide automatically, so that we may remove the delete button as well as the `data-autohide="false` attribute. All parameters are optional except the toast id, which is required to toggle the toast:

```{r}
tabler_toast <- function(id, title = NULL, subtitle = NULL, ..., img = NULL) {
  div(
    id = id,
    class = "toast",
    role = "alert",
    style = "position: absolute; top: 0; right: 0;",
    `aria-live` = "assertive",
    `aria-atomic` = "true",
    `data-toggle` = "toast",
    div(
      class = "toast-header",
      if (!is.null(img)) {
        span(
          class = "avatar mr-2", 
          style = sprintf("background-image: url(%s)", img)
        )
      },
      if (!is.null(title)) strong(class = "mr-auto", title),
      if (!is.null(subtitle)) tags$small(subtitle)
    ),
    div(class = "toast-body", ...)
  )
}
```

We create the `show_tabler_toast` function. Since the toast automatically hides, it does not make sense to create the hide function, as well as the dispose.

```{r}
show_tabler_toast <- function(id, options = NULL, session = getDefaultReactiveDomain()) {
  message <- shiny:::dropNulls(
    list(
      id = id,
      options = options
    )
  )
  session$sendCustomMessage(type = "tabler-toast", message)
}
```

The corresponding JS handler is given by:

```javascript
$(function() {
  Shiny.addCustomMessageHandler('tabler-toast', function(message) {
    $(`#${message.id}`)
      .toast(message.options)
      .toast('show');

    // add custom Shiny input to listen to the toast state
    $(`#${message.id}`).on('hidden.bs.toast', function() {
      Shiny.setInputValue(message.id, true, {priority: 'event'});
    });
  });
});
```

We first configure the toast and ask him to show. Notice how we chained jQuery methods! We optionally add an event listener to capture the `hidden.bs.toast` event, so that we may trigger an action when the toast is closed. The `input$id` will be used for that purpose in combination with the `Shiny.setInputValue`. Notice the extra parameter `{priority: 'event'}`: basically, once the toast is closed, `input$id` will always be TRUE, thereby breaking the reactivity. Adding this extra parameter forces the evaluation of the input, although constant over time.


### Wrap up

```{r, eval=FALSE}
ui <- tabler_page(
  tags$head(
    tags$script(
      "$(function() {
        Shiny.addCustomMessageHandler('tabler-toast', function(message) {
          $(`#${message.id}`)
            .toast(message.options)
            .toast('show');
          
          // add custom Shiny input to listen to the toast state
          $(`#${message.id}`).on('hidden.bs.toast', function() {
            Shiny.setInputValue(message.id, true, {priority: 'event'});
          })
        });
      });
      "
    )
  ),
  tabler_toast(
    id = "toast", 
    title = "Hello", 
    subtitle = "now", 
    "Toast body",
    img = "https://preview-dev.tabler.io/static/logo.svg"
  ),
  tabler_button("launch", "Go!", width = "25%")
)

server <- function(input, output, session) {
  observe(print(input$toast))
  observeEvent(input$launch, {
    show_tabler_toast(
      "toast", 
      options = list(
        animation = FALSE,
        delay = 2000
      )
    )
  })
  
  observeEvent(input$toast, {
    showNotification(
      "Toast was closed", 
      type = "warning",
      duration = 1,
      
    )
  })
}

shinyApp(ui, server)
```


## Transform an element in a custom action button
As seen in Chapter \@ref(custom-templates-inputs), any `<button>`, `<a>` element holding the `action-button` class may eventually become an action button. The tabler template has dropdown menus in the navbar and we would like to transform dropdown items in action buttons. The `tabler_dropdown` functions takes the following parameters:

  - id is required by the `show_tabler_dropdown` (see below) function which opens the menu
  - title is the dropdown menu name
  - subtitle is optional text
  - img is an optional image
  - ... hosts the `tabler_dropdown_item` (see below)

```{r}
tabler_dropdown <- function(..., id = NULL, title, subtitle = NULL, img = NULL) {
  
  div(
    class = "nav-item dropdown",
    a(
      href = "#",
      id = id, 
      class = "nav-link d-flex lh-1 text-reset p-0",
      `data-toggle` = "dropdown",
      `aria-expanded` = "false",
      if (!is.null(img)) {
        span(class = "avatar", style = sprintf("background-image: url(%s)", img))
      },
      div(
        class = "d-none d-xl-block pl-2",
        div(title),
        if (!is.null(subtitle)) {
          div(class = "mt-1 small text-muted", subtitle)
        }
      )
    ),
    div(class = "dropdown-menu dropdown-menu-right", `aria-labelledby` = id, ...)
  )
}
```

To convert a dropdown item in an action button , we add the `action-button` class as well
as the `id` parameter to recover the corresponding input id.

```{r}
tabler_dropdown_item <- function(..., id = NULL) {
  a(id = id, class = "dropdown-item action-button", href = "#", ...)
}
```

We finally create the `show_tabler_dropdown` as well as the corresponding Shiny message handler.

```{r}
show_tabler_dropdown <- function(id, session = getDefaultReactiveDomain()) {
  session$sendCustomMessage(type = "show-dropdown", message = id)
}
```

To show the dropdown, we use the `dropdown` method which is linked to the `data-toggle="dropdown"` of `tabler_dropdown`. 

```javascript
$(function() {
  Shiny.addCustomMessageHandler('show-dropdown', function(message) {
    $(`#${message}`).dropdown('show');
  });
});
```

Let's play with it!

```{r, eval=FALSE}
ui <- tabler_page(
  tags$head(
    tags$script(
      "$(function() {
        Shiny.addCustomMessageHandler('show-dropdown', function(message) {
          $(`#${message}`).dropdown('show');
        });
      });
      "
    )
  ),
  tabler_navbar(
    brand_url = "https://preview-dev.tabler.io", 
    brand_image = "https://preview-dev.tabler.io/static/logo.svg", 
    nav_menu = NULL, 
    tabler_dropdown(
      id = "mydropdown",
      title = "Dropdown",
      subtitle = "click me",
      tabler_dropdown_item(
        id = "item1",
        "Show Notification"
      ),
      tabler_dropdown_item(
        "Do nothing"
      )
    )
  ),
  tabler_body(
    tabler_button("show", "Open dropdown", width = "25%"),
    footer = tabler_footer(
      left = "Rstats, 2020", 
      right = a(href = "https://www.google.com")
    )
  )
)
server <- function(input, output, session) {
  
  observeEvent(input$show, {
    show_tabler_dropdown("mydropdown")
  })
  
  observeEvent(input$item1, {
    showNotification(
      "Success", 
      type = "message",
      duration = 2,
      
    )
  })
}
shinyApp(ui, server)
```


## Tab events
Do you remember about the navbar element and the tabsetpanel system of Chapter \@ref(custom-templates-skeleton)? Navs allow to organize any app into several tabs, acting like pages. This is a powerful tool for Shiny since it is currently not straightforward to create [multi-pages](https://community.rstudio.com/t/shiny-app-composed-of-many-many-pages/7698) Shiny apps like anyone would do with a website. Navs relie on the Bootstrap4 API but we only used few JS functions.

### Insert/Remove tabs in tabsetpanel
How about dynamically inserting/removing tabs from a `tabler_navbar`? I chose this example since it involves extra technical details about Shiny.

TO DO: start with a naive approach, show it does not work and introduce `Shiny.renderContent`, `processDeps` ...

### More events
There exists [events](https://getbootstrap.com/docs/4.0/components/navs/#events) that trigger after/before showing/hiding a tabs, that is `hidden.bs.tab` and `shown.bs.tab` (`hide.bs.tab` and `show.bs.tab` are triggered before). For instance, we may recover
the previously selected tab, namely `e.relatedTarget`, and store it in a shiny input with `Shiny.setInputValue`:

```javascript
$(function() {
  $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
    Shiny.setInputValue('previous_tab', e.relatedTarget)
  });
});
```

TO FINISH